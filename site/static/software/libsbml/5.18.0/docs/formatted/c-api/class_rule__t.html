<!-- HTML header for Doxygen -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>libSBML C API: Rule_t Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="sbml.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="libSBML C API"/>
<link href="libsbml-doxygen-stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libSBML C API
   &#160;<span id="projectnumber">5.18.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="group__core.html"><span>Core&#160;libSBML</span></a></li>
      <li><a href="usergroup0.html"><span>Level&#160;3&#160;Extensions</span></a></li>
      <li class="current"><a href="annotated.html"><span>Structures,&#160;functions</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="libsbml-example-files-c.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="functions.html"><span>Functions</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_rule__t.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Rule_t Class Reference<div class="ingroups"><a class="el" href="group__core.html">Core libSBML</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"> Parent class for SBML <em>rules</em> in libSBML. </p>
<p>In SBML, <em>rules</em> provide additional ways to define the values of variables in a model, their relationships, and the dynamical behaviors of those variables. They enable encoding relationships that cannot be expressed using <a class="el" href="class_reaction__t.html" title=" An SBML reaction between species in an SBML model. ">Reaction_t</a> nor <a class="el" href="class_initial_assignment__t.html" title=" An SBML initial assignment, evaluated once only. ">InitialAssignment_t</a> objects alone.</p>
<p>The libSBML implementation of rules mirrors the SBML Level&#160;3 definition (which is in turn is very similar to the Level&#160;2 Version&#160;4 definition), with <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> being the parent class of three subclasses as explained below. The <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> class itself cannot be instantiated by user programs and has no constructor; only the subclasses <a class="el" href="class_assignment_rule__t.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule_t</a>, <a class="el" href="class_algebraic_rule__t.html" title=" An SBML algebraic rule representing 0 = f(W). ">AlgebraicRule_t</a> and <a class="el" href="class_rate_rule__t.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule_t</a> can be instantiated directly.</p>
<h1><a class="anchor" id="rules-general"></a>
General summary of SBML rules</h1>
<p>In SBML Level&#160;3 as well as Level&#160;2, rules are separated into three subclasses for the benefit of model analysis software. The three subclasses are based on the following three different possible functional forms (where <em>x</em> is a variable, <em>f</em> is some arbitrary function returning a numerical result, <b><em>V</em></b> is a vector of variables that does not include <em>x</em>, and <b><em>W</em></b> is a vector of variables that may include <em>x</em>):</p>
<table  border="0" cellpadding="0" class="centered" style="font-size: small">
<tr>
<td width="120px"><em>Algebraic:</em></td><td width="250px">left-hand side is zero</td><td><em>0 = f(<b>W</b>)</em> </td></tr>
<tr>
<td><em>Assignment:</em></td><td>left-hand side is a scalar:</td><td><em>x = f(<b>V</b>)</em> </td></tr>
<tr>
<td><em>Rate:</em></td><td>left-hand side is a rate-of-change:</td><td><em>dx/dt = f(<b>W</b>)</em> </td></tr>
</table>
<p>In their general form given above, there is little to distinguish between <em>assignment</em> and <em>algebraic</em> rules. They are treated as separate cases for the following reasons:</p>
<ul>
<li><em>Assignment</em> rules can simply be evaluated to calculate intermediate values for use in numerical methods. They are statements of equality that hold at all times. (For assignments that are only performed once, see <a class="el" href="class_initial_assignment__t.html" title=" An SBML initial assignment, evaluated once only. ">InitialAssignment_t</a>.)</li>
</ul>
<ul>
<li>SBML needs to place restrictions on assignment rules, for example the restriction that assignment rules cannot contain algebraic loops.</li>
</ul>
<ul>
<li>Some simulators do not contain numerical solvers capable of solving unconstrained algebraic equations, and providing more direct forms such as assignment rules may enable those simulators to process models they could not process if the same assignments were put in the form of general algebraic equations;</li>
</ul>
<ul>
<li>Those simulators that <em>can</em> solve these algebraic equations make a distinction between the different categories listed above; and</li>
</ul>
<ul>
<li>Some specialized numerical analyses of models may only be applicable to models that do not contain <em>algebraic</em> rules.</li>
</ul>
<p>The approach taken to covering these cases in SBML is to define an abstract <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> structure containing a subelement, "math", to hold the right-hand side expression, then to derive subtypes of <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> that add attributes to distinguish the cases of algebraic, assignment and rate rules. The "math" subelement must contain a MathML expression defining the mathematical formula of the rule. This MathML formula must return a numerical value. The formula can be an arbitrary expression referencing the variables and other entities in an SBML model.</p>
<p>Each of the three subclasses of <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> (<a class="el" href="class_assignment_rule__t.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule_t</a>, <a class="el" href="class_algebraic_rule__t.html" title=" An SBML algebraic rule representing 0 = f(W). ">AlgebraicRule_t</a>, <a class="el" href="class_rate_rule__t.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule_t</a>) inherit the the "math" subelement and other fields from <a class="el" href="class_s_base__t.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase_t</a>. The <a class="el" href="class_assignment_rule__t.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule_t</a> and <a class="el" href="class_rate_rule__t.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule_t</a> classes add an additional attribute, "variable". See the definitions of <a class="el" href="class_assignment_rule__t.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule_t</a>, <a class="el" href="class_algebraic_rule__t.html" title=" An SBML algebraic rule representing 0 = f(W). ">AlgebraicRule_t</a> and <a class="el" href="class_rate_rule__t.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule_t</a> for details about the structure and interpretation of each one.</p>
<h1><a class="anchor" id="rules-restrictions"></a>
Additional restrictions on SBML rules</h1>
<p>An important design goal of SBML rule semantics is to ensure that a model's simulation and analysis results will not be dependent on when or how often rules are evaluated. To achieve this, SBML needs to place two restrictions on rule use. The first concerns algebraic loops in the system of assignments in a model, and the second concerns overdetermined systems.</p>
<h2><a class="anchor" id="rules-no-loops"></a>
A model must not contain algebraic loops</h2>
<p>The combined set of <a class="el" href="class_initial_assignment__t.html" title=" An SBML initial assignment, evaluated once only. ">InitialAssignment_t</a>, <a class="el" href="class_assignment_rule__t.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule_t</a> and <a class="el" href="class_kinetic_law__t.html" title=" The rate expression for an SBML reaction. ">KineticLaw_t</a> objects in a model constitute a set of assignment statements that should be considered as a whole. (A <a class="el" href="class_kinetic_law__t.html" title=" The rate expression for an SBML reaction. ">KineticLaw_t</a> object is counted as an assignment because it assigns a value to the symbol contained in the "id" attribute of the <a class="el" href="class_reaction__t.html" title=" An SBML reaction between species in an SBML model. ">Reaction_t</a> object in which it is defined.) This combined set of assignment statements must not contain algebraic loops&mdash;dependency chains between these statements must terminate. To put this more formally, consider a directed graph in which nodes are assignment statements and directed arcs exist for each occurrence of an SBML species, compartment or parameter symbol in an assignment statement's "math" subelement. Let the directed arcs point from the statement assigning the symbol to the statements that contain the symbol in their "math" subelement expressions. This graph must be acyclic.</p>
<p>Similarly, the combined set of <a class="el" href="class_rate_rule__t.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule_t</a> and <a class="el" href="class_reaction__t.html" title=" An SBML reaction between species in an SBML model. ">Reaction_t</a> objects constitute a set of definitions for the rates of change of various model entities (namely, the objects identified by the values of the 'variable' attributes of the <a class="el" href="class_rate_rule__t.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule_t</a> objects, and the 'species' attributes of the <a class="el" href="class_species_reference__t.html" title=" A reference to an SBML species in a reaction. ">SpeciesReference_t</a> objects in each <a class="el" href="class_reaction__t.html" title=" An SBML reaction between species in an SBML model. ">Reaction_t</a>). In SBML Level&#160;3 Version&#160;2, these rates of change may be referenced directly using the <em>rateOf</em> csymbol, but may not thereby contain algebraic loops&mdash;dependency chains between these statements must terminate. More formally, consider a directed graph in which the nodes are the definitions of different variables' rates of change, and directed arcs exist for each occurrence of a variable referenced by a <em>rateOf</em> csymbol from any <a class="el" href="class_rate_rule__t.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule_t</a> or <a class="el" href="class_kinetic_law__t.html" title=" The rate expression for an SBML reaction. ">KineticLaw_t</a> object in the model. Let the directed arcs point from the variable referenced by the <em>rateOf</em> csymbol (call it <em>x</em>) to the variable(s) determined by the 'math' expression in which <em>x</em> appears. This graph must be acyclic.</p>
<p>SBML does not specify when or how often rules should be evaluated. Eliminating algebraic loops ensures that assignment statements can be evaluated any number of times without the result of those evaluations changing. As an example, consider the set of equations <em>x = x + 1</em>, <em>y = z + 200</em> and <em>z = y + 100</em>. If this set of equations were interpreted as a set of assignment statements, it would be invalid because the rule for <em>x</em> refers to <em>x</em> (exhibiting one type of loop), and the rule for <em>y</em> refers to <em>z</em> while the rule for <em>z</em> refers back to <em>y</em> (exhibiting another type of loop). Conversely, the following set of equations would constitute a valid set of assignment statements: <em>x = 10</em>, <em>y = z + 200</em>, and <em>z = x + 100</em>.</p>
<h2><a class="anchor" id="rules-not-overdetermined"></a>
A model must not be overdetermined</h2>
<p>An SBML model must not be overdetermined; that is, a model must not define more equations than there are unknowns in a model. A valid SBML model that does not contain <a class="el" href="class_algebraic_rule__t.html" title=" An SBML algebraic rule representing 0 = f(W). ">AlgebraicRule_t</a> structures cannot be overdetermined.</p>
<p>LibSBML implements the static analysis procedure described in Appendix&#160;B of the SBML Level&#160;3 specification for assessing whether a model is overdetermined.</p>
<p>(In summary, assessing whether a given continuous, deterministic, mathematical model is overdetermined does not require dynamic analysis; it can be done by analyzing the system of equations created from the model. One approach is to construct a bipartite graph in which one set of vertices represents the variables and the other the set of vertices represents the equations. Place edges between vertices such that variables in the system are linked to the equations that determine them. For algebraic equations, there will be edges between the equation and each variable occurring in the equation. For ordinary differential equations (such as those defined by rate rules or implied by the reaction rate definitions), there will be a single edge between the equation and the variable determined by that differential equation. A mathematical model is overdetermined if the maximal matchings of the bipartite graph contain disconnected vertexes representing equations. If one maximal matching has this property, then all the maximal matchings will have this property; i.e., it is only necessary to find one maximal matching.)</p>
<h1><a class="anchor" id="RuleType_t"></a>
Rule_t types for SBML Level 1</h1>
<p>SBML Level 1 uses a different scheme than SBML Level 2 and Level 3 for distinguishing rules; specifically, it uses an attribute whose value is drawn from an enumeration of 3 values. LibSBML supports this using methods that work a libSBML enumeration type, <a class="el" href="_rule_8h.html#ad5d6b2dda840b827f5c4857296c739a7">RuleType_t</a>, whose values are listed below.</p>
<ul>
<li><a class="el" href="_rule_8h.html#ad5d6b2dda840b827f5c4857296c739a7ae4b2aaaecdabc4d50eadea4e61b09f2d">RULE_TYPE_RATE</a>: Indicates the rule is a "rate" rule. </li>
<li><a class="el" href="_rule_8h.html#ad5d6b2dda840b827f5c4857296c739a7a23d32c5ba722ac969aa49899aedad2e4">RULE_TYPE_SCALAR</a>: Indicates the rule is a "scalar" rule. </li>
<li><a class="el" href="_rule_8h.html#ad5d6b2dda840b827f5c4857296c739a7ad703ec8a3f92b80ae3f118cc96086a35">RULE_TYPE_INVALID</a>: Indicates the rule type is unknown or not yet set. </li>
</ul>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="print_annotation_8c-example.html#_a49">printAnnotation.c</a>, <a class="el" href="print_math_8c-example.html#_a10">printMath.c</a>, <a class="el" href="print_notes_8c-example.html#_a49">printNotes.c</a>, <a class="el" href="print_units_8c-example.html#_a55">printUnits.c</a>, <a class="el" href="unset_annotation_8c-example.html#_a40">unsetAnnotation.c</a>, and <a class="el" href="unset_notes_8c-example.html#_a40">unsetNotes.c</a>.</dd>
</dl></div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2f8b8555529a3d3c478c9be0d733691e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a2f8b8555529a3d3c478c9be0d733691e">Rule_clone</a> (const <a class="el" href="class_rule__t.html">Rule_t</a> *r)</td></tr>
<tr class="separator:a2f8b8555529a3d3c478c9be0d733691e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780da083143b3c3b6c25a10d85ea62ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a780da083143b3c3b6c25a10d85ea62ab">Rule_containsUndeclaredUnits</a> (<a class="el" href="class_rule__t.html">Rule_t</a> *ia)</td></tr>
<tr class="memdesc:a780da083143b3c3b6c25a10d85ea62ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>1</code> (true) or <code>0</code> (false) depending on whether the math expression of this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> contains parameters/numbers with undeclared units.  <a href="#a780da083143b3c3b6c25a10d85ea62ab">More...</a><br /></td></tr>
<tr class="separator:a780da083143b3c3b6c25a10d85ea62ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5326daaed309245f0164370fa55c199a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a5326daaed309245f0164370fa55c199a">Rule_createAlgebraic</a> (unsigned int level, unsigned int version)</td></tr>
<tr class="memdesc:a5326daaed309245f0164370fa55c199a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_algebraic_rule__t.html" title=" An SBML algebraic rule representing 0 = f(W). ">AlgebraicRule_t</a> (<a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>) structure using the given SBML <code>level</code> and <code>version</code> values.  <a href="#a5326daaed309245f0164370fa55c199a">More...</a><br /></td></tr>
<tr class="separator:a5326daaed309245f0164370fa55c199a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695ba482e8870a324864c0932e99e73a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a695ba482e8870a324864c0932e99e73a">Rule_createAlgebraicWithNS</a> (<a class="el" href="class_s_b_m_l_namespaces__t.html">SBMLNamespaces_t</a> *sbmlns)</td></tr>
<tr class="memdesc:a695ba482e8870a324864c0932e99e73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_algebraic_rule__t.html" title=" An SBML algebraic rule representing 0 = f(W). ">AlgebraicRule_t</a> (<a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>) structure using the given <a class="el" href="class_s_b_m_l_namespaces__t.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces_t</a> structure.  <a href="#a695ba482e8870a324864c0932e99e73a">More...</a><br /></td></tr>
<tr class="separator:a695ba482e8870a324864c0932e99e73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a6a55fadc4c75a790b42c1bb6a3e99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a02a6a55fadc4c75a790b42c1bb6a3e99">Rule_createAssignment</a> (unsigned int level, unsigned int version)</td></tr>
<tr class="memdesc:a02a6a55fadc4c75a790b42c1bb6a3e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_assignment_rule__t.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule_t</a> (<a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>) structure using the given SBML <code>level</code> and <code>version</code> values.  <a href="#a02a6a55fadc4c75a790b42c1bb6a3e99">More...</a><br /></td></tr>
<tr class="separator:a02a6a55fadc4c75a790b42c1bb6a3e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ca6c71538d504080055034c659442c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a73ca6c71538d504080055034c659442c">Rule_createAssignmentWithNS</a> (<a class="el" href="class_s_b_m_l_namespaces__t.html">SBMLNamespaces_t</a> *sbmlns)</td></tr>
<tr class="memdesc:a73ca6c71538d504080055034c659442c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_assignment_rule__t.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule_t</a> (<a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>) structure using the given <a class="el" href="class_s_b_m_l_namespaces__t.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces_t</a> structure.  <a href="#a73ca6c71538d504080055034c659442c">More...</a><br /></td></tr>
<tr class="separator:a73ca6c71538d504080055034c659442c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b17f1763a1d3cde241cde893303d5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#ac1b17f1763a1d3cde241cde893303d5b">Rule_createRate</a> (unsigned int level, unsigned int version)</td></tr>
<tr class="memdesc:ac1b17f1763a1d3cde241cde893303d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_rate_rule__t.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule_t</a> (<a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>) structure using the given SBML <code>level</code> and <code>version</code> values.  <a href="#ac1b17f1763a1d3cde241cde893303d5b">More...</a><br /></td></tr>
<tr class="separator:ac1b17f1763a1d3cde241cde893303d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e4adcfe2df9d68ffbd6fd004ed0a41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a06e4adcfe2df9d68ffbd6fd004ed0a41">Rule_createRateWithNS</a> (<a class="el" href="class_s_b_m_l_namespaces__t.html">SBMLNamespaces_t</a> *sbmlns)</td></tr>
<tr class="memdesc:a06e4adcfe2df9d68ffbd6fd004ed0a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_rate_rule__t.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule_t</a> (<a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>) structure using the given <a class="el" href="class_s_b_m_l_namespaces__t.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces_t</a> structure.  <a href="#a06e4adcfe2df9d68ffbd6fd004ed0a41">More...</a><br /></td></tr>
<tr class="separator:a06e4adcfe2df9d68ffbd6fd004ed0a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72878ade88c285cf2d85381aa4dae289"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a72878ade88c285cf2d85381aa4dae289">Rule_free</a> (<a class="el" href="class_rule__t.html">Rule_t</a> *r)</td></tr>
<tr class="memdesc:a72878ade88c285cf2d85381aa4dae289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>.  <a href="#a72878ade88c285cf2d85381aa4dae289">More...</a><br /></td></tr>
<tr class="separator:a72878ade88c285cf2d85381aa4dae289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4155372131bbd122a599fd7cebce98a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_definition__t.html">UnitDefinition_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#ab4155372131bbd122a599fd7cebce98a">Rule_getDerivedUnitDefinition</a> (<a class="el" href="class_rule__t.html">Rule_t</a> *ia)</td></tr>
<tr class="memdesc:ab4155372131bbd122a599fd7cebce98a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns a <a class="el" href="class_unit_definition__t.html" title=" A definition of a unit used in an SBML model. ">UnitDefinition_t</a> that expresses the units returned by the math expression of this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>.  <a href="#ab4155372131bbd122a599fd7cebce98a">More...</a><br /></td></tr>
<tr class="separator:ab4155372131bbd122a599fd7cebce98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88bb6b769a21957773b347545a4ff7a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#ad88bb6b769a21957773b347545a4ff7a">Rule_getFormula</a> (const <a class="el" href="class_rule__t.html">Rule_t</a> *r)</td></tr>
<tr class="separator:ad88bb6b769a21957773b347545a4ff7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c308d5b3f51c429b4c91f34b5af11d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a83c308d5b3f51c429b4c91f34b5af11d">Rule_getL1TypeCode</a> (const <a class="el" href="class_rule__t.html">Rule_t</a> *r)</td></tr>
<tr class="separator:a83c308d5b3f51c429b4c91f34b5af11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152d510dba1422726f3ff25aa8f1e5bf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a152d510dba1422726f3ff25aa8f1e5bf">Rule_getMath</a> (const <a class="el" href="class_rule__t.html">Rule_t</a> *r)</td></tr>
<tr class="separator:a152d510dba1422726f3ff25aa8f1e5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f03985065bcc7ac3e95de68b29e18c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_x_m_l_namespaces__t.html">XMLNamespaces_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a25f03985065bcc7ac3e95de68b29e18c">Rule_getNamespaces</a> (<a class="el" href="class_rule__t.html">Rule_t</a> *r)</td></tr>
<tr class="memdesc:a25f03985065bcc7ac3e95de68b29e18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of <a class="el" href="class_x_m_l_namespaces__t.html" title=" An XML Namespace. ">XMLNamespaces_t</a> associated with this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> structure.  <a href="#a25f03985065bcc7ac3e95de68b29e18c">More...</a><br /></td></tr>
<tr class="separator:a25f03985065bcc7ac3e95de68b29e18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cc26c509ff4d021dbed89d93c11881"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_rule_8h.html#ad5d6b2dda840b827f5c4857296c739a7">RuleType_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a38cc26c509ff4d021dbed89d93c11881">Rule_getType</a> (const <a class="el" href="class_rule__t.html">Rule_t</a> *r)</td></tr>
<tr class="memdesc:a38cc26c509ff4d021dbed89d93c11881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a code representing the type of rule this is.  <a href="#a38cc26c509ff4d021dbed89d93c11881">More...</a><br /></td></tr>
<tr class="separator:a38cc26c509ff4d021dbed89d93c11881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6656992f879fe56ea5ec75d1bcc204d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a6656992f879fe56ea5ec75d1bcc204d4">Rule_getTypeCode</a> (const <a class="el" href="class_rule__t.html">Rule_t</a> *r)</td></tr>
<tr class="memdesc:a6656992f879fe56ea5ec75d1bcc204d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the libSBML type code for this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> object.  <a href="#a6656992f879fe56ea5ec75d1bcc204d4">More...</a><br /></td></tr>
<tr class="separator:a6656992f879fe56ea5ec75d1bcc204d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab604d0b429d96a7b809c38d9378703dd"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#ab604d0b429d96a7b809c38d9378703dd">Rule_getUnits</a> (const <a class="el" href="class_rule__t.html">Rule_t</a> *r)</td></tr>
<tr class="separator:ab604d0b429d96a7b809c38d9378703dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345044740a11c0cc29210ab18abc45cb"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a345044740a11c0cc29210ab18abc45cb">Rule_getVariable</a> (const <a class="el" href="class_rule__t.html">Rule_t</a> *r)</td></tr>
<tr class="separator:a345044740a11c0cc29210ab18abc45cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d487a5ac41b1e31b11a47d4db4539b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#ac4d487a5ac41b1e31b11a47d4db4539b">Rule_isAlgebraic</a> (const <a class="el" href="class_rule__t.html">Rule_t</a> *r)</td></tr>
<tr class="separator:ac4d487a5ac41b1e31b11a47d4db4539b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359dbba3e8cf44336aaadfcd88af5ebf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a359dbba3e8cf44336aaadfcd88af5ebf">Rule_isAssignment</a> (const <a class="el" href="class_rule__t.html">Rule_t</a> *r)</td></tr>
<tr class="separator:a359dbba3e8cf44336aaadfcd88af5ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f843659aa91d8ce9282dae27532d1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a19f843659aa91d8ce9282dae27532d1e">Rule_isCompartmentVolume</a> (const <a class="el" href="class_rule__t.html">Rule_t</a> *r)</td></tr>
<tr class="memdesc:a19f843659aa91d8ce9282dae27532d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method attempts to lookup the <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>'s variable in the <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a>'s list of Compartments.  <a href="#a19f843659aa91d8ce9282dae27532d1e">More...</a><br /></td></tr>
<tr class="separator:a19f843659aa91d8ce9282dae27532d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013aa3db90ed1c3e53c530efd7ff619e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a013aa3db90ed1c3e53c530efd7ff619e">Rule_isParameter</a> (const <a class="el" href="class_rule__t.html">Rule_t</a> *r)</td></tr>
<tr class="memdesc:a013aa3db90ed1c3e53c530efd7ff619e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method attempts to lookup the <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>'s variable in the <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a>'s list of Parameters.  <a href="#a013aa3db90ed1c3e53c530efd7ff619e">More...</a><br /></td></tr>
<tr class="separator:a013aa3db90ed1c3e53c530efd7ff619e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8fcad2394f5fcd3dca76ed01f9e7e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a9c8fcad2394f5fcd3dca76ed01f9e7e3">Rule_isRate</a> (const <a class="el" href="class_rule__t.html">Rule_t</a> *r)</td></tr>
<tr class="separator:a9c8fcad2394f5fcd3dca76ed01f9e7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771e4c0237e8a0cabf37f81a660b2dd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a771e4c0237e8a0cabf37f81a660b2dd2">Rule_isScalar</a> (const <a class="el" href="class_rule__t.html">Rule_t</a> *r)</td></tr>
<tr class="separator:a771e4c0237e8a0cabf37f81a660b2dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1114514da13d12ca0b81204d482cb3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#aaf1114514da13d12ca0b81204d482cb3">Rule_isSetFormula</a> (const <a class="el" href="class_rule__t.html">Rule_t</a> *r)</td></tr>
<tr class="separator:aaf1114514da13d12ca0b81204d482cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b84647e92f40a4d682cd9551b8aec0b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a1b84647e92f40a4d682cd9551b8aec0b">Rule_isSetMath</a> (const <a class="el" href="class_rule__t.html">Rule_t</a> *r)</td></tr>
<tr class="separator:a1b84647e92f40a4d682cd9551b8aec0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fee09ec47799d33a89b1a283487ec4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a43fee09ec47799d33a89b1a283487ec4">Rule_isSetUnits</a> (const <a class="el" href="class_rule__t.html">Rule_t</a> *r)</td></tr>
<tr class="separator:a43fee09ec47799d33a89b1a283487ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3defc008ee9e1911993f2895f3825f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a5b3defc008ee9e1911993f2895f3825f">Rule_isSetVariable</a> (const <a class="el" href="class_rule__t.html">Rule_t</a> *r)</td></tr>
<tr class="separator:a5b3defc008ee9e1911993f2895f3825f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04788c4709312e6525bfd6e39196ab1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a04788c4709312e6525bfd6e39196ab1e">Rule_isSpeciesConcentration</a> (const <a class="el" href="class_rule__t.html">Rule_t</a> *r)</td></tr>
<tr class="memdesc:a04788c4709312e6525bfd6e39196ab1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method attempts to lookup the <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>'s variable in the <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a>'s list of <a class="el" href="class_species__t.html" title=" An SBML species â€“ a pool of entities. ">Species_t</a>.  <a href="#a04788c4709312e6525bfd6e39196ab1e">More...</a><br /></td></tr>
<tr class="separator:a04788c4709312e6525bfd6e39196ab1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26e81f5f331caa1046461cc7c3fa254"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#aa26e81f5f331caa1046461cc7c3fa254">Rule_setFormula</a> (<a class="el" href="class_rule__t.html">Rule_t</a> *r, const char *formula)</td></tr>
<tr class="memdesc:aa26e81f5f331caa1046461cc7c3fa254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the formula of this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> to a copy of string.  <a href="#aa26e81f5f331caa1046461cc7c3fa254">More...</a><br /></td></tr>
<tr class="separator:aa26e81f5f331caa1046461cc7c3fa254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade604971c62bbd8f95ad463deff7d237"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#ade604971c62bbd8f95ad463deff7d237">Rule_setL1TypeCode</a> (<a class="el" href="class_rule__t.html">Rule_t</a> *r, int L1Type)</td></tr>
<tr class="memdesc:ade604971c62bbd8f95ad463deff7d237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the SBML Level&#160;1 typecode for this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>.  <a href="#ade604971c62bbd8f95ad463deff7d237">More...</a><br /></td></tr>
<tr class="separator:ade604971c62bbd8f95ad463deff7d237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a08046535866f00057d29274dabd4c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a5a08046535866f00057d29274dabd4c6">Rule_setMath</a> (<a class="el" href="class_rule__t.html">Rule_t</a> *r, const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *math)</td></tr>
<tr class="memdesc:a5a08046535866f00057d29274dabd4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the math of this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> to a copy of the given <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a>.  <a href="#a5a08046535866f00057d29274dabd4c6">More...</a><br /></td></tr>
<tr class="separator:a5a08046535866f00057d29274dabd4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa834a2b5b2bca02fc8d8ab9f2bb3b3b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#aa834a2b5b2bca02fc8d8ab9f2bb3b3b3">Rule_setUnits</a> (<a class="el" href="class_rule__t.html">Rule_t</a> *r, const char *sname)</td></tr>
<tr class="memdesc:aa834a2b5b2bca02fc8d8ab9f2bb3b3b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the units for this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> to a copy of sname (L1 ParameterRules only).  <a href="#aa834a2b5b2bca02fc8d8ab9f2bb3b3b3">More...</a><br /></td></tr>
<tr class="separator:aa834a2b5b2bca02fc8d8ab9f2bb3b3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05744459ef037c17afc6c955258988a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#af05744459ef037c17afc6c955258988a">Rule_setVariable</a> (<a class="el" href="class_rule__t.html">Rule_t</a> *r, const char *sid)</td></tr>
<tr class="memdesc:af05744459ef037c17afc6c955258988a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the variable of this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> to a copy of <code>sid</code>.  <a href="#af05744459ef037c17afc6c955258988a">More...</a><br /></td></tr>
<tr class="separator:af05744459ef037c17afc6c955258988a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9422cfcc477a0d47c2e7247f42ce90ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule__t.html#a9422cfcc477a0d47c2e7247f42ce90ee">Rule_unsetUnits</a> (<a class="el" href="class_rule__t.html">Rule_t</a> *r)</td></tr>
<tr class="memdesc:a9422cfcc477a0d47c2e7247f42ce90ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the units for this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> (L1 ParameterRules only).  <a href="#a9422cfcc477a0d47c2e7247f42ce90ee">More...</a><br /></td></tr>
<tr class="separator:a9422cfcc477a0d47c2e7247f42ce90ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2f8b8555529a3d3c478c9be0d733691e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rule__t.html">Rule_t</a> * Rule_clone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a (deep) copy of this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a780da083143b3c3b6c25a10d85ea62ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Rule_containsUndeclaredUnits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>ia</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicate returning <code>1</code> (true) or <code>0</code> (false) depending on whether the math expression of this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> contains parameters/numbers with undeclared units. </p>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> (true) if the math expression of this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> includes parameters/numbers with undeclared units, <code>0</code> (false) otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>a return value of <code>1</code> (true) indicates that the <a class="el" href="class_unit_definition__t.html" title=" A definition of a unit used in an SBML model. ">UnitDefinition_t</a> returned by the getDerivedUnitDefinition function may not accurately represent the units of the expression.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_rule__t.html#ab4155372131bbd122a599fd7cebce98a" title="Calculates and returns a UnitDefinition_t that expresses the units returned by the math expression of...">Rule_getDerivedUnitDefinition()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="print_units_8c-example.html#a58">printUnits.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a5326daaed309245f0164370fa55c199a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rule__t.html">Rule_t</a> * Rule_createAlgebraic </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_algebraic_rule__t.html" title=" An SBML algebraic rule representing 0 = f(W). ">AlgebraicRule_t</a> (<a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>) structure using the given SBML <code>level</code> and <code>version</code> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>an unsigned int, the SBML Level to assign to this algebraic <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>.</td></tr>
    <tr><td class="paramname">version</td><td>an unsigned int, the SBML Version to assign to this algebraic <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly created <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> structure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Attempting to add an object to an <a class="el" href="class_s_b_m_l_document__t.html" title=" Overall SBML container object. ">SBMLDocument_t</a> having a different combination of SBML Level, Version and XML namespaces than the object itself will result in an error at the time a caller attempts to make the addition. A parent object must have compatible Level, Version and XML namespaces. (Strictly speaking, a parent may also have more XML namespaces than a child, but the reverse is not permitted.) The restriction is necessary to ensure that an SBML model has a consistent overall structure. This requires callers to manage their objects carefully, but the benefit is increased flexibility in how models can be created by permitting callers to create objects bottom-up if desired. In situations where objects are not yet attached to parents (e.g., <a class="el" href="class_s_b_m_l_document__t.html" title=" Overall SBML container object. ">SBMLDocument_t</a>), knowledge of the intented SBML Level and Version help libSBML determine such things as whether it is valid to assign a particular value to an attribute. </dd></dl>

</div>
</div>
<a class="anchor" id="a695ba482e8870a324864c0932e99e73a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rule__t.html">Rule_t</a> * Rule_createAlgebraicWithNS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_b_m_l_namespaces__t.html">SBMLNamespaces_t</a> *&#160;</td>
          <td class="paramname"><em>sbmlns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_algebraic_rule__t.html" title=" An SBML algebraic rule representing 0 = f(W). ">AlgebraicRule_t</a> (<a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>) structure using the given <a class="el" href="class_s_b_m_l_namespaces__t.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces_t</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sbmlns</td><td><a class="el" href="class_s_b_m_l_namespaces__t.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces_t</a>, a pointer to an <a class="el" href="class_s_b_m_l_namespaces__t.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces_t</a> structure to assign to this algebraic <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly created <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> structure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Attempting to add an object to an <a class="el" href="class_s_b_m_l_document__t.html" title=" Overall SBML container object. ">SBMLDocument_t</a> having a different combination of SBML Level, Version and XML namespaces than the object itself will result in an error at the time a caller attempts to make the addition. A parent object must have compatible Level, Version and XML namespaces. (Strictly speaking, a parent may also have more XML namespaces than a child, but the reverse is not permitted.) The restriction is necessary to ensure that an SBML model has a consistent overall structure. This requires callers to manage their objects carefully, but the benefit is increased flexibility in how models can be created by permitting callers to create objects bottom-up if desired. In situations where objects are not yet attached to parents (e.g., <a class="el" href="class_s_b_m_l_document__t.html" title=" Overall SBML container object. ">SBMLDocument_t</a>), knowledge of the intented SBML Level and Version help libSBML determine such things as whether it is valid to assign a particular value to an attribute. </dd></dl>

</div>
</div>
<a class="anchor" id="a02a6a55fadc4c75a790b42c1bb6a3e99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rule__t.html">Rule_t</a> * Rule_createAssignment </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_assignment_rule__t.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule_t</a> (<a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>) structure using the given SBML <code>level</code> and <code>version</code> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>an unsigned int, the SBML Level to assign to this assignment <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>.</td></tr>
    <tr><td class="paramname">version</td><td>an unsigned int, the SBML Version to assign to this assignment <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly created <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> structure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Attempting to add an object to an <a class="el" href="class_s_b_m_l_document__t.html" title=" Overall SBML container object. ">SBMLDocument_t</a> having a different combination of SBML Level, Version and XML namespaces than the object itself will result in an error at the time a caller attempts to make the addition. A parent object must have compatible Level, Version and XML namespaces. (Strictly speaking, a parent may also have more XML namespaces than a child, but the reverse is not permitted.) The restriction is necessary to ensure that an SBML model has a consistent overall structure. This requires callers to manage their objects carefully, but the benefit is increased flexibility in how models can be created by permitting callers to create objects bottom-up if desired. In situations where objects are not yet attached to parents (e.g., <a class="el" href="class_s_b_m_l_document__t.html" title=" Overall SBML container object. ">SBMLDocument_t</a>), knowledge of the intented SBML Level and Version help libSBML determine such things as whether it is valid to assign a particular value to an attribute. </dd></dl>

</div>
</div>
<a class="anchor" id="a73ca6c71538d504080055034c659442c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rule__t.html">Rule_t</a> * Rule_createAssignmentWithNS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_b_m_l_namespaces__t.html">SBMLNamespaces_t</a> *&#160;</td>
          <td class="paramname"><em>sbmlns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_assignment_rule__t.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule_t</a> (<a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>) structure using the given <a class="el" href="class_s_b_m_l_namespaces__t.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces_t</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sbmlns</td><td><a class="el" href="class_s_b_m_l_namespaces__t.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces_t</a>, a pointer to an <a class="el" href="class_s_b_m_l_namespaces__t.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces_t</a> structure to assign to this assignment <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly created <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> structure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Attempting to add an object to an <a class="el" href="class_s_b_m_l_document__t.html" title=" Overall SBML container object. ">SBMLDocument_t</a> having a different combination of SBML Level, Version and XML namespaces than the object itself will result in an error at the time a caller attempts to make the addition. A parent object must have compatible Level, Version and XML namespaces. (Strictly speaking, a parent may also have more XML namespaces than a child, but the reverse is not permitted.) The restriction is necessary to ensure that an SBML model has a consistent overall structure. This requires callers to manage their objects carefully, but the benefit is increased flexibility in how models can be created by permitting callers to create objects bottom-up if desired. In situations where objects are not yet attached to parents (e.g., <a class="el" href="class_s_b_m_l_document__t.html" title=" Overall SBML container object. ">SBMLDocument_t</a>), knowledge of the intented SBML Level and Version help libSBML determine such things as whether it is valid to assign a particular value to an attribute. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1b17f1763a1d3cde241cde893303d5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rule__t.html">Rule_t</a> * Rule_createRate </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_rate_rule__t.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule_t</a> (<a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>) structure using the given SBML <code>level</code> and <code>version</code> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>an unsigned int, the SBML Level to assign to this rate <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>.</td></tr>
    <tr><td class="paramname">version</td><td>an unsigned int, the SBML Version to assign to this rate <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly created <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> structure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Attempting to add an object to an <a class="el" href="class_s_b_m_l_document__t.html" title=" Overall SBML container object. ">SBMLDocument_t</a> having a different combination of SBML Level, Version and XML namespaces than the object itself will result in an error at the time a caller attempts to make the addition. A parent object must have compatible Level, Version and XML namespaces. (Strictly speaking, a parent may also have more XML namespaces than a child, but the reverse is not permitted.) The restriction is necessary to ensure that an SBML model has a consistent overall structure. This requires callers to manage their objects carefully, but the benefit is increased flexibility in how models can be created by permitting callers to create objects bottom-up if desired. In situations where objects are not yet attached to parents (e.g., <a class="el" href="class_s_b_m_l_document__t.html" title=" Overall SBML container object. ">SBMLDocument_t</a>), knowledge of the intented SBML Level and Version help libSBML determine such things as whether it is valid to assign a particular value to an attribute. </dd></dl>

</div>
</div>
<a class="anchor" id="a06e4adcfe2df9d68ffbd6fd004ed0a41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rule__t.html">Rule_t</a> * Rule_createRateWithNS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_b_m_l_namespaces__t.html">SBMLNamespaces_t</a> *&#160;</td>
          <td class="paramname"><em>sbmlns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_rate_rule__t.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule_t</a> (<a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>) structure using the given <a class="el" href="class_s_b_m_l_namespaces__t.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces_t</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sbmlns</td><td><a class="el" href="class_s_b_m_l_namespaces__t.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces_t</a>, a pointer to an <a class="el" href="class_s_b_m_l_namespaces__t.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces_t</a> structure to assign to this rate <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly created <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> structure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Attempting to add an object to an <a class="el" href="class_s_b_m_l_document__t.html" title=" Overall SBML container object. ">SBMLDocument_t</a> having a different combination of SBML Level, Version and XML namespaces than the object itself will result in an error at the time a caller attempts to make the addition. A parent object must have compatible Level, Version and XML namespaces. (Strictly speaking, a parent may also have more XML namespaces than a child, but the reverse is not permitted.) The restriction is necessary to ensure that an SBML model has a consistent overall structure. This requires callers to manage their objects carefully, but the benefit is increased flexibility in how models can be created by permitting callers to create objects bottom-up if desired. In situations where objects are not yet attached to parents (e.g., <a class="el" href="class_s_b_m_l_document__t.html" title=" Overall SBML container object. ">SBMLDocument_t</a>), knowledge of the intented SBML Level and Version help libSBML determine such things as whether it is valid to assign a particular value to an attribute. </dd></dl>

</div>
</div>
<a class="anchor" id="a72878ade88c285cf2d85381aa4dae289"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Rule_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>. </p>

</div>
</div>
<a class="anchor" id="ab4155372131bbd122a599fd7cebce98a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_definition__t.html">UnitDefinition_t</a> * Rule_getDerivedUnitDefinition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>ia</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates and returns a <a class="el" href="class_unit_definition__t.html" title=" A definition of a unit used in an SBML model. ">UnitDefinition_t</a> that expresses the units returned by the math expression of this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_unit_definition__t.html" title=" A definition of a unit used in an SBML model. ">UnitDefinition_t</a> that expresses the units of the math expression of this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>.</dd></dl>
<p>Note that the functionality that facilitates unit analysis depends on the model as a whole. Thus, in cases where the structure has not been added to a model or the model itself is incomplete, unit analysis is not possible and this method will return <code>NULL</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The units are calculated by applying the mathematics from the expression to the units of the &lt;ci&gt; elements used within the expression. Where there are parameters/numbers with undeclared units the <a class="el" href="class_unit_definition__t.html" title=" A definition of a unit used in an SBML model. ">UnitDefinition_t</a> returned by this function may not accurately represent the units of the expression.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_rule__t.html#a780da083143b3c3b6c25a10d85ea62ab" title="Predicate returning 1 (true) or 0 (false) depending on whether the math expression of this Rule_t con...">Rule_containsUndeclaredUnits()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="print_units_8c-example.html#a57">printUnits.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad88bb6b769a21957773b347545a4ff7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Rule_getFormula </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>SBML Level 1 uses a text-string format for mathematical formulas. Other levels of SBML use MathML, an XML format for representing mathematical expressions. LibSBML provides an Abstract Syntax Tree API for working with mathematical expressions; this API is more powerful than working with formulas directly in text form, and ASTs can be translated into either MathML or the text-string syntax. The libSBML methods that accept text-string formulas directly (such as this one) are provided for SBML Level 1 compatibility, but developers are encouraged to use the AST mechanisms.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the formula for this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a83c308d5b3f51c429b4c91f34b5af11d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Rule_getL1TypeCode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the SBML Level 1 typecode for this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> or <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfea0316def67cdf9a94d4605d7efeb3cc23">SBML_UNKNOWN</a> (default). </dd></dl>

</div>
</div>
<a class="anchor" id="a152d510dba1422726f3ff25aa8f1e5bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> * Rule_getMath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the math for this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="print_math_8c-example.html#a12">printMath.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a25f03985065bcc7ac3e95de68b29e18c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_x_m_l_namespaces__t.html">XMLNamespaces_t</a> * Rule_getNamespaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of <a class="el" href="class_x_m_l_namespaces__t.html" title=" An XML Namespace. ">XMLNamespaces_t</a> associated with this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the <a class="el" href="class_x_m_l_namespaces__t.html" title=" An XML Namespace. ">XMLNamespaces_t</a> structure associated with this structure </dd></dl>

</div>
</div>
<a class="anchor" id="a38cc26c509ff4d021dbed89d93c11881"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_rule_8h.html#ad5d6b2dda840b827f5c4857296c739a7">RuleType_t</a> Rule_getType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a code representing the type of rule this is. </p>
<dl class="section return"><dt>Returns</dt><dd>the rule type, which will be one of the following three possible values: <ul>
<li><a class="el" href="_rule_8h.html#ad5d6b2dda840b827f5c4857296c739a7ae4b2aaaecdabc4d50eadea4e61b09f2d">RULE_TYPE_RATE</a> </li>
<li><a class="el" href="_rule_8h.html#ad5d6b2dda840b827f5c4857296c739a7a23d32c5ba722ac969aa49899aedad2e4">RULE_TYPE_SCALAR</a> </li>
<li><a class="el" href="_rule_8h.html#ad5d6b2dda840b827f5c4857296c739a7ad703ec8a3f92b80ae3f118cc96086a35">RULE_TYPE_INVALID</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The attribute "type" on <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> objects is present only in SBML Level&#160;1. In SBML Level&#160;2 and later, the type has been replaced by subclassing the <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> object. </dd></dl>

</div>
</div>
<a class="anchor" id="a6656992f879fe56ea5ec75d1bcc204d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Rule_getTypeCode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the libSBML type code for this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> object. </p>
<dl class="section user"><dt></dt><dd>LibSBML attaches an identifying code to every kind of SBML object. These are integer constants known as <em>SBML type codes</em>. The names of all the codes begin with the characters <code>SBML_</code>. The set of possible type codes for core elements is defined in the enumeration <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfe" title="The enumeration of possible SBML core object types. ">SBMLTypeCode_t</a>, and in addition, libSBML plug-ins for SBML Level&#160;3 packages define their own extra enumerations of type codes (e.g., <a class="el" href="_layout_extension_8h.html#a6b80c825e1507341de5540b8e7de003d" title="SBMLFbcTypeCode_t Enumeration of possible types in the libSBML â€œlayoutâ€ package implementation...">SBMLLayoutTypeCode_t</a> for the Level&#160;3 <a class="el" href="class_layout__t.html" title=" The layout of a diagram of an SBML model. ">Layout_t</a> package). Note that different Level&#160;3 package plug-ins may use overlapping type codes; to identify the package to which a given object belongs, call the <code><a class="el" href="class_s_base__t.html#af4204c7a0391ed2cd2d4fa4da24dc284" title="Returns the package name for the given SBase_t structure. ">SBase_getPackageName()</a> </code> method on the object.</dd></dl>
<p>The exception to this is lists: all SBML-style list elements have the type <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfeaa111b52def73380487c84f062f47dadc">SBML_LIST_OF</a>, regardless of what package they are from.</p>
<dl class="section return"><dt>Returns</dt><dd>the SBML type code for this object, either <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfeaeb87df9f7e9efbabd7e92403ea4e1914">SBML_ASSIGNMENT_RULE</a>, <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfea8577e7f4bc6d014398fd8c0d75859427">SBML_RATE_RULE</a>, or <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfeab2d405a60c7a2a93ab2604858f1f3e1e">SBML_ALGEBRAIC_RULE</a> for SBML Core.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><span class="warning">The specific integer values of the possible type codes may be reused by different libSBML plug-ins for SBML Level&#160;3. packages, To fully identify the correct code, <b>it is necessary to invoke both getPackageName() and getTypeCode()</b> (or ListOf_t::getItemTypeCode()).</span></dd></dl>
<dl class="section see"><dt>See also</dt><dd>getElementName() </dd>
<dd>
getPackageName() </dd></dl>

</div>
</div>
<a class="anchor" id="ab604d0b429d96a7b809c38d9378703dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Rule_getUnits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the units for this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> (L1 ParameterRules only). </dd></dl>

</div>
</div>
<a class="anchor" id="a345044740a11c0cc29210ab18abc45cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Rule_getVariable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the variable for this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4d487a5ac41b1e31b11a47d4db4539b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Rule_isAlgebraic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>1</code> (true) if this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> is an <a class="el" href="class_algebraic_rule__t.html" title=" An SBML algebraic rule representing 0 = f(W). ">AlgebraicRule_t</a>, <code>0</code> (false) otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a359dbba3e8cf44336aaadfcd88af5ebf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Rule_isAssignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>1</code> (true) if this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> is an <a class="el" href="class_assignment_rule__t.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule_t</a>, <code>0</code> (false) otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a19f843659aa91d8ce9282dae27532d1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Rule_isCompartmentVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method attempts to lookup the <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>'s variable in the <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a>'s list of Compartments. </p>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> (true) if this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> is a CompartmentVolumeRule, <code>0</code> (false) otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a013aa3db90ed1c3e53c530efd7ff619e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Rule_isParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method attempts to lookup the <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>'s variable in the <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a>'s list of Parameters. </p>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> (true) if this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> is a ParameterRule, <code>0</code> (false) otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c8fcad2394f5fcd3dca76ed01f9e7e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Rule_isRate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>1</code> (true) if this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> is a <a class="el" href="class_rate_rule__t.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule_t</a> (L2) or has type="rate" (L1), <code>0</code> (false) otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a771e4c0237e8a0cabf37f81a660b2dd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Rule_isScalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>1</code> (true) if this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> is an <a class="el" href="class_assignment_rule__t.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule_t</a> (L2) has type="scalar" (L1), <code>0</code> (false) otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf1114514da13d12ca0b81204d482cb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Rule_isSetFormula </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>1</code> (true) if the formula (or equivalently the math) for this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> is set, <code>0</code> (false) otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b84647e92f40a4d682cd9551b8aec0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Rule_isSetMath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>1</code> (true) if the math (or equivalently the formula) for this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> is set, <code>0</code> (false) otherwise. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="print_math_8c-example.html#a11">printMath.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a43fee09ec47799d33a89b1a283487ec4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Rule_isSetUnits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>1</code> (true) if the units for this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> is set, <code>0</code> (false) otherwise (L1 ParameterRules only). </dd></dl>

</div>
</div>
<a class="anchor" id="a5b3defc008ee9e1911993f2895f3825f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Rule_isSetVariable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>1</code> (true) if the variable of this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> is set, <code>0</code> (false) otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a04788c4709312e6525bfd6e39196ab1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Rule_isSpeciesConcentration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method attempts to lookup the <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>'s variable in the <a class="el" href="class_model__t.html" title=" An SBML model. ">Model_t</a>'s list of <a class="el" href="class_species__t.html" title=" An SBML species â€“ a pool of entities. ">Species_t</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> (true) if this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> is a species concentration <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>, <code>0</code> (false) otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa26e81f5f331caa1046461cc7c3fa254"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Rule_setFormula </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>formula</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the formula of this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> to a copy of string. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>SBML Level 1 uses a text-string format for mathematical formulas. Other levels of SBML use MathML, an XML format for representing mathematical expressions. LibSBML provides an Abstract Syntax Tree API for working with mathematical expressions; this API is more powerful than working with formulas directly in text form, and ASTs can be translated into either MathML or the text-string syntax. The libSBML methods that accept text-string formulas directly (such as this one) are provided for SBML Level 1 compatibility, but developers are encouraged to use the AST mechanisms. </dd></dl>

</div>
</div>
<a class="anchor" id="ade604971c62bbd8f95ad463deff7d237"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Rule_setL1TypeCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>L1Type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the SBML Level&#160;1 typecode for this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> structure. </td></tr>
    <tr><td class="paramname">L1Type</td><td>the SBML Level&#160;1 typecode for this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> (<code>SBML_COMPARTMENT_VOLUME_RULE</code>, <code>SBML_PARAMETER_RULE</code>, or <code>SBML_SPECIES_CONCENTRATION_RULE</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5a08046535866f00057d29274dabd4c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Rule_setMath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node__t.html">ASTNode_t</a> *&#160;</td>
          <td class="paramname"><em>math</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the math of this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> to a copy of the given <a class="el" href="class_a_s_t_node__t.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode_t</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa834a2b5b2bca02fc8d8ab9f2bb3b3b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Rule_setUnits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the units for this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> to a copy of sname (L1 ParameterRules only). </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Using this function with an <code>sname</code> of NULL is equivalent to unsetting the "units" attribute. </dd></dl>

</div>
</div>
<a class="anchor" id="af05744459ef037c17afc6c955258988a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Rule_setVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the variable of this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> to a copy of <code>sid</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Using this function with an <code>sid</code> of NULL is equivalent to unsetting the "variable" attribute. </dd></dl>

</div>
</div>
<a class="anchor" id="a9422cfcc477a0d47c2e7247f42ce90ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Rule_unsetUnits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rule__t.html">Rule_t</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsets the units for this <a class="el" href="class_rule__t.html" title=" Parent class for SBML rules in libSBML. ">Rule_t</a> (L1 ParameterRules only). </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for Doxygen -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      Visit <a href="http://sbml.org">SBML.org</a> for more information
    about SBML and libSBML.
    </li>
   </ul>
</div>
</body>
</html>
