<!-- HTML header for Doxygen -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>libSBML C++ API: RateRule Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="sbml.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="libSBML C++ API"/>
<link href="libsbml-doxygen-stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libSBML C++ API
   &#160;<span id="projectnumber">5.18.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="group__core.html"><span>Core&#160;libSBML</span></a></li>
      <li><a href="usergroup0.html"><span>Level&#160;3&#160;Extensions</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="libsbml-example-files.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_rate_rule.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="class_rate_rule-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">RateRule Class Reference<div class="ingroups"><a class="el" href="group__core.html">Core libSBML</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for RateRule:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_rate_rule__inherit__graph.svg" width="88" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"> An SBML <em>rate rule</em> representing <em>dx/dt = f(<b>Y</b>)</em>. </p>
<p>The rule type <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> is derived from the parent class <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>. It is used to express equations that determine the rates of change of variables. The left-hand side (the "variable" attribute) can refer to the identifier of a species, compartment, or parameter (but not a reaction). The entity identified must have its "constant" attribute set to <code>false</code>. The effects of a <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> are in general terms the same, but differ in the precise details depending on which variable is being set:</p>
<ul>
<li>
<p class="startli"><em>In the case of a species</em>, a <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> sets the rate of change of the species' quantity (<em>concentration</em> or <em>amount of substance</em>) to the value determined by the formula in the "math" subelement of the <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> object. The overall units of the formula in "math" <em>should</em> (in SBML Level&#160;2 Version&#160;4 and in SBML Level&#160;3) or <em>must</em> (in SBML releases prior to Level&#160;2 version&#160;4) be equal to the unit of <em>species quantity</em> divided by the model-wide unit of <em>time</em>. <em>Restrictions</em>: There must not be both a <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> "variable" attribute and a <a class="el" href="class_species_reference.html" title=" A reference to an SBML species in a reaction. ">SpeciesReference</a> "species" attribute having the same value, unless that species has its "boundaryCondition" attribute is set to <code>true</code>. This means a rate rule cannot be defined for a species that is created or destroyed in a reaction, unless that species is defined as a boundary condition in the model.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">(For SBML Level&#160;3 only) <em>In the case of a species reference</em>, a <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> sets the rate of change of the stoichiometry of the referenced reactant or product to the value determined by the formula in "math". The unit associated with the value produced by the "math" formula should be consistent with the unit "dimensionless" divided by the model-wide unit of <em>time</em>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><em>In the case of a compartment</em>, a <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> sets the rate of change of the compartment's size to the value determined by the formula in the "math" subelement of the <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> object. The overall units of the formula <em>should</em> (in SBML Level&#160;2 Version&#160;4 and in SBML Level&#160;3) or <em>must</em> (in SBML releases prior to Level&#160;2 version&#160;4) be the units of the compartment's <em>size</em> divided by the model-wide unit of <em>time</em>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><em>In the case of a parameter</em>, a <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> sets the rate of change of the parameter's value to that determined by the formula in the "math" subelement of the <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> object. The overall units of the formula <em>should</em> (in SBML Level&#160;2 Version&#160;4 and in SBML Level&#160;3) or <em>must</em> (in SBML releases prior to Level&#160;2 version&#160;4) be the <a class="el" href="class_parameter.html" title=" An SBML parameter: a named symbol with a value. ">Parameter</a> object's "unit" attribute value divided by the model-wide unit of <em>time</em>.</p>
<p class="endli"></p>
</li>
<li>
(For SBML Level&#160;3 Version&#160;2 only) <em>In the case of an object from an SBML Level&#160;3 package</em>, a <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> sets the rate of change of the referenced object's value (as defined by that package) to the value of the formula in "math". The unit of measurement associated with the value produced by the formula should be the same as that object's units attribute value (if it has such an attribute) divided by the model-wide unit of <em>time</em>, or be equal to the units of model components of that type (if objects of that class are defined by the package as having the same units) divided by the model-wide unit of <em>time</em>. </li>
</ul>
<p>In SBML Level&#160;2 and Level&#160;3 Version&#160;1, the "math" subelement of the <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> is required. In SBML Level&#160;3 Version&#160;2, this rule is relaxed, and the subelement is optional. If a <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> with no "math" child is present in the model, the rate at which its referenced "variable" changes over time is undefined. This may represent a situation where the model itself is unfinished, or the missing information may be provided by an SBML Level&#160;3 package.</p>
<p>If the variable attribute of a <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> object references an object in an SBML namespace that is not understood by the interpreter reading a given SBML document (that is, if the object is defined by an SBML Level&#160;3 package that the software does not support), the rate rule must be ignored&ndash;the object's value will not need to be set, as the interpreter could not understand that package. If an interpreter cannot establish whether a referenced object is missing from the model or instead is defined in an SBML namespace not understood by the interpreter, it may produce a warning to the user. (The latter situation may only arise if an SBML package is present in the SBML document with a package:required attribute of "true".)</p>
<p>In the context of a simulation, rate rules are in effect for simulation time <em>t</em> &gt; <em>0</em>. Please consult the relevant SBML specification for additional information about the semantics of assignments, rules, and entity values for simulation time <em>t</em> <img class="formulaInl" alt="$\leq$" src="form_2.png"/> <em>0</em>.</p>
<p>As mentioned in the description of <a class="el" href="class_assignment_rule.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule</a>, a model must not contain more than one <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> or <a class="el" href="class_assignment_rule.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule</a> object having the same value of "variable"; in other words, in the set of all assignment rules and rate rules in an SBML model, each variable appearing in the left-hand sides can only appear once. This simply follows from the fact that an indeterminate system would result if a model contained more than one assignment rule for the same variable or both an assignment rule and a rate rule for the same variable.</p>
<h1><a class="anchor" id="rules-general"></a>
General summary of SBML rules</h1>
<p>In SBML Level&#160;3 as well as Level&#160;2, rules are separated into three subclasses for the benefit of model analysis software. The three subclasses are based on the following three different possible functional forms (where <em>x</em> is a variable, <em>f</em> is some arbitrary function returning a numerical result, <b><em>V</em></b> is a vector of variables that does not include <em>x</em>, and <b><em>W</em></b> is a vector of variables that may include <em>x</em>):</p>
<table  border="0" cellpadding="0" class="centered" style="font-size: small">
<tr>
<td width="120px"><em>Algebraic:</em></td><td width="250px">left-hand side is zero</td><td><em>0 = f(<b>W</b>)</em> </td></tr>
<tr>
<td><em>Assignment:</em></td><td>left-hand side is a scalar:</td><td><em>x = f(<b>V</b>)</em> </td></tr>
<tr>
<td><em>Rate:</em></td><td>left-hand side is a rate-of-change:</td><td><em>dx/dt = f(<b>W</b>)</em> </td></tr>
</table>
<p>In their general form given above, there is little to distinguish between <em>assignment</em> and <em>algebraic</em> rules. They are treated as separate cases for the following reasons:</p>
<ul>
<li><em>Assignment</em> rules can simply be evaluated to calculate intermediate values for use in numerical methods. They are statements of equality that hold at all times. (For assignments that are only performed once, see <a class="el" href="class_initial_assignment.html" title=" An SBML initial assignment, evaluated once only. ">InitialAssignment</a>.)</li>
</ul>
<ul>
<li>SBML needs to place restrictions on assignment rules, for example the restriction that assignment rules cannot contain algebraic loops.</li>
</ul>
<ul>
<li>Some simulators do not contain numerical solvers capable of solving unconstrained algebraic equations, and providing more direct forms such as assignment rules may enable those simulators to process models they could not process if the same assignments were put in the form of general algebraic equations;</li>
</ul>
<ul>
<li>Those simulators that <em>can</em> solve these algebraic equations make a distinction between the different categories listed above; and</li>
</ul>
<ul>
<li>Some specialized numerical analyses of models may only be applicable to models that do not contain <em>algebraic</em> rules.</li>
</ul>
<p>The approach taken to covering these cases in SBML is to define an abstract <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> structure containing a subelement, "math", to hold the right-hand side expression, then to derive subtypes of <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> that add attributes to distinguish the cases of algebraic, assignment and rate rules. The "math" subelement must contain a MathML expression defining the mathematical formula of the rule. This MathML formula must return a numerical value. The formula can be an arbitrary expression referencing the variables and other entities in an SBML model.</p>
<p>Each of the three subclasses of <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> (<a class="el" href="class_assignment_rule.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule</a>, <a class="el" href="class_algebraic_rule.html" title=" An SBML algebraic rule representing 0 = f(W). ">AlgebraicRule</a>, <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a>) inherit the the "math" subelement and other fields from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a>. The <a class="el" href="class_assignment_rule.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule</a> and <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> classes add an additional attribute, "variable". See the definitions of <a class="el" href="class_assignment_rule.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule</a>, <a class="el" href="class_algebraic_rule.html" title=" An SBML algebraic rule representing 0 = f(W). ">AlgebraicRule</a> and <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> for details about the structure and interpretation of each one.</p>
<h1><a class="anchor" id="rules-restrictions"></a>
Additional restrictions on SBML rules</h1>
<p>An important design goal of SBML rule semantics is to ensure that a model's simulation and analysis results will not be dependent on when or how often rules are evaluated. To achieve this, SBML needs to place two restrictions on rule use. The first concerns algebraic loops in the system of assignments in a model, and the second concerns overdetermined systems.</p>
<h2><a class="anchor" id="rules-no-loops"></a>
A model must not contain algebraic loops</h2>
<p>The combined set of <a class="el" href="class_initial_assignment.html" title=" An SBML initial assignment, evaluated once only. ">InitialAssignment</a>, <a class="el" href="class_assignment_rule.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule</a> and <a class="el" href="class_kinetic_law.html" title=" The rate expression for an SBML reaction. ">KineticLaw</a> objects in a model constitute a set of assignment statements that should be considered as a whole. (A <a class="el" href="class_kinetic_law.html" title=" The rate expression for an SBML reaction. ">KineticLaw</a> object is counted as an assignment because it assigns a value to the symbol contained in the "id" attribute of the <a class="el" href="class_reaction.html" title=" An SBML reaction between species in an SBML model. ">Reaction</a> object in which it is defined.) This combined set of assignment statements must not contain algebraic loops&mdash;dependency chains between these statements must terminate. To put this more formally, consider a directed graph in which nodes are assignment statements and directed arcs exist for each occurrence of an SBML species, compartment or parameter symbol in an assignment statement's "math" subelement. Let the directed arcs point from the statement assigning the symbol to the statements that contain the symbol in their "math" subelement expressions. This graph must be acyclic.</p>
<p>Similarly, the combined set of <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> and <a class="el" href="class_reaction.html" title=" An SBML reaction between species in an SBML model. ">Reaction</a> objects constitute a set of definitions for the rates of change of various model entities (namely, the objects identified by the values of the 'variable' attributes of the <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> objects, and the 'species' attributes of the <a class="el" href="class_species_reference.html" title=" A reference to an SBML species in a reaction. ">SpeciesReference</a> objects in each <a class="el" href="class_reaction.html" title=" An SBML reaction between species in an SBML model. ">Reaction</a>). In SBML Level&#160;3 Version&#160;2, these rates of change may be referenced directly using the <em>rateOf</em> csymbol, but may not thereby contain algebraic loops&mdash;dependency chains between these statements must terminate. More formally, consider a directed graph in which the nodes are the definitions of different variables' rates of change, and directed arcs exist for each occurrence of a variable referenced by a <em>rateOf</em> csymbol from any <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> or <a class="el" href="class_kinetic_law.html" title=" The rate expression for an SBML reaction. ">KineticLaw</a> object in the model. Let the directed arcs point from the variable referenced by the <em>rateOf</em> csymbol (call it <em>x</em>) to the variable(s) determined by the 'math' expression in which <em>x</em> appears. This graph must be acyclic.</p>
<p>SBML does not specify when or how often rules should be evaluated. Eliminating algebraic loops ensures that assignment statements can be evaluated any number of times without the result of those evaluations changing. As an example, consider the set of equations <em>x = x + 1</em>, <em>y = z + 200</em> and <em>z = y + 100</em>. If this set of equations were interpreted as a set of assignment statements, it would be invalid because the rule for <em>x</em> refers to <em>x</em> (exhibiting one type of loop), and the rule for <em>y</em> refers to <em>z</em> while the rule for <em>z</em> refers back to <em>y</em> (exhibiting another type of loop). Conversely, the following set of equations would constitute a valid set of assignment statements: <em>x = 10</em>, <em>y = z + 200</em>, and <em>z = x + 100</em>.</p>
<h2><a class="anchor" id="rules-not-overdetermined"></a>
A model must not be overdetermined</h2>
<p>An SBML model must not be overdetermined; that is, a model must not define more equations than there are unknowns in a model. A valid SBML model that does not contain <a class="el" href="class_algebraic_rule.html" title=" An SBML algebraic rule representing 0 = f(W). ">AlgebraicRule</a> structures cannot be overdetermined.</p>
<p>LibSBML implements the static analysis procedure described in Appendix&#160;B of the SBML Level&#160;3 specification for assessing whether a model is overdetermined.</p>
<p>(In summary, assessing whether a given continuous, deterministic, mathematical model is overdetermined does not require dynamic analysis; it can be done by analyzing the system of equations created from the model. One approach is to construct a bipartite graph in which one set of vertices represents the variables and the other the set of vertices represents the equations. Place edges between vertices such that variables in the system are linked to the equations that determine them. For algebraic equations, there will be edges between the equation and each variable occurring in the equation. For ordinary differential equations (such as those defined by rate rules or implied by the reaction rate definitions), there will be a single edge between the equation and the variable determined by that differential equation. A mathematical model is overdetermined if the maximal matchings of the bipartite graph contain disconnected vertexes representing equations. If one maximal matching has this property, then all the maximal matchings will have this property; i.e., it is only necessary to find one maximal matching.)</p>
<h1><a class="anchor" id="RuleType_t"></a>
Rule types for SBML Level 1</h1>
<p>SBML Level 1 uses a different scheme than SBML Level 2 and Level 3 for distinguishing rules; specifically, it uses an attribute whose value is drawn from an enumeration of 3 values. LibSBML supports this using methods that work a libSBML enumeration type, <a class="el" href="_rule_8h.html#ad5d6b2dda840b827f5c4857296c739a7">RuleType_t</a>, whose values are listed below.</p>
<ul>
<li><a class="el" href="_rule_8h.html#ad5d6b2dda840b827f5c4857296c739a7ae4b2aaaecdabc4d50eadea4e61b09f2d">RULE_TYPE_RATE</a>: Indicates the rule is a "rate" rule. </li>
<li><a class="el" href="_rule_8h.html#ad5d6b2dda840b827f5c4857296c739a7a23d32c5ba722ac969aa49899aedad2e4">RULE_TYPE_SCALAR</a>: Indicates the rule is a "scalar" rule. </li>
<li><a class="el" href="_rule_8h.html#ad5d6b2dda840b827f5c4857296c739a7ad703ec8a3f92b80ae3f118cc96086a35">RULE_TYPE_INVALID</a>: Indicates the rule type is unknown or not yet set. </li>
</ul>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a852e0bd8bfc64342750faf5cbccec65e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a852e0bd8bfc64342750faf5cbccec65e">addCVTerm</a> (<a class="el" href="class_c_v_term.html">CVTerm</a> *term, bool newBag=false)</td></tr>
<tr class="memdesc:a852e0bd8bfc64342750faf5cbccec65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a copy of the given <a class="el" href="class_c_v_term.html" title=" A MIRIAM-compliant controlled vocabulary term. ">CVTerm</a> object to this SBML object.  <a href="#a852e0bd8bfc64342750faf5cbccec65e">More...</a><br /></td></tr>
<tr class="separator:a852e0bd8bfc64342750faf5cbccec65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc96fb06a79df769eb3669e090771e5"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#accc96fb06a79df769eb3669e090771e5">appendAnnotation</a> (const <a class="el" href="class_x_m_l_node.html">XMLNode</a> *annotation)</td></tr>
<tr class="memdesc:accc96fb06a79df769eb3669e090771e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given <code>annotation</code> to the "annotation" subelement of this object.  <a href="#accc96fb06a79df769eb3669e090771e5">More...</a><br /></td></tr>
<tr class="separator:accc96fb06a79df769eb3669e090771e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118148398f5c626bf9697887296f97b8"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a118148398f5c626bf9697887296f97b8">appendAnnotation</a> (const std::string &amp;annotation)</td></tr>
<tr class="memdesc:a118148398f5c626bf9697887296f97b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given <code>annotation</code> to the "annotation" subelement of this object.  <a href="#a118148398f5c626bf9697887296f97b8">More...</a><br /></td></tr>
<tr class="separator:a118148398f5c626bf9697887296f97b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8c800163c108a27880bd644d7767ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#adb8c800163c108a27880bd644d7767ad">appendNotes</a> (const <a class="el" href="class_x_m_l_node.html">XMLNode</a> *notes)</td></tr>
<tr class="memdesc:adb8c800163c108a27880bd644d7767ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given <code>notes</code> to the "notes" subelement of this object.  <a href="#adb8c800163c108a27880bd644d7767ad">More...</a><br /></td></tr>
<tr class="separator:adb8c800163c108a27880bd644d7767ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33da5a2b0b03cbe6af69730869e35212"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a33da5a2b0b03cbe6af69730869e35212">appendNotes</a> (const std::string &amp;notes)</td></tr>
<tr class="memdesc:a33da5a2b0b03cbe6af69730869e35212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given <code>notes</code> to the "notes" subelement of this object.  <a href="#a33da5a2b0b03cbe6af69730869e35212">More...</a><br /></td></tr>
<tr class="separator:a33da5a2b0b03cbe6af69730869e35212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401b49483ec3e768f7f163a912bafb0c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_rate_rule.html">RateRule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rate_rule.html#a401b49483ec3e768f7f163a912bafb0c">clone</a> () const </td></tr>
<tr class="memdesc:a401b49483ec3e768f7f163a912bafb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a deep copy of this <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> object.  <a href="#a401b49483ec3e768f7f163a912bafb0c">More...</a><br /></td></tr>
<tr class="separator:a401b49483ec3e768f7f163a912bafb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7ed3391f84555629a74c3fe2ee7eec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#afa7ed3391f84555629a74c3fe2ee7eec">containsUndeclaredUnits</a> ()</td></tr>
<tr class="memdesc:afa7ed3391f84555629a74c3fe2ee7eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if the math expression of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> contains parameters/numbers with undeclared units.  <a href="#afa7ed3391f84555629a74c3fe2ee7eec">More...</a><br /></td></tr>
<tr class="separator:afa7ed3391f84555629a74c3fe2ee7eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285ba0b2d009817d33ffde742ed38966"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#a285ba0b2d009817d33ffde742ed38966">containsUndeclaredUnits</a> () const </td></tr>
<tr class="memdesc:a285ba0b2d009817d33ffde742ed38966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if the math expression of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> contains parameters/numbers with undeclared units.  <a href="#a285ba0b2d009817d33ffde742ed38966">More...</a><br /></td></tr>
<tr class="separator:a285ba0b2d009817d33ffde742ed38966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39cfac9d726a12e0f05c6e393953888"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ac39cfac9d726a12e0f05c6e393953888">deleteDisabledPlugins</a> (bool recursive=true)</td></tr>
<tr class="memdesc:ac39cfac9d726a12e0f05c6e393953888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all information stored in disabled plugins.  <a href="#ac39cfac9d726a12e0f05c6e393953888">More...</a><br /></td></tr>
<tr class="separator:ac39cfac9d726a12e0f05c6e393953888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe0e86c2c28a3226ddc42972241bddd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a5fe0e86c2c28a3226ddc42972241bddd">disablePackage</a> (const std::string &amp;pkgURI, const std::string &amp;pkgPrefix)</td></tr>
<tr class="memdesc:a5fe0e86c2c28a3226ddc42972241bddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the given SBML Level&#160;3 package on this object.  <a href="#a5fe0e86c2c28a3226ddc42972241bddd">More...</a><br /></td></tr>
<tr class="separator:a5fe0e86c2c28a3226ddc42972241bddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89a4757c093b8f9c491338bcb278921"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ae89a4757c093b8f9c491338bcb278921">enablePackage</a> (const std::string &amp;pkgURI, const std::string &amp;pkgPrefix, bool flag)</td></tr>
<tr class="memdesc:ae89a4757c093b8f9c491338bcb278921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables the given SBML Level&#160;3 package on this object.  <a href="#ae89a4757c093b8f9c491338bcb278921">More...</a><br /></td></tr>
<tr class="separator:ae89a4757c093b8f9c491338bcb278921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03cdef0daf939ae8f83b9a9ea24ff8a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_list.html">List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ab03cdef0daf939ae8f83b9a9ea24ff8a">getAllElements</a> (<a class="el" href="class_element_filter.html">ElementFilter</a> *filter=NULL)</td></tr>
<tr class="memdesc:ab03cdef0daf939ae8f83b9a9ea24ff8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_list.html" title=" Simple, plain, generic lists. ">List</a> of all child <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> objects, including those nested to an arbitrary depth.  <a href="#ab03cdef0daf939ae8f83b9a9ea24ff8a">More...</a><br /></td></tr>
<tr class="separator:ab03cdef0daf939ae8f83b9a9ea24ff8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0143961ca5188d00203c99eef1de854e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_list.html">List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a0143961ca5188d00203c99eef1de854e">getAllElementsFromPlugins</a> (<a class="el" href="class_element_filter.html">ElementFilter</a> *filter=NULL)</td></tr>
<tr class="memdesc:a0143961ca5188d00203c99eef1de854e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="class_list.html" title=" Simple, plain, generic lists. ">List</a> of all child <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> objects contained in SBML package plug-ins.  <a href="#a0143961ca5188d00203c99eef1de854e">More...</a><br /></td></tr>
<tr class="separator:a0143961ca5188d00203c99eef1de854e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1db4c7f15e643a3cb27fe3b85e22f05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_base.html">SBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ac1db4c7f15e643a3cb27fe3b85e22f05">getAncestorOfType</a> (int type, const std::string &amp;pkgName=&quot;core&quot;)</td></tr>
<tr class="memdesc:ac1db4c7f15e643a3cb27fe3b85e22f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first ancestor object that has the given SBML type code from the given package.  <a href="#ac1db4c7f15e643a3cb27fe3b85e22f05">More...</a><br /></td></tr>
<tr class="separator:ac1db4c7f15e643a3cb27fe3b85e22f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a432c412387b4a5cb6771a1c0f40c47"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_s_base.html">SBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a7a432c412387b4a5cb6771a1c0f40c47">getAncestorOfType</a> (int type, const std::string pkgName=&quot;core&quot;) const </td></tr>
<tr class="memdesc:a7a432c412387b4a5cb6771a1c0f40c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first ancestor object that has the given SBML type code from the given package.  <a href="#a7a432c412387b4a5cb6771a1c0f40c47">More...</a><br /></td></tr>
<tr class="separator:a7a432c412387b4a5cb6771a1c0f40c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbf6701023075573bd76fa0bd276291"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a4fbf6701023075573bd76fa0bd276291">getAnnotation</a> ()</td></tr>
<tr class="memdesc:a4fbf6701023075573bd76fa0bd276291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "annotation" subelement of this object as a tree of <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> objects.  <a href="#a4fbf6701023075573bd76fa0bd276291">More...</a><br /></td></tr>
<tr class="separator:a4fbf6701023075573bd76fa0bd276291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b46329bd00e67fe52d3d75ae038714"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ab1b46329bd00e67fe52d3d75ae038714">getAnnotation</a> () const </td></tr>
<tr class="memdesc:ab1b46329bd00e67fe52d3d75ae038714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "annotation" subelement of this object as a tree of <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> objects.  <a href="#ab1b46329bd00e67fe52d3d75ae038714">More...</a><br /></td></tr>
<tr class="separator:ab1b46329bd00e67fe52d3d75ae038714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbff50c6c73c044a5c8e29e6b5dcefc6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#adbff50c6c73c044a5c8e29e6b5dcefc6">getAnnotationString</a> ()</td></tr>
<tr class="memdesc:adbff50c6c73c044a5c8e29e6b5dcefc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "annotation" subelement of this object as a character string.  <a href="#adbff50c6c73c044a5c8e29e6b5dcefc6">More...</a><br /></td></tr>
<tr class="separator:adbff50c6c73c044a5c8e29e6b5dcefc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2acdb3d3c45b598d9a9741dce6ac6c15"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a2acdb3d3c45b598d9a9741dce6ac6c15">getAnnotationString</a> () const </td></tr>
<tr class="memdesc:a2acdb3d3c45b598d9a9741dce6ac6c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "annotation" subelement of this object as a character string.  <a href="#a2acdb3d3c45b598d9a9741dce6ac6c15">More...</a><br /></td></tr>
<tr class="separator:a2acdb3d3c45b598d9a9741dce6ac6c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3afa2adb559d29047c2ba2e1e60dd39"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ad3afa2adb559d29047c2ba2e1e60dd39">getColumn</a> () const </td></tr>
<tr class="memdesc:ad3afa2adb559d29047c2ba2e1e60dd39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the column number where this object first appears in the XML representation of the SBML document.  <a href="#ad3afa2adb559d29047c2ba2e1e60dd39">More...</a><br /></td></tr>
<tr class="separator:ad3afa2adb559d29047c2ba2e1e60dd39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07ccf83cfe580d386088d88b61e60ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_v_term.html">CVTerm</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ae07ccf83cfe580d386088d88b61e60ff">getCVTerm</a> (unsigned int n)</td></tr>
<tr class="memdesc:ae07ccf83cfe580d386088d88b61e60ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth <a class="el" href="class_c_v_term.html" title=" A MIRIAM-compliant controlled vocabulary term. ">CVTerm</a> in the list of CVTerms of this SBML object.  <a href="#ae07ccf83cfe580d386088d88b61e60ff">More...</a><br /></td></tr>
<tr class="separator:ae07ccf83cfe580d386088d88b61e60ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9dcb83f0b3da9466817e3d32f197f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_list.html">List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a9b9dcb83f0b3da9466817e3d32f197f0">getCVTerms</a> ()</td></tr>
<tr class="memdesc:a9b9dcb83f0b3da9466817e3d32f197f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of <a class="el" href="class_c_v_term.html" title=" A MIRIAM-compliant controlled vocabulary term. ">CVTerm</a> objects in the annotations of this SBML object.  <a href="#a9b9dcb83f0b3da9466817e3d32f197f0">More...</a><br /></td></tr>
<tr class="separator:a9b9dcb83f0b3da9466817e3d32f197f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936cde6e165e162e0cd2f149ffe9b0d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_list.html">List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a936cde6e165e162e0cd2f149ffe9b0d6">getCVTerms</a> () const </td></tr>
<tr class="memdesc:a936cde6e165e162e0cd2f149ffe9b0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of <a class="el" href="class_c_v_term.html" title=" A MIRIAM-compliant controlled vocabulary term. ">CVTerm</a> objects in the annotations of this SBML object.  <a href="#a936cde6e165e162e0cd2f149ffe9b0d6">More...</a><br /></td></tr>
<tr class="separator:a936cde6e165e162e0cd2f149ffe9b0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3489e5f551ec6273d117bf45f563a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_unit_definition.html">UnitDefinition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#aae3489e5f551ec6273d117bf45f563a2">getDerivedUnitDefinition</a> ()</td></tr>
<tr class="memdesc:aae3489e5f551ec6273d117bf45f563a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns a <a class="el" href="class_unit_definition.html" title=" A definition of a unit used in an SBML model. ">UnitDefinition</a> that expresses the units of measurement assumed for the "math" expression of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>.  <a href="#aae3489e5f551ec6273d117bf45f563a2">More...</a><br /></td></tr>
<tr class="separator:aae3489e5f551ec6273d117bf45f563a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c79fac4eb2635ab2b54dae0588713f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_unit_definition.html">UnitDefinition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#a25c79fac4eb2635ab2b54dae0588713f">getDerivedUnitDefinition</a> () const </td></tr>
<tr class="memdesc:a25c79fac4eb2635ab2b54dae0588713f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns a <a class="el" href="class_unit_definition.html" title=" A definition of a unit used in an SBML model. ">UnitDefinition</a> that expresses the units of measurement assumed for the "math" expression of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>.  <a href="#a25c79fac4eb2635ab2b54dae0588713f">More...</a><br /></td></tr>
<tr class="separator:a25c79fac4eb2635ab2b54dae0588713f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8012eba52b904a1fcfb2a483eef94810"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_base_plugin.html">SBasePlugin</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a8012eba52b904a1fcfb2a483eef94810">getDisabledPlugin</a> (unsigned int n)</td></tr>
<tr class="memdesc:a8012eba52b904a1fcfb2a483eef94810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth disabled plug-in object (extension interface) for an SBML Level&#160;3 package extension.  <a href="#a8012eba52b904a1fcfb2a483eef94810">More...</a><br /></td></tr>
<tr class="separator:a8012eba52b904a1fcfb2a483eef94810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3cb30f3dedf374b937811ed54ec3364"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_s_base_plugin.html">SBasePlugin</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ad3cb30f3dedf374b937811ed54ec3364">getDisabledPlugin</a> (unsigned int n) const </td></tr>
<tr class="memdesc:ad3cb30f3dedf374b937811ed54ec3364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth disabled plug-in object (extension interface) for an SBML Level&#160;3 package extension.  <a href="#ad3cb30f3dedf374b937811ed54ec3364">More...</a><br /></td></tr>
<tr class="separator:ad3cb30f3dedf374b937811ed54ec3364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd4be8061a6a0338ebc2b8018ffbd46"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_s_base.html">SBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a5fd4be8061a6a0338ebc2b8018ffbd46">getElementByMetaId</a> (const std::string &amp;metaid)</td></tr>
<tr class="memdesc:a5fd4be8061a6a0338ebc2b8018ffbd46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first child element it can find with a specific "metaid" attribute value, or <code>NULL</code> if no such object is found.  <a href="#a5fd4be8061a6a0338ebc2b8018ffbd46">More...</a><br /></td></tr>
<tr class="separator:a5fd4be8061a6a0338ebc2b8018ffbd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab46333d7e559e600c8fe770d715ce0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_s_base.html">SBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a7ab46333d7e559e600c8fe770d715ce0">getElementByMetaId</a> (const std::string &amp;metaid) const </td></tr>
<tr class="memdesc:a7ab46333d7e559e600c8fe770d715ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first child element it can find with a specific "metaid" attribute value, or <code>NULL</code> if no such object is found.  <a href="#a7ab46333d7e559e600c8fe770d715ce0">More...</a><br /></td></tr>
<tr class="separator:a7ab46333d7e559e600c8fe770d715ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b81fdb8570c061842115f59d12ef99"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_s_base.html">SBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ab9b81fdb8570c061842115f59d12ef99">getElementBySId</a> (const std::string &amp;id)</td></tr>
<tr class="memdesc:ab9b81fdb8570c061842115f59d12ef99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first child element found that has the given <code>id</code> in the model-wide <code>SId</code> namespace, or <code>NULL</code> if no such object is found.  <a href="#ab9b81fdb8570c061842115f59d12ef99">More...</a><br /></td></tr>
<tr class="separator:ab9b81fdb8570c061842115f59d12ef99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f9cf402bf4f5e090799270aad1c1cb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_s_base.html">SBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a58f9cf402bf4f5e090799270aad1c1cb">getElementBySId</a> (const std::string &amp;id) const </td></tr>
<tr class="memdesc:a58f9cf402bf4f5e090799270aad1c1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first child element found that has the given <code>id</code> in the model-wide <code>SId</code> namespace, or <code>NULL</code> if no such object is found.  <a href="#a58f9cf402bf4f5e090799270aad1c1cb">More...</a><br /></td></tr>
<tr class="separator:a58f9cf402bf4f5e090799270aad1c1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a86ec04e9fee983005cf7b24d9f1a3"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#a92a86ec04e9fee983005cf7b24d9f1a3">getElementName</a> () const </td></tr>
<tr class="memdesc:a92a86ec04e9fee983005cf7b24d9f1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the XML element name of this object.  <a href="#a92a86ec04e9fee983005cf7b24d9f1a3">More...</a><br /></td></tr>
<tr class="separator:a92a86ec04e9fee983005cf7b24d9f1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1309f4f14c012aec069340aa3dd9ddf"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#ab1309f4f14c012aec069340aa3dd9ddf">getFormula</a> () const </td></tr>
<tr class="memdesc:ab1309f4f14c012aec069340aa3dd9ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mathematical expression of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> in text-string form.  <a href="#ab1309f4f14c012aec069340aa3dd9ddf">More...</a><br /></td></tr>
<tr class="separator:ab1309f4f14c012aec069340aa3dd9ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd617bad05c960bee53c986e856b6ee1"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#abd617bad05c960bee53c986e856b6ee1">getId</a> () const </td></tr>
<tr class="memdesc:abd617bad05c960bee53c986e856b6ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the "variable" attribute of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> (NOT the "id").  <a href="#abd617bad05c960bee53c986e856b6ee1">More...</a><br /></td></tr>
<tr class="separator:abd617bad05c960bee53c986e856b6ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5e8dc937c46ace3af5125c8674c199"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#acd5e8dc937c46ace3af5125c8674c199">getIdAttribute</a> () const </td></tr>
<tr class="memdesc:acd5e8dc937c46ace3af5125c8674c199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the "id" attribute of this SBML object.  <a href="#acd5e8dc937c46ace3af5125c8674c199">More...</a><br /></td></tr>
<tr class="separator:acd5e8dc937c46ace3af5125c8674c199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97235bacc1a59b4ec29401254610229"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#ae97235bacc1a59b4ec29401254610229">getL1TypeCode</a> () const </td></tr>
<tr class="memdesc:ae97235bacc1a59b4ec29401254610229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the SBML Level&#160;1 type code for this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> object.  <a href="#ae97235bacc1a59b4ec29401254610229">More...</a><br /></td></tr>
<tr class="separator:ae97235bacc1a59b4ec29401254610229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22fcf03f946d415a46e4b8e4c69076a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ae22fcf03f946d415a46e4b8e4c69076a">getLevel</a> () const </td></tr>
<tr class="memdesc:ae22fcf03f946d415a46e4b8e4c69076a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the SBML Level of the <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> object containing <em>this</em> object.  <a href="#ae22fcf03f946d415a46e4b8e4c69076a">More...</a><br /></td></tr>
<tr class="separator:ae22fcf03f946d415a46e4b8e4c69076a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdeb5554fd732ec045b6b31f3b56b8cd"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#acdeb5554fd732ec045b6b31f3b56b8cd">getLine</a> () const </td></tr>
<tr class="memdesc:acdeb5554fd732ec045b6b31f3b56b8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the line number where this object first appears in the XML representation of the SBML document.  <a href="#acdeb5554fd732ec045b6b31f3b56b8cd">More...</a><br /></td></tr>
<tr class="separator:acdeb5554fd732ec045b6b31f3b56b8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f1d983ede091d3096c51cdceb54135"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_a_s_t_node.html">ASTNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#ab1f1d983ede091d3096c51cdceb54135">getMath</a> () const </td></tr>
<tr class="memdesc:ab1f1d983ede091d3096c51cdceb54135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mathematical formula of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> as an <a class="el" href="class_a_s_t_node.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode</a> tree.  <a href="#ab1f1d983ede091d3096c51cdceb54135">More...</a><br /></td></tr>
<tr class="separator:ab1f1d983ede091d3096c51cdceb54135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6dcf5f49d13567a1dfead284b7ac96b"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ad6dcf5f49d13567a1dfead284b7ac96b">getMetaId</a> () const </td></tr>
<tr class="memdesc:ad6dcf5f49d13567a1dfead284b7ac96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the "metaid" attribute of this SBML object.  <a href="#ad6dcf5f49d13567a1dfead284b7ac96b">More...</a><br /></td></tr>
<tr class="separator:ad6dcf5f49d13567a1dfead284b7ac96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2880c1c6a2df519371637a9234ed68a4"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a2880c1c6a2df519371637a9234ed68a4">getMetaId</a> ()</td></tr>
<tr class="memdesc:a2880c1c6a2df519371637a9234ed68a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the "metaid" attribute of this SBML object.  <a href="#a2880c1c6a2df519371637a9234ed68a4">More...</a><br /></td></tr>
<tr class="separator:a2880c1c6a2df519371637a9234ed68a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74db90e4530b215a3884f50632b95cc8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_model.html">Model</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a74db90e4530b215a3884f50632b95cc8">getModel</a> () const </td></tr>
<tr class="memdesc:a74db90e4530b215a3884f50632b95cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_model.html" title=" An SBML model. ">Model</a> object for the SBML Document in which the current object is located.  <a href="#a74db90e4530b215a3884f50632b95cc8">More...</a><br /></td></tr>
<tr class="separator:a74db90e4530b215a3884f50632b95cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768c53757958b705c6bdedf3d184f8b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_model_history.html">ModelHistory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a768c53757958b705c6bdedf3d184f8b9">getModelHistory</a> () const </td></tr>
<tr class="memdesc:a768c53757958b705c6bdedf3d184f8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_model_history.html" title=" MIRIAM-compliant data about a model&#39;s history. ">ModelHistory</a> object, if any, attached to this object.  <a href="#a768c53757958b705c6bdedf3d184f8b9">More...</a><br /></td></tr>
<tr class="separator:a768c53757958b705c6bdedf3d184f8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027dbf22b8bf74bbb0ce5cd4453851c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_model_history.html">ModelHistory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a027dbf22b8bf74bbb0ce5cd4453851c7">getModelHistory</a> ()</td></tr>
<tr class="memdesc:a027dbf22b8bf74bbb0ce5cd4453851c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_model_history.html" title=" MIRIAM-compliant data about a model&#39;s history. ">ModelHistory</a> object, if any, attached to this object.  <a href="#a027dbf22b8bf74bbb0ce5cd4453851c7">More...</a><br /></td></tr>
<tr class="separator:a027dbf22b8bf74bbb0ce5cd4453851c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24c4b22c1ac115368032d558b6fe4e4"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ab24c4b22c1ac115368032d558b6fe4e4">getName</a> () const </td></tr>
<tr class="memdesc:ab24c4b22c1ac115368032d558b6fe4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the "name" attribute of this SBML object.  <a href="#ab24c4b22c1ac115368032d558b6fe4e4">More...</a><br /></td></tr>
<tr class="separator:ab24c4b22c1ac115368032d558b6fe4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8726b2382c6945adddc1f469c6758be1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a8726b2382c6945adddc1f469c6758be1">getNamespaces</a> () const </td></tr>
<tr class="memdesc:a8726b2382c6945adddc1f469c6758be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of the XML Namespaces declared on the SBML document owning this object.  <a href="#a8726b2382c6945adddc1f469c6758be1">More...</a><br /></td></tr>
<tr class="separator:a8726b2382c6945adddc1f469c6758be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34eff3877f512b8bf31facff83c4483"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ac34eff3877f512b8bf31facff83c4483">getNotes</a> ()</td></tr>
<tr class="memdesc:ac34eff3877f512b8bf31facff83c4483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "notes" subelement of this object as a tree of <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> objects.  <a href="#ac34eff3877f512b8bf31facff83c4483">More...</a><br /></td></tr>
<tr class="separator:ac34eff3877f512b8bf31facff83c4483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b7859768bced5964304957f85775b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ac0b7859768bced5964304957f85775b2">getNotes</a> () const </td></tr>
<tr class="memdesc:ac0b7859768bced5964304957f85775b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "notes" subelement of this object as a tree of <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> objects.  <a href="#ac0b7859768bced5964304957f85775b2">More...</a><br /></td></tr>
<tr class="separator:ac0b7859768bced5964304957f85775b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eee96ee206a55837c0d7b936f20f14d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a6eee96ee206a55837c0d7b936f20f14d">getNotesString</a> ()</td></tr>
<tr class="memdesc:a6eee96ee206a55837c0d7b936f20f14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "notes" subelement of this object as a string.  <a href="#a6eee96ee206a55837c0d7b936f20f14d">More...</a><br /></td></tr>
<tr class="separator:a6eee96ee206a55837c0d7b936f20f14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b5ef0e49324e94ea606478a8f8714d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a45b5ef0e49324e94ea606478a8f8714d">getNotesString</a> () const </td></tr>
<tr class="memdesc:a45b5ef0e49324e94ea606478a8f8714d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the "notes" subelement of this object as a string.  <a href="#a45b5ef0e49324e94ea606478a8f8714d">More...</a><br /></td></tr>
<tr class="separator:a45b5ef0e49324e94ea606478a8f8714d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b34686c3620ef45eecdc41b2b7f1f6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a33b34686c3620ef45eecdc41b2b7f1f6">getNumCVTerms</a> ()</td></tr>
<tr class="memdesc:a33b34686c3620ef45eecdc41b2b7f1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <a class="el" href="class_c_v_term.html" title=" A MIRIAM-compliant controlled vocabulary term. ">CVTerm</a> objects in the annotations of this SBML object.  <a href="#a33b34686c3620ef45eecdc41b2b7f1f6">More...</a><br /></td></tr>
<tr class="separator:a33b34686c3620ef45eecdc41b2b7f1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68708993ac87a7fee20fe46fea06a851"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a68708993ac87a7fee20fe46fea06a851">getNumDisabledPlugins</a> () const </td></tr>
<tr class="memdesc:a68708993ac87a7fee20fe46fea06a851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of disabled plug-in objects (extension interfaces) for SBML Level&#160;3 package extensions known.  <a href="#a68708993ac87a7fee20fe46fea06a851">More...</a><br /></td></tr>
<tr class="separator:a68708993ac87a7fee20fe46fea06a851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ec0d431ea99929055baebf1d97e421"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a78ec0d431ea99929055baebf1d97e421">getNumPlugins</a> () const </td></tr>
<tr class="memdesc:a78ec0d431ea99929055baebf1d97e421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of plug-in objects (extenstion interfaces) for SBML Level&#160;3 package extensions known.  <a href="#a78ec0d431ea99929055baebf1d97e421">More...</a><br /></td></tr>
<tr class="separator:a78ec0d431ea99929055baebf1d97e421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa729b3e8fa153e4235f0407c40e32167"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#aa729b3e8fa153e4235f0407c40e32167">getPackageCoreVersion</a> () const </td></tr>
<tr class="memdesc:aa729b3e8fa153e4235f0407c40e32167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the SBML Core Version within the SBML Level of the actual object.  <a href="#aa729b3e8fa153e4235f0407c40e32167">More...</a><br /></td></tr>
<tr class="separator:aa729b3e8fa153e4235f0407c40e32167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fba4f047b5e009a42081bd685d4eb16"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a2fba4f047b5e009a42081bd685d4eb16">getPackageName</a> () const </td></tr>
<tr class="memdesc:a2fba4f047b5e009a42081bd685d4eb16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the SBML Level&#160;3 package in which this element is defined.  <a href="#a2fba4f047b5e009a42081bd685d4eb16">More...</a><br /></td></tr>
<tr class="separator:a2fba4f047b5e009a42081bd685d4eb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa831f09f33c10055a222cd1900c99bf8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#aa831f09f33c10055a222cd1900c99bf8">getPackageVersion</a> () const </td></tr>
<tr class="memdesc:aa831f09f33c10055a222cd1900c99bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Version of the SBML Level&#160;3 package to which this element belongs to.  <a href="#aa831f09f33c10055a222cd1900c99bf8">More...</a><br /></td></tr>
<tr class="separator:aa831f09f33c10055a222cd1900c99bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5912bd9dc06f63029b86dbda467bb3c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_base.html">SBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a5912bd9dc06f63029b86dbda467bb3c5">getParentSBMLObject</a> ()</td></tr>
<tr class="memdesc:a5912bd9dc06f63029b86dbda467bb3c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent SBML object containing this object.  <a href="#a5912bd9dc06f63029b86dbda467bb3c5">More...</a><br /></td></tr>
<tr class="separator:a5912bd9dc06f63029b86dbda467bb3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65de47c82fbb90a0e27377c6164f8f4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_s_base.html">SBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#af65de47c82fbb90a0e27377c6164f8f4">getParentSBMLObject</a> () const </td></tr>
<tr class="memdesc:af65de47c82fbb90a0e27377c6164f8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent SBML object containing this object.  <a href="#af65de47c82fbb90a0e27377c6164f8f4">More...</a><br /></td></tr>
<tr class="separator:af65de47c82fbb90a0e27377c6164f8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8d8b8cb1ae5980d228174073fc5abc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_base_plugin.html">SBasePlugin</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc">getPlugin</a> (const std::string &amp;package)</td></tr>
<tr class="memdesc:aee8d8b8cb1ae5980d228174073fc5abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given package name or URI.  <a href="#aee8d8b8cb1ae5980d228174073fc5abc">More...</a><br /></td></tr>
<tr class="separator:aee8d8b8cb1ae5980d228174073fc5abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b37e0ac6f9c6359fcad8bbe1d3a942"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_s_base_plugin.html">SBasePlugin</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a70b37e0ac6f9c6359fcad8bbe1d3a942">getPlugin</a> (const std::string &amp;package) const </td></tr>
<tr class="memdesc:a70b37e0ac6f9c6359fcad8bbe1d3a942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given package name or URI.  <a href="#a70b37e0ac6f9c6359fcad8bbe1d3a942">More...</a><br /></td></tr>
<tr class="separator:a70b37e0ac6f9c6359fcad8bbe1d3a942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcd32c8ab7537433f7f7851818c60ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_base_plugin.html">SBasePlugin</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a2bcd32c8ab7537433f7f7851818c60ed">getPlugin</a> (unsigned int n)</td></tr>
<tr class="memdesc:a2bcd32c8ab7537433f7f7851818c60ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth plug-in object (extension interface) for an SBML Level&#160;3 package extension.  <a href="#a2bcd32c8ab7537433f7f7851818c60ed">More...</a><br /></td></tr>
<tr class="separator:a2bcd32c8ab7537433f7f7851818c60ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70be7c5915bea4bdb76993dafaeb3824"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_s_base_plugin.html">SBasePlugin</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a70be7c5915bea4bdb76993dafaeb3824">getPlugin</a> (unsigned int n) const </td></tr>
<tr class="memdesc:a70be7c5915bea4bdb76993dafaeb3824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth plug-in object (extension interface) for an SBML Level&#160;3 package extension.  <a href="#a70be7c5915bea4bdb76993dafaeb3824">More...</a><br /></td></tr>
<tr class="separator:a70be7c5915bea4bdb76993dafaeb3824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404fd41294b3f5fb84f4f4215755abb8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a404fd41294b3f5fb84f4f4215755abb8">getPrefix</a> () const </td></tr>
<tr class="memdesc:a404fd41294b3f5fb84f4f4215755abb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the XML namespace prefix of this element.  <a href="#a404fd41294b3f5fb84f4f4215755abb8">More...</a><br /></td></tr>
<tr class="separator:a404fd41294b3f5fb84f4f4215755abb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ebee0bc9c56fe3444b8f230eddc129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_c_v_term_8h.html#a7dbfb6956b3be9e61e65509cb2052f18">BiolQualifierType_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ac6ebee0bc9c56fe3444b8f230eddc129">getResourceBiologicalQualifier</a> (std::string resource)</td></tr>
<tr class="memdesc:ac6ebee0bc9c56fe3444b8f230eddc129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MIRIAM <em>biological qualifier</em> associated with the given resource.  <a href="#ac6ebee0bc9c56fe3444b8f230eddc129">More...</a><br /></td></tr>
<tr class="separator:ac6ebee0bc9c56fe3444b8f230eddc129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67710b870844b0465b0c5b9e43c6ed4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_c_v_term_8h.html#a969edcb49472d95685722a541f391d9d">ModelQualifierType_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#af67710b870844b0465b0c5b9e43c6ed4">getResourceModelQualifier</a> (std::string resource)</td></tr>
<tr class="memdesc:af67710b870844b0465b0c5b9e43c6ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MIRIAM <em>model qualifier</em> associated with the given resource.  <a href="#af67710b870844b0465b0c5b9e43c6ed4">More...</a><br /></td></tr>
<tr class="separator:af67710b870844b0465b0c5b9e43c6ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab649bfd5586aec788536a5cd77ae963f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ab649bfd5586aec788536a5cd77ae963f">getSBMLDocument</a> () const </td></tr>
<tr class="memdesc:ab649bfd5586aec788536a5cd77ae963f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> object containing this object instance.  <a href="#ab649bfd5586aec788536a5cd77ae963f">More...</a><br /></td></tr>
<tr class="separator:ab649bfd5586aec788536a5cd77ae963f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1725f1b98e08e54485ec52404d579a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a7e1725f1b98e08e54485ec52404d579a">getSBMLDocument</a> ()</td></tr>
<tr class="memdesc:a7e1725f1b98e08e54485ec52404d579a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> object containing this object instance.  <a href="#a7e1725f1b98e08e54485ec52404d579a">More...</a><br /></td></tr>
<tr class="separator:a7e1725f1b98e08e54485ec52404d579a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af001f8160ee38a0b39bd69dc364dac8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#af001f8160ee38a0b39bd69dc364dac8f">getSBOTerm</a> () const </td></tr>
<tr class="memdesc:af001f8160ee38a0b39bd69dc364dac8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the integer portion of the value of the "sboTerm" attribute of this object.  <a href="#af001f8160ee38a0b39bd69dc364dac8f">More...</a><br /></td></tr>
<tr class="separator:af001f8160ee38a0b39bd69dc364dac8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0eae047c6c4ddc8d17e4d3369da7b57"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#af0eae047c6c4ddc8d17e4d3369da7b57">getSBOTermAsURL</a> () const </td></tr>
<tr class="memdesc:af0eae047c6c4ddc8d17e4d3369da7b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the URL representation of the "sboTerm" attribute of this object.  <a href="#af0eae047c6c4ddc8d17e4d3369da7b57">More...</a><br /></td></tr>
<tr class="separator:af0eae047c6c4ddc8d17e4d3369da7b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abcd5c8b17994422c21cc1b291cf9d9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a7abcd5c8b17994422c21cc1b291cf9d9">getSBOTermID</a> () const </td></tr>
<tr class="memdesc:a7abcd5c8b17994422c21cc1b291cf9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of the "sboTerm" attribute of this object.  <a href="#a7abcd5c8b17994422c21cc1b291cf9d9">More...</a><br /></td></tr>
<tr class="separator:a7abcd5c8b17994422c21cc1b291cf9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5a245e34bc27da4818558796dc6654"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_rule_8h.html#ad5d6b2dda840b827f5c4857296c739a7">RuleType_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#a1e5a245e34bc27da4818558796dc6654">getType</a> () const </td></tr>
<tr class="memdesc:a1e5a245e34bc27da4818558796dc6654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a code representing the type of rule this is.  <a href="#a1e5a245e34bc27da4818558796dc6654">More...</a><br /></td></tr>
<tr class="separator:a1e5a245e34bc27da4818558796dc6654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c7637ff4280635853fe59489fcbcc9"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#a88c7637ff4280635853fe59489fcbcc9">getTypeCode</a> () const </td></tr>
<tr class="memdesc:a88c7637ff4280635853fe59489fcbcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the libSBML type code for this SBML object.  <a href="#a88c7637ff4280635853fe59489fcbcc9">More...</a><br /></td></tr>
<tr class="separator:a88c7637ff4280635853fe59489fcbcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65c881cf77ae692c4d7cc6a98e474f3"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#ac65c881cf77ae692c4d7cc6a98e474f3">getUnits</a> () const </td></tr>
<tr class="memdesc:ac65c881cf77ae692c4d7cc6a98e474f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the units for the mathematical formula of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>.  <a href="#ac65c881cf77ae692c4d7cc6a98e474f3">More...</a><br /></td></tr>
<tr class="separator:ac65c881cf77ae692c4d7cc6a98e474f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae616f1910aa4764813c10347e0e776fd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ae616f1910aa4764813c10347e0e776fd">getURI</a> () const </td></tr>
<tr class="memdesc:ae616f1910aa4764813c10347e0e776fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the namespace URI to which this element belongs to.  <a href="#ae616f1910aa4764813c10347e0e776fd">More...</a><br /></td></tr>
<tr class="separator:ae616f1910aa4764813c10347e0e776fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf88daa030d52a6a9494f9277e91cc2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a2cf88daa030d52a6a9494f9277e91cc2">getUserData</a> () const </td></tr>
<tr class="memdesc:a2cf88daa030d52a6a9494f9277e91cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the user data that has been previously set via <a class="el" href="class_s_base.html#ac3b1bbfe22bad0dbc577b61c529f37bb" title="Sets the user data of this element. ">setUserData()</a>.  <a href="#a2cf88daa030d52a6a9494f9277e91cc2">More...</a><br /></td></tr>
<tr class="separator:a2cf88daa030d52a6a9494f9277e91cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b6103384ba971fb7b1d85584566c7c"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#a21b6103384ba971fb7b1d85584566c7c">getVariable</a> () const </td></tr>
<tr class="memdesc:a21b6103384ba971fb7b1d85584566c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the "variable" attribute of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> object.  <a href="#a21b6103384ba971fb7b1d85584566c7c">More...</a><br /></td></tr>
<tr class="separator:a21b6103384ba971fb7b1d85584566c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555924b2486ab63a21fae675bdce8c5e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a555924b2486ab63a21fae675bdce8c5e">getVersion</a> () const </td></tr>
<tr class="memdesc:a555924b2486ab63a21fae675bdce8c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Version within the SBML Level of the <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> object containing <em>this</em> object.  <a href="#a555924b2486ab63a21fae675bdce8c5e">More...</a><br /></td></tr>
<tr class="separator:a555924b2486ab63a21fae675bdce8c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aaf5962c6268adb1ebfcc95b18a59fb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rate_rule.html#a6aaf5962c6268adb1ebfcc95b18a59fb">hasRequiredAttributes</a> () const </td></tr>
<tr class="memdesc:a6aaf5962c6268adb1ebfcc95b18a59fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if all the required attributes for this <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> object have been set.  <a href="#a6aaf5962c6268adb1ebfcc95b18a59fb">More...</a><br /></td></tr>
<tr class="separator:a6aaf5962c6268adb1ebfcc95b18a59fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de991eb944dd12f49f795a0432dfa06"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#a4de991eb944dd12f49f795a0432dfa06">hasRequiredElements</a> () const </td></tr>
<tr class="memdesc:a4de991eb944dd12f49f795a0432dfa06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if all the required elements for this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> object have been set.  <a href="#a4de991eb944dd12f49f795a0432dfa06">More...</a><br /></td></tr>
<tr class="separator:a4de991eb944dd12f49f795a0432dfa06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c78f1941d1d0fc804b6b4a1dd0db54e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a4c78f1941d1d0fc804b6b4a1dd0db54e">hasValidLevelVersionNamespaceCombination</a> ()</td></tr>
<tr class="memdesc:a4c78f1941d1d0fc804b6b4a1dd0db54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this object's level/version and namespace values correspond to a valid SBML specification.  <a href="#a4c78f1941d1d0fc804b6b4a1dd0db54e">More...</a><br /></td></tr>
<tr class="separator:a4c78f1941d1d0fc804b6b4a1dd0db54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bfc9dcae803017df4730c9619ee9f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#a57bfc9dcae803017df4730c9619ee9f8">isAlgebraic</a> () const </td></tr>
<tr class="memdesc:a57bfc9dcae803017df4730c9619ee9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is an <a class="el" href="class_algebraic_rule.html" title=" An SBML algebraic rule representing 0 = f(W). ">AlgebraicRule</a>.  <a href="#a57bfc9dcae803017df4730c9619ee9f8">More...</a><br /></td></tr>
<tr class="separator:a57bfc9dcae803017df4730c9619ee9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9d996c385325d233e9d2b0484a4610"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#aba9d996c385325d233e9d2b0484a4610">isAssignment</a> () const </td></tr>
<tr class="memdesc:aba9d996c385325d233e9d2b0484a4610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is an <a class="el" href="class_assignment_rule.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule</a>.  <a href="#aba9d996c385325d233e9d2b0484a4610">More...</a><br /></td></tr>
<tr class="separator:aba9d996c385325d233e9d2b0484a4610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe96b3ecf285d008dc401d4baba34786"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#afe96b3ecf285d008dc401d4baba34786">isCompartmentVolume</a> () const </td></tr>
<tr class="memdesc:afe96b3ecf285d008dc401d4baba34786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is an CompartmentVolumeRule or equivalent.  <a href="#afe96b3ecf285d008dc401d4baba34786">More...</a><br /></td></tr>
<tr class="separator:afe96b3ecf285d008dc401d4baba34786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ea0c99c7dffe1f0afc710358b537a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a60ea0c99c7dffe1f0afc710358b537a3">isPackageEnabled</a> (const std::string &amp;pkgName) const </td></tr>
<tr class="memdesc:a60ea0c99c7dffe1f0afc710358b537a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if the given SBML Level&#160;3 package is enabled with this object.  <a href="#a60ea0c99c7dffe1f0afc710358b537a3">More...</a><br /></td></tr>
<tr class="separator:a60ea0c99c7dffe1f0afc710358b537a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f68f8a35a952df01c3e81248bb51f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ad9f68f8a35a952df01c3e81248bb51f4">isPackageURIEnabled</a> (const std::string &amp;pkgURI) const </td></tr>
<tr class="memdesc:ad9f68f8a35a952df01c3e81248bb51f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if an SBML Level&#160;3 package with the given URI is enabled with this object.  <a href="#ad9f68f8a35a952df01c3e81248bb51f4">More...</a><br /></td></tr>
<tr class="separator:ad9f68f8a35a952df01c3e81248bb51f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8195a67115217b55f42241d00d951134"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#a8195a67115217b55f42241d00d951134">isParameter</a> () const </td></tr>
<tr class="memdesc:a8195a67115217b55f42241d00d951134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is an ParameterRule or equivalent.  <a href="#a8195a67115217b55f42241d00d951134">More...</a><br /></td></tr>
<tr class="separator:a8195a67115217b55f42241d00d951134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dadc50ef089b47e70e2608e7ca2785e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a1dadc50ef089b47e70e2608e7ca2785e">isPkgEnabled</a> (const std::string &amp;pkgName) const </td></tr>
<tr class="memdesc:a1dadc50ef089b47e70e2608e7ca2785e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if the given SBML Level&#160;3 package is enabled with this object.  <a href="#a1dadc50ef089b47e70e2608e7ca2785e">More...</a><br /></td></tr>
<tr class="separator:a1dadc50ef089b47e70e2608e7ca2785e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c034c6274fa5da28b781a4c30e7088"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ac2c034c6274fa5da28b781a4c30e7088">isPkgURIEnabled</a> (const std::string &amp;pkgURI) const </td></tr>
<tr class="memdesc:ac2c034c6274fa5da28b781a4c30e7088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if an SBML Level&#160;3 package with the given URI is enabled with this object.  <a href="#ac2c034c6274fa5da28b781a4c30e7088">More...</a><br /></td></tr>
<tr class="separator:ac2c034c6274fa5da28b781a4c30e7088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce2768a6aa73c8fdb0426397bcac1c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#a1ce2768a6aa73c8fdb0426397bcac1c6">isRate</a> () const </td></tr>
<tr class="memdesc:a1ce2768a6aa73c8fdb0426397bcac1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is a <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> (SBML Levels&#160;2&ndash;3) or has a "type" attribute value of <code>"rate"</code> (SBML Level&#160;1).  <a href="#a1ce2768a6aa73c8fdb0426397bcac1c6">More...</a><br /></td></tr>
<tr class="separator:a1ce2768a6aa73c8fdb0426397bcac1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ecd9b9dfecc5b784e5b624d25e7b47c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#a3ecd9b9dfecc5b784e5b624d25e7b47c">isScalar</a> () const </td></tr>
<tr class="memdesc:a3ecd9b9dfecc5b784e5b624d25e7b47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is an <a class="el" href="class_assignment_rule.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule</a> (SBML Levels&#160;2&ndash;3) or has a "type" attribute value of <code>"scalar"</code> (SBML Level&#160;1).  <a href="#a3ecd9b9dfecc5b784e5b624d25e7b47c">More...</a><br /></td></tr>
<tr class="separator:a3ecd9b9dfecc5b784e5b624d25e7b47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279ce55f23330dc6bb0231774adfc42b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a279ce55f23330dc6bb0231774adfc42b">isSetAnnotation</a> () const </td></tr>
<tr class="memdesc:a279ce55f23330dc6bb0231774adfc42b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this object's "annotation" subelement exists and has content.  <a href="#a279ce55f23330dc6bb0231774adfc42b">More...</a><br /></td></tr>
<tr class="separator:a279ce55f23330dc6bb0231774adfc42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30847417c7341e8fefc494293f59e1cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#a30847417c7341e8fefc494293f59e1cc">isSetFormula</a> () const </td></tr>
<tr class="memdesc:a30847417c7341e8fefc494293f59e1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>'s mathematical expression is set.  <a href="#a30847417c7341e8fefc494293f59e1cc">More...</a><br /></td></tr>
<tr class="separator:a30847417c7341e8fefc494293f59e1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e059dca5f0e97bdc7dc2e8fd3e4c35"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a20e059dca5f0e97bdc7dc2e8fd3e4c35">isSetId</a> () const </td></tr>
<tr class="memdesc:a20e059dca5f0e97bdc7dc2e8fd3e4c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if a call to <a class="el" href="class_s_base.html#a8bd7cb0de43db3680bd1eeb30022fcd3" title="Returns the value of the &quot;id&quot; attribute of this SBML object, if it has one, or the &quot;variable&quot; attribu...">getId()</a> returns a non-empty string.  <a href="#a20e059dca5f0e97bdc7dc2e8fd3e4c35">More...</a><br /></td></tr>
<tr class="separator:a20e059dca5f0e97bdc7dc2e8fd3e4c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad201f20c9527cff5daf5d05bf49aac8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ad201f20c9527cff5daf5d05bf49aac8c">isSetIdAttribute</a> () const </td></tr>
<tr class="memdesc:ad201f20c9527cff5daf5d05bf49aac8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this object's "id" attribute is set.  <a href="#ad201f20c9527cff5daf5d05bf49aac8c">More...</a><br /></td></tr>
<tr class="separator:ad201f20c9527cff5daf5d05bf49aac8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7da5cccceb8ead3aeb318e5617d265"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#aef7da5cccceb8ead3aeb318e5617d265">isSetMath</a> () const </td></tr>
<tr class="memdesc:aef7da5cccceb8ead3aeb318e5617d265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>'s mathematical expression is set.  <a href="#aef7da5cccceb8ead3aeb318e5617d265">More...</a><br /></td></tr>
<tr class="separator:aef7da5cccceb8ead3aeb318e5617d265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fc99c2ba9431594a78b78536699a0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a24fc99c2ba9431594a78b78536699a0e">isSetMetaId</a> () const </td></tr>
<tr class="memdesc:a24fc99c2ba9431594a78b78536699a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this object's "metaid" attribute is set.  <a href="#a24fc99c2ba9431594a78b78536699a0e">More...</a><br /></td></tr>
<tr class="separator:a24fc99c2ba9431594a78b78536699a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03795a0c11687c49f9b4a2017607de95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a03795a0c11687c49f9b4a2017607de95">isSetModelHistory</a> ()</td></tr>
<tr class="memdesc:a03795a0c11687c49f9b4a2017607de95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this object has a <a class="el" href="class_model_history.html" title=" MIRIAM-compliant data about a model&#39;s history. ">ModelHistory</a> object attached to it.  <a href="#a03795a0c11687c49f9b4a2017607de95">More...</a><br /></td></tr>
<tr class="separator:a03795a0c11687c49f9b4a2017607de95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541c62b7ad823db1f14674386a61b52f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a541c62b7ad823db1f14674386a61b52f">isSetName</a> () const </td></tr>
<tr class="memdesc:a541c62b7ad823db1f14674386a61b52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this object's "name" attribute is set.  <a href="#a541c62b7ad823db1f14674386a61b52f">More...</a><br /></td></tr>
<tr class="separator:a541c62b7ad823db1f14674386a61b52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff0554efc75440b5375b35a4d188ea0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#aeff0554efc75440b5375b35a4d188ea0">isSetNotes</a> () const </td></tr>
<tr class="memdesc:aeff0554efc75440b5375b35a4d188ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this object's "notes" subelement exists and has content.  <a href="#aeff0554efc75440b5375b35a4d188ea0">More...</a><br /></td></tr>
<tr class="separator:aeff0554efc75440b5375b35a4d188ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535a9b7edadff8681c9f5f30b32378a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a535a9b7edadff8681c9f5f30b32378a6">isSetSBOTerm</a> () const </td></tr>
<tr class="memdesc:a535a9b7edadff8681c9f5f30b32378a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this object's "sboTerm" attribute is set.  <a href="#a535a9b7edadff8681c9f5f30b32378a6">More...</a><br /></td></tr>
<tr class="separator:a535a9b7edadff8681c9f5f30b32378a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52efbbf15fe8d48a46b82ad21a667121"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#a52efbbf15fe8d48a46b82ad21a667121">isSetUnits</a> () const </td></tr>
<tr class="memdesc:a52efbbf15fe8d48a46b82ad21a667121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>'s "units" attribute is set.  <a href="#a52efbbf15fe8d48a46b82ad21a667121">More...</a><br /></td></tr>
<tr class="separator:a52efbbf15fe8d48a46b82ad21a667121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469f7adb20116ecfd755c6ab43931763"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a469f7adb20116ecfd755c6ab43931763">isSetUserData</a> () const </td></tr>
<tr class="memdesc:a469f7adb20116ecfd755c6ab43931763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning true or false depending on whether the user data of this element has been set.  <a href="#a469f7adb20116ecfd755c6ab43931763">More...</a><br /></td></tr>
<tr class="separator:a469f7adb20116ecfd755c6ab43931763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5fcb43d75b82d54382d2a28eea8e45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#a8a5fcb43d75b82d54382d2a28eea8e45">isSetVariable</a> () const </td></tr>
<tr class="memdesc:a8a5fcb43d75b82d54382d2a28eea8e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>'s "variable" attribute is set.  <a href="#a8a5fcb43d75b82d54382d2a28eea8e45">More...</a><br /></td></tr>
<tr class="separator:a8a5fcb43d75b82d54382d2a28eea8e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64dbf17f774c3969ae77b96afc8a06de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#a64dbf17f774c3969ae77b96afc8a06de">isSpeciesConcentration</a> () const </td></tr>
<tr class="memdesc:a64dbf17f774c3969ae77b96afc8a06de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate returning <code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is a SpeciesConcentrationRule or equivalent.  <a href="#a64dbf17f774c3969ae77b96afc8a06de">More...</a><br /></td></tr>
<tr class="separator:a64dbf17f774c3969ae77b96afc8a06de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ead78ebf80118b1027af5438f22516"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a94ead78ebf80118b1027af5438f22516">matchesRequiredSBMLNamespacesForAddition</a> (const <a class="el" href="class_s_base.html">SBase</a> *sb)</td></tr>
<tr class="memdesc:a94ead78ebf80118b1027af5438f22516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this object's set of XML namespaces are a subset of the given object's XML namespaces.  <a href="#a94ead78ebf80118b1027af5438f22516">More...</a><br /></td></tr>
<tr class="separator:a94ead78ebf80118b1027af5438f22516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8800aa51fa0ab0a36f47723c3ecf0a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ad8800aa51fa0ab0a36f47723c3ecf0a5">matchesRequiredSBMLNamespacesForAddition</a> (const <a class="el" href="class_s_base.html">SBase</a> *sb) const </td></tr>
<tr class="memdesc:ad8800aa51fa0ab0a36f47723c3ecf0a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this object's set of XML namespaces are a subset of the given object's XML namespaces.  <a href="#ad8800aa51fa0ab0a36f47723c3ecf0a5">More...</a><br /></td></tr>
<tr class="separator:ad8800aa51fa0ab0a36f47723c3ecf0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936f753a9032913c569dafa3642d8252"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a936f753a9032913c569dafa3642d8252">matchesSBMLNamespaces</a> (const <a class="el" href="class_s_base.html">SBase</a> *sb)</td></tr>
<tr class="memdesc:a936f753a9032913c569dafa3642d8252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this object's set of XML namespaces are the same as the given object's XML namespaces.  <a href="#a936f753a9032913c569dafa3642d8252">More...</a><br /></td></tr>
<tr class="separator:a936f753a9032913c569dafa3642d8252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5eb7774ffab4af86ee4cb9468b267d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#aac5eb7774ffab4af86ee4cb9468b267d">matchesSBMLNamespaces</a> (const <a class="el" href="class_s_base.html">SBase</a> *sb) const </td></tr>
<tr class="memdesc:aac5eb7774ffab4af86ee4cb9468b267d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this object's set of XML namespaces are the same as the given object's XML namespaces.  <a href="#aac5eb7774ffab4af86ee4cb9468b267d">More...</a><br /></td></tr>
<tr class="separator:aac5eb7774ffab4af86ee4cb9468b267d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a922f9945f1166ed6ff0294885a9e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rate_rule.html#a18a922f9945f1166ed6ff0294885a9e6">RateRule</a> (unsigned int level, unsigned int version)</td></tr>
<tr class="memdesc:a18a922f9945f1166ed6ff0294885a9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> using the given SBML <code>level</code> and <code>version</code> values.  <a href="#a18a922f9945f1166ed6ff0294885a9e6">More...</a><br /></td></tr>
<tr class="separator:a18a922f9945f1166ed6ff0294885a9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8395da17406a747f493035d3eeb1fb9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rate_rule.html#a8395da17406a747f493035d3eeb1fb9a">RateRule</a> (<a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> *sbmlns)</td></tr>
<tr class="memdesc:a8395da17406a747f493035d3eeb1fb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> using the given <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> object <code>sbmlns</code>.  <a href="#a8395da17406a747f493035d3eeb1fb9a">More...</a><br /></td></tr>
<tr class="separator:a8395da17406a747f493035d3eeb1fb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5907f34420c9eaf65c7cf41b0a8b6954"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a5907f34420c9eaf65c7cf41b0a8b6954">read</a> (<a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp;node, <a class="el" href="_x_m_l_error_8h.html#a8a35e0419c4745cae351cfcec58dc710">XMLErrorSeverityOverride_t</a> flag=<a class="el" href="_x_m_l_error_8h.html#a8a35e0419c4745cae351cfcec58dc710add6235c114a38f4b2b00c4e79761d4c7">LIBSBML_OVERRIDE_DISABLED</a>)</td></tr>
<tr class="memdesc:a5907f34420c9eaf65c7cf41b0a8b6954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads (initializes) this SBML object by reading from the given <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a>.  <a href="#a5907f34420c9eaf65c7cf41b0a8b6954">More...</a><br /></td></tr>
<tr class="separator:a5907f34420c9eaf65c7cf41b0a8b6954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae431ca4044e40e1fe8e0ff4136dce838"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ae431ca4044e40e1fe8e0ff4136dce838">removeFromParentAndDelete</a> ()</td></tr>
<tr class="memdesc:ae431ca4044e40e1fe8e0ff4136dce838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes this object from its parent.  <a href="#ae431ca4044e40e1fe8e0ff4136dce838">More...</a><br /></td></tr>
<tr class="separator:ae431ca4044e40e1fe8e0ff4136dce838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40dba8a849dbda05d3f9f42000119dc5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a40dba8a849dbda05d3f9f42000119dc5">removeTopLevelAnnotationElement</a> (const std::string &amp;elementName, const std::string elementURI=&quot;&quot;, bool removeEmpty=true)</td></tr>
<tr class="memdesc:a40dba8a849dbda05d3f9f42000119dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the top-level element within the "annotation" subelement of this SBML object with the given name and optional URI.  <a href="#a40dba8a849dbda05d3f9f42000119dc5">More...</a><br /></td></tr>
<tr class="separator:a40dba8a849dbda05d3f9f42000119dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df4f196b8e11d08013c436c689465a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a4df4f196b8e11d08013c436c689465a5">renameMetaIdRefs</a> (const std::string &amp;oldid, const std::string &amp;newid)</td></tr>
<tr class="memdesc:a4df4f196b8e11d08013c436c689465a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all uses of a given meta identifier attribute value with another value.  <a href="#a4df4f196b8e11d08013c436c689465a5">More...</a><br /></td></tr>
<tr class="separator:a4df4f196b8e11d08013c436c689465a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80385825484be2980ece92154cf78197"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rate_rule.html#a80385825484be2980ece92154cf78197">renameSIdRefs</a> (const std::string &amp;oldid, const std::string &amp;newid)</td></tr>
<tr class="memdesc:a80385825484be2980ece92154cf78197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all uses of a given <code>SIdRef</code> type attribute value with another value.  <a href="#a80385825484be2980ece92154cf78197">More...</a><br /></td></tr>
<tr class="separator:a80385825484be2980ece92154cf78197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340d4cea8317cca28bb14dcf52574e47"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#a340d4cea8317cca28bb14dcf52574e47">renameUnitSIdRefs</a> (const std::string &amp;oldid, const std::string &amp;newid)</td></tr>
<tr class="memdesc:a340d4cea8317cca28bb14dcf52574e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all uses of a given <code>UnitSIdRef</code> type attribute value with another value.  <a href="#a340d4cea8317cca28bb14dcf52574e47">More...</a><br /></td></tr>
<tr class="separator:a340d4cea8317cca28bb14dcf52574e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14876bd1b05a660593ed2cf46aece3ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a14876bd1b05a660593ed2cf46aece3ee">replaceTopLevelAnnotationElement</a> (const <a class="el" href="class_x_m_l_node.html">XMLNode</a> *annotation)</td></tr>
<tr class="memdesc:a14876bd1b05a660593ed2cf46aece3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the given top-level element within the "annotation" subelement of this SBML object and with the annotation element supplied.  <a href="#a14876bd1b05a660593ed2cf46aece3ee">More...</a><br /></td></tr>
<tr class="separator:a14876bd1b05a660593ed2cf46aece3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21580da1d75f4782effcc57b45ed37c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a21580da1d75f4782effcc57b45ed37c8">replaceTopLevelAnnotationElement</a> (const std::string &amp;annotation)</td></tr>
<tr class="memdesc:a21580da1d75f4782effcc57b45ed37c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the given top-level element within the "annotation" subelement of this SBML object and with the annotation element supplied.  <a href="#a21580da1d75f4782effcc57b45ed37c8">More...</a><br /></td></tr>
<tr class="separator:a21580da1d75f4782effcc57b45ed37c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d9c02a3690d9a13362835ef0133125"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a11d9c02a3690d9a13362835ef0133125">setAnnotation</a> (const <a class="el" href="class_x_m_l_node.html">XMLNode</a> *annotation)</td></tr>
<tr class="memdesc:a11d9c02a3690d9a13362835ef0133125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "annotation" subelement of this SBML object.  <a href="#a11d9c02a3690d9a13362835ef0133125">More...</a><br /></td></tr>
<tr class="separator:a11d9c02a3690d9a13362835ef0133125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b1541bd854ad7edfe0aff79ab3231f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a75b1541bd854ad7edfe0aff79ab3231f">setAnnotation</a> (const std::string &amp;annotation)</td></tr>
<tr class="memdesc:a75b1541bd854ad7edfe0aff79ab3231f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "annotation" subelement of this SBML object.  <a href="#a75b1541bd854ad7edfe0aff79ab3231f">More...</a><br /></td></tr>
<tr class="separator:a75b1541bd854ad7edfe0aff79ab3231f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad001eb0d7da33033a2b33e5c6665b723"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#ad001eb0d7da33033a2b33e5c6665b723">setFormula</a> (const std::string &amp;formula)</td></tr>
<tr class="memdesc:ad001eb0d7da33033a2b33e5c6665b723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the "math" subelement of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> to an expression in text-string form.  <a href="#ad001eb0d7da33033a2b33e5c6665b723">More...</a><br /></td></tr>
<tr class="separator:ad001eb0d7da33033a2b33e5c6665b723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f9a3703526cd1fb929778df3050692"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ac9f9a3703526cd1fb929778df3050692">setId</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:ac9f9a3703526cd1fb929778df3050692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "id" attribute of this SBML object.  <a href="#ac9f9a3703526cd1fb929778df3050692">More...</a><br /></td></tr>
<tr class="separator:ac9f9a3703526cd1fb929778df3050692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a342a0f8387842fb6700c50c4c43344"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344">setIdAttribute</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:a8a342a0f8387842fb6700c50c4c43344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "id" attribute of this SBML object.  <a href="#a8a342a0f8387842fb6700c50c4c43344">More...</a><br /></td></tr>
<tr class="separator:a8a342a0f8387842fb6700c50c4c43344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f59a6ad607c2fc32a8c14f30fce1a9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#a9f59a6ad607c2fc32a8c14f30fce1a9e">setL1TypeCode</a> (int type)</td></tr>
<tr class="memdesc:a9f59a6ad607c2fc32a8c14f30fce1a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the SBML Level&#160;1 type code for this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>.  <a href="#a9f59a6ad607c2fc32a8c14f30fce1a9e">More...</a><br /></td></tr>
<tr class="separator:a9f59a6ad607c2fc32a8c14f30fce1a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524690d35b8bf6177a2c9c144d257fa7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#a524690d35b8bf6177a2c9c144d257fa7">setMath</a> (const <a class="el" href="class_a_s_t_node.html">ASTNode</a> *math)</td></tr>
<tr class="memdesc:a524690d35b8bf6177a2c9c144d257fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the "math" subelement of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> to a copy of the given <a class="el" href="class_a_s_t_node.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode</a>.  <a href="#a524690d35b8bf6177a2c9c144d257fa7">More...</a><br /></td></tr>
<tr class="separator:a524690d35b8bf6177a2c9c144d257fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050779a94ecdb2d73d7edfef73bc1e55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a050779a94ecdb2d73d7edfef73bc1e55">setMetaId</a> (const std::string &amp;metaid)</td></tr>
<tr class="memdesc:a050779a94ecdb2d73d7edfef73bc1e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the meta-identifier attribute of this SBML object.  <a href="#a050779a94ecdb2d73d7edfef73bc1e55">More...</a><br /></td></tr>
<tr class="separator:a050779a94ecdb2d73d7edfef73bc1e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0ea49f9a3ad67d72edb2c1cf92ad82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#aef0ea49f9a3ad67d72edb2c1cf92ad82">setModelHistory</a> (<a class="el" href="class_model_history.html">ModelHistory</a> *history)</td></tr>
<tr class="memdesc:aef0ea49f9a3ad67d72edb2c1cf92ad82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="class_model_history.html" title=" MIRIAM-compliant data about a model&#39;s history. ">ModelHistory</a> of this object.  <a href="#aef0ea49f9a3ad67d72edb2c1cf92ad82">More...</a><br /></td></tr>
<tr class="separator:aef0ea49f9a3ad67d72edb2c1cf92ad82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1531f729b16689aba3fb7f3567202a7c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a1531f729b16689aba3fb7f3567202a7c">setName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a1531f729b16689aba3fb7f3567202a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "name" attribute of this SBML object.  <a href="#a1531f729b16689aba3fb7f3567202a7c">More...</a><br /></td></tr>
<tr class="separator:a1531f729b16689aba3fb7f3567202a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6dc5a02be520ea43c7cf71c5062c71"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a7a6dc5a02be520ea43c7cf71c5062c71">setNamespaces</a> (<a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> *xmlns)</td></tr>
<tr class="memdesc:a7a6dc5a02be520ea43c7cf71c5062c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the namespaces relevant of this SBML object.  <a href="#a7a6dc5a02be520ea43c7cf71c5062c71">More...</a><br /></td></tr>
<tr class="separator:a7a6dc5a02be520ea43c7cf71c5062c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611a4bd98a4e32e3573980b2481ce77e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e">setNotes</a> (const <a class="el" href="class_x_m_l_node.html">XMLNode</a> *notes)</td></tr>
<tr class="memdesc:a611a4bd98a4e32e3573980b2481ce77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "notes" subelement of this SBML object.  <a href="#a611a4bd98a4e32e3573980b2481ce77e">More...</a><br /></td></tr>
<tr class="separator:a611a4bd98a4e32e3573980b2481ce77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478ad1e0e2bb2dc27a9de6ab9bac4bf2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a478ad1e0e2bb2dc27a9de6ab9bac4bf2">setNotes</a> (const std::string &amp;notes, bool addXHTMLMarkup=false)</td></tr>
<tr class="memdesc:a478ad1e0e2bb2dc27a9de6ab9bac4bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "notes" subelement of this SBML object to a copy of the string <code>notes</code>.  <a href="#a478ad1e0e2bb2dc27a9de6ab9bac4bf2">More...</a><br /></td></tr>
<tr class="separator:a478ad1e0e2bb2dc27a9de6ab9bac4bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37287e48bd51353012b74e4d200bb446"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a37287e48bd51353012b74e4d200bb446">setSBOTerm</a> (int value)</td></tr>
<tr class="memdesc:a37287e48bd51353012b74e4d200bb446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "sboTerm" attribute.  <a href="#a37287e48bd51353012b74e4d200bb446">More...</a><br /></td></tr>
<tr class="separator:a37287e48bd51353012b74e4d200bb446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7b199563437a7977cc13cabb21ef63"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a7b7b199563437a7977cc13cabb21ef63">setSBOTerm</a> (const std::string &amp;sboid)</td></tr>
<tr class="memdesc:a7b7b199563437a7977cc13cabb21ef63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the "sboTerm" attribute by string.  <a href="#a7b7b199563437a7977cc13cabb21ef63">More...</a><br /></td></tr>
<tr class="separator:a7b7b199563437a7977cc13cabb21ef63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78ca6ed2b4e131061fd5f8669e4e27e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#ab78ca6ed2b4e131061fd5f8669e4e27e">setUnits</a> (const std::string &amp;sname)</td></tr>
<tr class="memdesc:ab78ca6ed2b4e131061fd5f8669e4e27e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the units for this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>.  <a href="#ab78ca6ed2b4e131061fd5f8669e4e27e">More...</a><br /></td></tr>
<tr class="separator:ab78ca6ed2b4e131061fd5f8669e4e27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b1bbfe22bad0dbc577b61c529f37bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ac3b1bbfe22bad0dbc577b61c529f37bb">setUserData</a> (void *userData)</td></tr>
<tr class="memdesc:ac3b1bbfe22bad0dbc577b61c529f37bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the user data of this element.  <a href="#ac3b1bbfe22bad0dbc577b61c529f37bb">More...</a><br /></td></tr>
<tr class="separator:ac3b1bbfe22bad0dbc577b61c529f37bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea784a5a8a3594270dfc5b5e83dc315"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#a2ea784a5a8a3594270dfc5b5e83dc315">setVariable</a> (const std::string &amp;sid)</td></tr>
<tr class="memdesc:a2ea784a5a8a3594270dfc5b5e83dc315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the "variable" attribute value of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> object.  <a href="#a2ea784a5a8a3594270dfc5b5e83dc315">More...</a><br /></td></tr>
<tr class="separator:a2ea784a5a8a3594270dfc5b5e83dc315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8317d5157b70e4f1bc68e33e5c84001"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#ae8317d5157b70e4f1bc68e33e5c84001">toSBML</a> ()</td></tr>
<tr class="memdesc:ae8317d5157b70e4f1bc68e33e5c84001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string consisting of a partial SBML corresponding to just this object.  <a href="#ae8317d5157b70e4f1bc68e33e5c84001">More...</a><br /></td></tr>
<tr class="separator:ae8317d5157b70e4f1bc68e33e5c84001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c949d524aca47b84b18b57b76e6ee0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a5c949d524aca47b84b18b57b76e6ee0a">toXMLNode</a> ()</td></tr>
<tr class="memdesc:a5c949d524aca47b84b18b57b76e6ee0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this element as an <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a>.  <a href="#a5c949d524aca47b84b18b57b76e6ee0a">More...</a><br /></td></tr>
<tr class="separator:a5c949d524aca47b84b18b57b76e6ee0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9121d6a4f7401fe957cc75647a1e95ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a9121d6a4f7401fe957cc75647a1e95ed">unsetAnnotation</a> ()</td></tr>
<tr class="memdesc:a9121d6a4f7401fe957cc75647a1e95ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "annotation" subelement of this SBML object.  <a href="#a9121d6a4f7401fe957cc75647a1e95ed">More...</a><br /></td></tr>
<tr class="separator:a9121d6a4f7401fe957cc75647a1e95ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e89a7890f2fb291f1ba4c38866d1dcc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a1e89a7890f2fb291f1ba4c38866d1dcc">unsetCVTerms</a> ()</td></tr>
<tr class="memdesc:a1e89a7890f2fb291f1ba4c38866d1dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the list of <a class="el" href="class_c_v_term.html" title=" A MIRIAM-compliant controlled vocabulary term. ">CVTerm</a> objects attached to this SBML object.  <a href="#a1e89a7890f2fb291f1ba4c38866d1dcc">More...</a><br /></td></tr>
<tr class="separator:a1e89a7890f2fb291f1ba4c38866d1dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f77b6aa5f6f5d80b2d01558f7496f5"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a65f77b6aa5f6f5d80b2d01558f7496f5">unsetId</a> ()</td></tr>
<tr class="memdesc:a65f77b6aa5f6f5d80b2d01558f7496f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "id" attribute of this SBML object.  <a href="#a65f77b6aa5f6f5d80b2d01558f7496f5">More...</a><br /></td></tr>
<tr class="separator:a65f77b6aa5f6f5d80b2d01558f7496f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfd93ef72d0f624964fcfd7a8d5cdfb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb">unsetIdAttribute</a> ()</td></tr>
<tr class="memdesc:a1bfd93ef72d0f624964fcfd7a8d5cdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "id" attribute of this SBML object.  <a href="#a1bfd93ef72d0f624964fcfd7a8d5cdfb">More...</a><br /></td></tr>
<tr class="separator:a1bfd93ef72d0f624964fcfd7a8d5cdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c955421c92c28351610ea811ecb4fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a98c955421c92c28351610ea811ecb4fe">unsetMetaId</a> ()</td></tr>
<tr class="memdesc:a98c955421c92c28351610ea811ecb4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "metaid" attribute of this SBML object.  <a href="#a98c955421c92c28351610ea811ecb4fe">More...</a><br /></td></tr>
<tr class="separator:a98c955421c92c28351610ea811ecb4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa197c1c8a34df2cbd05a58f6cbc41841"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#aa197c1c8a34df2cbd05a58f6cbc41841">unsetModelHistory</a> ()</td></tr>
<tr class="memdesc:aa197c1c8a34df2cbd05a58f6cbc41841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the <a class="el" href="class_model_history.html" title=" MIRIAM-compliant data about a model&#39;s history. ">ModelHistory</a> object attached to this object.  <a href="#aa197c1c8a34df2cbd05a58f6cbc41841">More...</a><br /></td></tr>
<tr class="separator:aa197c1c8a34df2cbd05a58f6cbc41841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf8825fb83925a508eaac3d7f8fbb8c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a4cf8825fb83925a508eaac3d7f8fbb8c">unsetName</a> ()</td></tr>
<tr class="memdesc:a4cf8825fb83925a508eaac3d7f8fbb8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "name" attribute of this SBML object.  <a href="#a4cf8825fb83925a508eaac3d7f8fbb8c">More...</a><br /></td></tr>
<tr class="separator:a4cf8825fb83925a508eaac3d7f8fbb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f626f2593df8e83da4cdbfe79142f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a89f626f2593df8e83da4cdbfe79142f7">unsetNotes</a> ()</td></tr>
<tr class="memdesc:a89f626f2593df8e83da4cdbfe79142f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "notes" subelement of this SBML object.  <a href="#a89f626f2593df8e83da4cdbfe79142f7">More...</a><br /></td></tr>
<tr class="separator:a89f626f2593df8e83da4cdbfe79142f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317ea060a5c3f97576188a22e670e683"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#a317ea060a5c3f97576188a22e670e683">unsetSBOTerm</a> ()</td></tr>
<tr class="memdesc:a317ea060a5c3f97576188a22e670e683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "sboTerm" attribute of this SBML object.  <a href="#a317ea060a5c3f97576188a22e670e683">More...</a><br /></td></tr>
<tr class="separator:a317ea060a5c3f97576188a22e670e683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b39106dd241502c4f7267b1f370190e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#a8b39106dd241502c4f7267b1f370190e">unsetUnits</a> ()</td></tr>
<tr class="memdesc:a8b39106dd241502c4f7267b1f370190e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the "units" for this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>.  <a href="#a8b39106dd241502c4f7267b1f370190e">More...</a><br /></td></tr>
<tr class="separator:a8b39106dd241502c4f7267b1f370190e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd78c4290e103245ce49b92b5e229375"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#abd78c4290e103245ce49b92b5e229375">unsetUserData</a> ()</td></tr>
<tr class="memdesc:abd78c4290e103245ce49b92b5e229375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the user data of this element.  <a href="#abd78c4290e103245ce49b92b5e229375">More...</a><br /></td></tr>
<tr class="separator:abd78c4290e103245ce49b92b5e229375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8195e91304799d65e2a198352a49217"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rule.html#ad8195e91304799d65e2a198352a49217">unsetVariable</a> ()</td></tr>
<tr class="memdesc:ad8195e91304799d65e2a198352a49217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the value of the "variable" attribute of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> object.  <a href="#ad8195e91304799d65e2a198352a49217">More...</a><br /></td></tr>
<tr class="separator:ad8195e91304799d65e2a198352a49217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d3fd71252912103e4d963530240dcb"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_rate_rule.html#a17d3fd71252912103e4d963530240dcb">~RateRule</a> ()</td></tr>
<tr class="memdesc:a17d3fd71252912103e4d963530240dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a>.  <a href="#a17d3fd71252912103e4d963530240dcb">More...</a><br /></td></tr>
<tr class="separator:a17d3fd71252912103e4d963530240dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa78ef1ca7e89aa9be18302622aad221f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_base.html#aa78ef1ca7e89aa9be18302622aad221f">setElementText</a> (const std::string &amp;text)</td></tr>
<tr class="memdesc:aa78ef1ca7e89aa9be18302622aad221f"><td class="mdescLeft">&#160;</td><td class="mdescRight">When overridden allows <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> elements to use the text included in between the elements tags.  <a href="#aa78ef1ca7e89aa9be18302622aad221f">More...</a><br /></td></tr>
<tr class="separator:aa78ef1ca7e89aa9be18302622aad221f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a18a922f9945f1166ed6ff0294885a9e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RateRule::RateRule </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> using the given SBML <code>level</code> and <code>version</code> values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>an unsigned int, the SBML Level to assign to this <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a>.</td></tr>
    <tr><td class="paramname">version</td><td>an unsigned int, the SBML Version to assign to this <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_s_b_m_l_constructor_exception.html" title=" Exceptions thrown by some libSBML constructors. ">SBMLConstructorException</a></td><td>Thrown if the given <code>level</code> and <code>version</code> combination are invalid or if this object is incompatible with the given level and version.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Attempting to add an object to an <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> having a different combination of SBML Level, Version and XML namespaces than the object itself will result in an error at the time a caller attempts to make the addition. A parent object must have compatible Level, Version and XML namespaces. (Strictly speaking, a parent may also have more XML namespaces than a child, but the reverse is not permitted.) The restriction is necessary to ensure that an SBML model has a consistent overall structure. This requires callers to manage their objects carefully, but the benefit is increased flexibility in how models can be created by permitting callers to create objects bottom-up if desired. In situations where objects are not yet attached to parents (e.g., <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a>), knowledge of the intented SBML Level and Version help libSBML determine such things as whether it is valid to assign a particular value to an attribute. </dd></dl>

</div>
</div>
<a class="anchor" id="a8395da17406a747f493035d3eeb1fb9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RateRule::RateRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_b_m_l_namespaces.html">SBMLNamespaces</a> *&#160;</td>
          <td class="paramname"><em>sbmlns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> using the given <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> object <code>sbmlns</code>. </p>
<dl class="section user"><dt></dt><dd>The <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> object encapsulates SBML Level/Version/namespaces information. It is used to communicate the SBML Level, Version, and (in Level&#160;3) packages used in addition to SBML Level&#160;3 Core. A common approach to using libSBML's <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> facilities is to create an <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> object somewhere in a program once, then hand that object as needed to object constructors that accept <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> as arguments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sbmlns</td><td>an <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_s_b_m_l_constructor_exception.html" title=" Exceptions thrown by some libSBML constructors. ">SBMLConstructorException</a></td><td>Thrown if the given <code>sbmlns</code> is inconsistent or incompatible with this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Attempting to add an object to an <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> having a different combination of SBML Level, Version and XML namespaces than the object itself will result in an error at the time a caller attempts to make the addition. A parent object must have compatible Level, Version and XML namespaces. (Strictly speaking, a parent may also have more XML namespaces than a child, but the reverse is not permitted.) The restriction is necessary to ensure that an SBML model has a consistent overall structure. This requires callers to manage their objects carefully, but the benefit is increased flexibility in how models can be created by permitting callers to create objects bottom-up if desired. In situations where objects are not yet attached to parents (e.g., <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a>), knowledge of the intented SBML Level and Version help libSBML determine such things as whether it is valid to assign a particular value to an attribute. </dd></dl>

</div>
</div>
<a class="anchor" id="a17d3fd71252912103e4d963530240dcb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RateRule::~RateRule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a852e0bd8bfc64342750faf5cbccec65e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::addCVTerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_v_term.html">CVTerm</a> *&#160;</td>
          <td class="paramname"><em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newBag</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a copy of the given <a class="el" href="class_c_v_term.html" title=" A MIRIAM-compliant controlled vocabulary term. ">CVTerm</a> object to this SBML object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>the <a class="el" href="class_c_v_term.html" title=" A MIRIAM-compliant controlled vocabulary term. ">CVTerm</a> to assign.</td></tr>
    <tr><td class="paramname">newBag</td><td>if <code>true</code>, creates a new RDF bag with the same identifier as a previous bag, and if <code>false</code>, adds the term to an existing RDF bag with the same type of qualifier as the term being added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a>, if this object lacks a "metaid" attribute </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since the CV Term uses the "metaid" attribute of the object as a reference, if the object has no "metaid" attribute value set, then the <a class="el" href="class_c_v_term.html" title=" A MIRIAM-compliant controlled vocabulary term. ">CVTerm</a> will not be added.</dd>
<dd>
This method should be used with some caution. The fact that this method <em>copies</em> the object passed to it means that the caller will be left holding a physically different object instance than the one contained inside this object. Changes made to the original object instance (such as resetting attribute values) will <em>not affect the instance in this object</em>. In addition, the caller should make sure to free the original object if it is no longer being used, or else a memory leak will result. Please see other methods on this class (particularly a corresponding method whose name begins with the word <code>create</code>) for alternatives that do not lead to these issues. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="add_c_v_terms_8cpp-example.html#a16">addCVTerms.cpp</a>, <a class="el" href="adding_evidence_codes_1_8cpp-example.html#a16">addingEvidenceCodes_1.cpp</a>, and <a class="el" href="adding_evidence_codes_2_8cpp-example.html#a16">addingEvidenceCodes_2.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="accc96fb06a79df769eb3669e090771e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::appendAnnotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>annotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given <code>annotation</code> to the "annotation" subelement of this object. </p>
<p>Whereas the <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> "notes" subelement is a container for content to be shown directly to humans, the "annotation" element is a container for optional software-generated content <em>not</em> meant to be shown to humans. Every object derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> can have its own value for "annotation". The element's content type is <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls" target="_blank">XML type "any"</a>, allowing essentially arbitrary well-formed XML data content.</p>
<p>SBML places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the SBML specifications for more details.</p>
<p>Unlike <a class="el" href="class_s_base.html#a11d9c02a3690d9a13362835ef0133125" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object. ">SBase::setAnnotation(const XMLNode* annotation)</a> or <a class="el" href="class_s_base.html#a75b1541bd854ad7edfe0aff79ab3231f" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object. ">SBase::setAnnotation(const std::string&amp; annotation)</a>, this method allows other annotations to be preserved when an application adds its own data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annotation</td><td>an XML structure that is to be copied and appended to the content of the "annotation" subelement of this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> (if the parent element does not have the 'metaid' attribute set) </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dad3ae4ef19483c3441aaaf0138a2d3b1a">LIBSBML_DUPLICATE_ANNOTATION_NS</a> (if the parent was already annotated with the annotation in question)</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#adbff50c6c73c044a5c8e29e6b5dcefc6" title="Returns the content of the &quot;annotation&quot; subelement of this object as a character string. ">getAnnotationString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a279ce55f23330dc6bb0231774adfc42b" title="Predicate returning true if this object&#39;s &quot;annotation&quot; subelement exists and has content. ">isSetAnnotation()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a11d9c02a3690d9a13362835ef0133125" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object. ">setAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a75b1541bd854ad7edfe0aff79ab3231f" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object. ">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a118148398f5c626bf9697887296f97b8" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object. ">appendAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a9121d6a4f7401fe957cc75647a1e95ed" title="Unsets the value of the &quot;annotation&quot; subelement of this SBML object. ">unsetAnnotation()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_model.html#ab2762b5bd0f32b5a4a1e9141ca9a5cbf">Model</a>, and <a class="el" href="class_species_reference.html#abb4003189aea5d71767e2f281fd4afc4">SpeciesReference</a>.</p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="adding_evidence_codes_2_8cpp-example.html#a28">addingEvidenceCodes_2.cpp</a>, and <a class="el" href="append_annotation_8cpp-example.html#a9">appendAnnotation.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a118148398f5c626bf9697887296f97b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::appendAnnotation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>annotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given <code>annotation</code> to the "annotation" subelement of this object. </p>
<p>Whereas the <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> "notes" subelement is a container for content to be shown directly to humans, the "annotation" element is a container for optional software-generated content <em>not</em> meant to be shown to humans. Every object derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> can have its own value for "annotation". The element's content type is <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls" target="_blank">XML type "any"</a>, allowing essentially arbitrary well-formed XML data content.</p>
<p>SBML places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the SBML specifications for more details.</p>
<p>Unlike <a class="el" href="class_s_base.html#a11d9c02a3690d9a13362835ef0133125" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object. ">SBase::setAnnotation(const XMLNode* annotation)</a> or <a class="el" href="class_s_base.html#a75b1541bd854ad7edfe0aff79ab3231f" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object. ">SBase::setAnnotation(const std::string&amp; annotation)</a>, this method allows other annotations to be preserved when an application adds its own data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annotation</td><td>an XML string that is to be copied and appended to the content of the "annotation" subelement of this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> (if the parent element does not have the 'metaid' attribute set) </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dad3ae4ef19483c3441aaaf0138a2d3b1a">LIBSBML_DUPLICATE_ANNOTATION_NS</a> (if the parent was already annotated with the annotation in question)</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#adbff50c6c73c044a5c8e29e6b5dcefc6" title="Returns the content of the &quot;annotation&quot; subelement of this object as a character string. ">getAnnotationString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a279ce55f23330dc6bb0231774adfc42b" title="Predicate returning true if this object&#39;s &quot;annotation&quot; subelement exists and has content. ">isSetAnnotation()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a11d9c02a3690d9a13362835ef0133125" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object. ">setAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a75b1541bd854ad7edfe0aff79ab3231f" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object. ">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#accc96fb06a79df769eb3669e090771e5" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object. ">appendAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a9121d6a4f7401fe957cc75647a1e95ed" title="Unsets the value of the &quot;annotation&quot; subelement of this SBML object. ">unsetAnnotation()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_model.html#a866fda8a7ba2ba45bf861885fdac4dc1">Model</a>, and <a class="el" href="class_species_reference.html#a093267663f42220b92423da2fa64458c">SpeciesReference</a>.</p>

</div>
</div>
<a class="anchor" id="adb8c800163c108a27880bd644d7767ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::appendNotes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>notes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given <code>notes</code> to the "notes" subelement of this object. </p>
<p>The content of <code>notes</code> is copied.</p>
<p>The optional SBML element named "notes", present on every major SBML component type, is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</p>
<p>The format of "notes" elements must be <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. To help verify the formatting of "notes" content, libSBML provides the static utility method <a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content...">SyntaxChecker::hasExpectedXHTMLSyntax()</a>; however, readers are urged to consult the appropriate <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specification document</a> for the Level and Version of their model for more in-depth explanations. The SBML Level&#160;2 and&#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">notes</td><td>an XML node structure that is to appended to the content of the "notes" subelement of this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a6eee96ee206a55837c0d7b936f20f14d" title="Returns the content of the &quot;notes&quot; subelement of this object as a string. ">getNotesString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#aeff0554efc75440b5375b35a4d188ea0" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content. ">isSetNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e" title="Sets the value of the &quot;notes&quot; subelement of this SBML object. ">setNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a478ad1e0e2bb2dc27a9de6ab9bac4bf2" title="Sets the value of the &quot;notes&quot; subelement of this SBML object to a copy of the string notes...">setNotes(const std::string&amp; notes, bool addXHTMLMarkup)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a33da5a2b0b03cbe6af69730869e35212" title="Appends the given notes to the &quot;notes&quot; subelement of this object. ">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a89f626f2593df8e83da4cdbfe79142f7" title="Unsets the value of the &quot;notes&quot; subelement of this SBML object. ">unsetNotes()</a> </dd>
<dd>
<a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content...">SyntaxChecker::hasExpectedXHTMLSyntax()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a33da5a2b0b03cbe6af69730869e35212"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::appendNotes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>notes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the given <code>notes</code> to the "notes" subelement of this object. </p>
<p>The content of the parameter <code>notes</code> is copied.</p>
<p>The optional SBML element named "notes", present on every major SBML component type, is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</p>
<p>The format of "notes" elements must be <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. To help verify the formatting of "notes" content, libSBML provides the static utility method <a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content...">SyntaxChecker::hasExpectedXHTMLSyntax()</a>; however, readers are urged to consult the appropriate <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specification document</a> for the Level and Version of their model for more in-depth explanations. The SBML Level&#160;2 and&#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">notes</td><td>an XML string that is to appended to the content of the "notes" subelement of this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a6eee96ee206a55837c0d7b936f20f14d" title="Returns the content of the &quot;notes&quot; subelement of this object as a string. ">getNotesString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#aeff0554efc75440b5375b35a4d188ea0" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content. ">isSetNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e" title="Sets the value of the &quot;notes&quot; subelement of this SBML object. ">setNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a478ad1e0e2bb2dc27a9de6ab9bac4bf2" title="Sets the value of the &quot;notes&quot; subelement of this SBML object to a copy of the string notes...">setNotes(const std::string&amp; notes, bool addXHTMLMarkup)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adb8c800163c108a27880bd644d7767ad" title="Appends the given notes to the &quot;notes&quot; subelement of this object. ">appendNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a89f626f2593df8e83da4cdbfe79142f7" title="Unsets the value of the &quot;notes&quot; subelement of this SBML object. ">unsetNotes()</a> </dd>
<dd>
<a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content...">SyntaxChecker::hasExpectedXHTMLSyntax()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a401b49483ec3e768f7f163a912bafb0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rate_rule.html">RateRule</a> * RateRule::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and returns a deep copy of this <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>the (deep) copy of this <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> object. </dd></dl>

<p>Reimplemented from <a class="el" href="class_rule.html#a7e7c75537be5d3e9a0fd25d126d7f572">Rule</a>.</p>

</div>
</div>
<a class="anchor" id="afa7ed3391f84555629a74c3fe2ee7eec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rule::containsUndeclaredUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if the math expression of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> contains parameters/numbers with undeclared units. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the math expression of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> includes parameters/numbers with undeclared units, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A return value of <code>true</code> indicates that the <a class="el" href="class_unit_definition.html" title=" A definition of a unit used in an SBML model. ">UnitDefinition</a> returned by <a class="el" href="class_rule.html#aae3489e5f551ec6273d117bf45f563a2" title="Calculates and returns a UnitDefinition that expresses the units of measurement assumed for the &quot;math...">getDerivedUnitDefinition()</a> may not accurately represent the units of the expression.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_rule.html#aae3489e5f551ec6273d117bf45f563a2" title="Calculates and returns a UnitDefinition that expresses the units of measurement assumed for the &quot;math...">getDerivedUnitDefinition()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="print_units_8cpp-example.html#a57">printUnits.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a285ba0b2d009817d33ffde742ed38966"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rule::containsUndeclaredUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if the math expression of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> contains parameters/numbers with undeclared units. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the math expression of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> includes parameters/numbers with undeclared units, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A return value of <code>true</code> indicates that the <a class="el" href="class_unit_definition.html" title=" A definition of a unit used in an SBML model. ">UnitDefinition</a> returned by <a class="el" href="class_rule.html#aae3489e5f551ec6273d117bf45f563a2" title="Calculates and returns a UnitDefinition that expresses the units of measurement assumed for the &quot;math...">getDerivedUnitDefinition()</a> may not accurately represent the units of the expression.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_rule.html#aae3489e5f551ec6273d117bf45f563a2" title="Calculates and returns a UnitDefinition that expresses the units of measurement assumed for the &quot;math...">getDerivedUnitDefinition()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac39cfac9d726a12e0f05c6e393953888"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SBase::deleteDisabledPlugins </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recursive</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all information stored in disabled plugins. </p>
<p>If the plugin is re-enabled later, it will then not have any previously-stored information.</p>
<dl class="section user"><dt></dt><dd>SBML Level&#160;3 consists of a <em>Core</em> definition that can be extended via optional SBML Level&#160;3 <em>packages</em>. A given model may indicate that it uses one or more SBML packages, and likewise, a software tool may be able to support one or more packages. LibSBML does not come preconfigured with all possible packages included and enabled, in part because not all package specifications have been finalized. To support the ability for software systems to enable support for the Level&#160;3 packages they choose, libSBML features a <em>plug-in</em> mechanism. Each SBML Level&#160;3 package is implemented in a separate code plug-in that can be enabled by the application to support working with that SBML package. A given SBML model may thus contain not only objects defined by SBML Level&#160;3 Core, but also objects created by libSBML plug-ins supporting additional Level&#160;3 packages.</dd></dl>
<dl class="section user"><dt></dt><dd>If a plugin is <em>disabled</em>, the package information it contains is no longer considered to be part of the SBML document for the purposes of searching the document or writing out the document. However, the information is still retained, so if the plugin is enabled again, the same information will once again be available, and will be written out to the final model.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recursive</td><td>if <code>true</code>, the disabled information will be deleted also from all child elements, otherwise only from this <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a68708993ac87a7fee20fe46fea06a851" title="Returns the number of disabled plug-in objects (extension interfaces) for SBML Level&#160;3 package extens...">getNumDisabledPlugins()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5fe0e86c2c28a3226ddc42972241bddd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::disablePackage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pkgURI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pkgPrefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disables the given SBML Level&#160;3 package on this object. </p>
<p>This method disables the specified package on this object and other objects connected by child-parent links in the same <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> object.</p>
<p>An example of when this may be useful is during construction of model components when mixing existing and new models. Suppose your application read an SBML document containing a model that used the SBML Hierarchical Model Composition (&ldquo;comp&rdquo;) package, and extracted parts of that model in order to construct a new model in memory. The new, in-memory model will not accept a component drawn from an other <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> with different package namespace declarations. You could reconstruct the same namespaces in the in-memory model first, but as a shortcut, you could also disable the package namespace on the object being added. Here is a code example to help clarify this: </p><div class="fragment"><div class="line"><span class="comment">// We read in an SBML L3V1 model that uses the &#39;comp&#39;</span></div><div class="line"><span class="comment">// package namespace.</span></div><div class="line">doc = <a class="code" href="_s_b_m_l_reader_8h.html#a638d6486ad221b01e62d2d15d130a04e">readSBML</a>(<span class="stringliteral">&quot;sbml-file-with-comp-elements.xml&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// We extract one of the species from the model.</span></div><div class="line"><a class="code" href="class_species.html">Species</a>* s1 = doc-&gt;<a class="code" href="class_s_b_m_l_document.html#a01f1b5308e5c2c3aa2f5aa967aa599ef">getModel</a>()-&gt;<a class="code" href="class_model.html#a66728cce8799f57fa2742e76c4583c9d">getSpecies</a>(0);</div><div class="line"></div><div class="line"><span class="comment">// We construct a new model.  This model does not use the</span></div><div class="line"><span class="comment">// &#39;comp&#39; package.</span></div><div class="line"><a class="code" href="class_model.html">Model</a> * newModel = <span class="keyword">new</span> <a class="code" href="class_model.html">Model</a>(3,1);</div><div class="line"></div><div class="line"><span class="comment">// The following will fail with an error, because addSpecies()</span></div><div class="line"><span class="comment">// will first check that the parent of the given object has</span></div><div class="line"><span class="comment">// namespaces declared, and will discover that s1 does but</span></div><div class="line"><span class="comment">// newModel does not.</span></div><div class="line"></div><div class="line"><span class="comment">// newModel-&gt;addSpecies(s1);</span></div><div class="line"></div><div class="line"><span class="comment">// However, if we disable the &#39;comp&#39; package on s1, then</span></div><div class="line"><span class="comment">// the call to addSpecies will work.</span></div><div class="line"></div><div class="line">s1-&gt;<a class="code" href="class_s_base.html#a5fe0e86c2c28a3226ddc42972241bddd">disablePackage</a>(<span class="stringliteral">&quot;http://www.sbml.org/sbml/level3/version1/comp/version1&quot;</span>,</div><div class="line">                   <span class="stringliteral">&quot;comp&quot;</span>);</div><div class="line">newModel-&gt;<a class="code" href="class_model.html#a2760726af3b7d89f9590e634154d8017">addSpecies</a>(s1);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkgURI</td><td>the URI of the package.</td></tr>
    <tr><td class="paramname">pkgPrefix</td><td>the XML prefix of the package.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da381940e93af9dacbae414c4413beae31">LIBSBML_PKG_UNKNOWN</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da55dc550fc2f744dd411b452afa55a52b">LIBSBML_PKG_VERSION_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf4b39ff5e6c7e8073b19ab8b4f29fee1">LIBSBML_PKG_CONFLICTED_VERSION</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ae89a4757c093b8f9c491338bcb278921" title="Enables or disables the given SBML Level&#160;3 package on this object. ">enablePackage(const std::string&amp; pkgURI, const std::string&amp; pkgPrefix, bool flag)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae89a4757c093b8f9c491338bcb278921"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::enablePackage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pkgURI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pkgPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables or disables the given SBML Level&#160;3 package on this object. </p>
<p>This method enables the specified package on this object and other objects connected by child-parent links in the same <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> object. This method is the converse of <a class="el" href="class_s_base.html#a5fe0e86c2c28a3226ddc42972241bddd" title="Disables the given SBML Level&#160;3 package on this object. ">SBase::disablePackage(const std::string&amp; pkgURI, const std::string&amp; pkgPrefix)</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkgURI</td><td>the URI of the package.</td></tr>
    <tr><td class="paramname">pkgPrefix</td><td>the XML prefix of the package.</td></tr>
    <tr><td class="paramname">flag</td><td>whether to enable (<code>true</code>) or disable (<code>false</code>) the package.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da381940e93af9dacbae414c4413beae31">LIBSBML_PKG_UNKNOWN</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da55dc550fc2f744dd411b452afa55a52b">LIBSBML_PKG_VERSION_MISMATCH</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf4b39ff5e6c7e8073b19ab8b4f29fee1">LIBSBML_PKG_CONFLICTED_VERSION</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a5fe0e86c2c28a3226ddc42972241bddd" title="Disables the given SBML Level&#160;3 package on this object. ">disablePackage(const std::string&amp; pkgURI, const std::string&amp; pkgPrefix)</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="add_layout_8cpp-example.html#a6">addLayout.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab03cdef0daf939ae8f83b9a9ea24ff8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_list.html">List</a> * SBase::getAllElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_element_filter.html">ElementFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_list.html" title=" Simple, plain, generic lists. ">List</a> of all child <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> objects, including those nested to an arbitrary depth. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>a pointer to an <a class="el" href="class_element_filter.html" title=" Base class for filter functions. ">ElementFilter</a>, which causes the function to return only elements that match a particular set of constraints. If NULL (the default), the function will return all child objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a <a class="el" href="class_list.html" title=" Simple, plain, generic lists. ">List</a> of pointers to all objects that are children of this object. </dd></dl>

<p>Reimplemented in <a class="el" href="class_render_information_base.html#aa958d8d7cc5d68e8533ca965bba81328">RenderInformationBase</a>, <a class="el" href="class_render_group.html#a4a3493cdc8d90182f28052c17185b11f">RenderGroup</a>, <a class="el" href="class_group.html#a1c92b9001fe68f436f722958dba03977">Group</a>, <a class="el" href="class_gradient_base.html#a7c68f0600255ade16de973ca76a6b50f">GradientBase</a>, <a class="el" href="class_layout.html#a0ea8c2d45748c83b078e3857b2451d60">Layout</a>, <a class="el" href="class_render_curve.html#a28e5d736a4a2d135cdd6d1ee078dfa7e">RenderCurve</a>, <a class="el" href="class_style.html#ab24bf2d78131311113472b8e628ffdc9">Style</a>, <a class="el" href="class_line_ending.html#a298d30ceb06ecad70e6612755580e496">LineEnding</a>, <a class="el" href="class_multi_species_type.html#a7e1636eb19ca7cb54d0e7abbbe39b140">MultiSpeciesType</a>, <a class="el" href="class_global_render_information.html#a211b21f7e348711881b0c7a481fc7b3b">GlobalRenderInformation</a>, <a class="el" href="class_transition.html#a204c7f99af24e942b00c2aa28f089bc1">Transition</a>, <a class="el" href="class_local_render_information.html#a0e564256992928d4bcceca55816eb077">LocalRenderInformation</a>, <a class="el" href="class_list_of_function_terms.html#a8954f82844919cfa73b8306bfd173fcd">ListOfFunctionTerms</a>, <a class="el" href="class_list_of_global_render_information.html#a6c45c22f17f139079b57db2ef9760fad">ListOfGlobalRenderInformation</a>, <a class="el" href="class_list_of_local_render_information.html#ac5b864a15f1c13b81773407a7efc35f3">ListOfLocalRenderInformation</a>, <a class="el" href="class_model.html#af5c36c64d3d15f1e39b603794a8f722e">Model</a>, <a class="el" href="class_polygon.html#aee98d22d577881ee3790dbd6123b2285">Polygon</a>, <a class="el" href="class_s_b_m_l_document.html#ad2439ace63d766aa6855b78b8f70119e">SBMLDocument</a>, <a class="el" href="class_species_feature.html#a1bdedccdb403e719f2cc45725b9b421a">SpeciesFeature</a>, <a class="el" href="class_objective.html#ad83cad3f95088f33b667214b9e72b40a">Objective</a>, <a class="el" href="class_event.html#ac0a7ab95057e93424eca0ffcdf511ec3">Event</a>, <a class="el" href="class_species_feature_type.html#ab2e3737c84ff738e7b98033c85dfc03f">SpeciesFeatureType</a>, <a class="el" href="class_reaction_glyph.html#a28c53e8f1d873a00cd6088fa7551ed1c">ReactionGlyph</a>, <a class="el" href="class_unit_definition.html#a4fbaedbb5a3d68e3cae0a1f8db21f05d">UnitDefinition</a>, <a class="el" href="class_list_of.html#aa15ab67b6caa158f4e5a571e7225365c">ListOf</a>, <a class="el" href="class_gene_product_association.html#a7e8361dc6f2bebbf04ca206dcfefb3f2">GeneProductAssociation</a>, <a class="el" href="class_general_glyph.html#a33f98405ebf098ab73f8040cb9c7ea37">GeneralGlyph</a>, <a class="el" href="class_fbc_and.html#a66074bdf46f008a73dbed8bd53947817">FbcAnd</a>, <a class="el" href="class_fbc_or.html#ae82114be2e8361867b46e4f04a66f6f7">FbcOr</a>, <a class="el" href="class_reaction.html#a1c23cbb55fd230b7b9c7d2fa10ed68ce">Reaction</a>, <a class="el" href="class_kinetic_law.html#a6c74e1ecdd939bbaa2af94e21347d50a">KineticLaw</a>, <a class="el" href="class_curve.html#a76c2089882b2b67cbfead0a479256e85">Curve</a>, <a class="el" href="class_submodel.html#ada27efb33a393e17fac0540117cce489">Submodel</a>, <a class="el" href="class_bounding_box.html#a09ef4bd2f928e171822d2a6a2baabcc4">BoundingBox</a>, <a class="el" href="class_s_base_ref.html#a96bc2a270774dfa0f8901270de85cf93">SBaseRef</a>, <a class="el" href="class_species_reference_glyph.html#a865ce842fde43dfbf807043616722ac2">SpeciesReferenceGlyph</a>, <a class="el" href="class_graphical_object.html#a640f1178df1bb94a7d4b01e599c906c1">GraphicalObject</a>, <a class="el" href="class_cubic_bezier.html#aa53384d155e2a395397507248c888200">CubicBezier</a>, <a class="el" href="class_line_segment.html#a749afbaa74d4786c072bf89e2dbc320b">LineSegment</a>, and <a class="el" href="class_reference_glyph.html#aa7f02d40059a865ef2dfd46f00093d77">ReferenceGlyph</a>.</p>

</div>
</div>
<a class="anchor" id="a0143961ca5188d00203c99eef1de854e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_list.html">List</a> * SBase::getAllElementsFromPlugins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_element_filter.html">ElementFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="class_list.html" title=" Simple, plain, generic lists. ">List</a> of all child <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> objects contained in SBML package plug-ins. </p>
<dl class="section user"><dt></dt><dd>SBML Level&#160;3 consists of a <em>Core</em> definition that can be extended via optional SBML Level&#160;3 <em>packages</em>. A given model may indicate that it uses one or more SBML packages, and likewise, a software tool may be able to support one or more packages. LibSBML does not come preconfigured with all possible packages included and enabled, in part because not all package specifications have been finalized. To support the ability for software systems to enable support for the Level&#160;3 packages they choose, libSBML features a <em>plug-in</em> mechanism. Each SBML Level&#160;3 package is implemented in a separate code plug-in that can be enabled by the application to support working with that SBML package. A given SBML model may thus contain not only objects defined by SBML Level&#160;3 Core, but also objects created by libSBML plug-ins supporting additional Level&#160;3 packages.</dd></dl>
<p>This method walks down the list of all SBML Level&#160;3 packages used by this object and returns all child objects defined by those packages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>a pointer to an <a class="el" href="class_element_filter.html" title=" Base class for filter functions. ">ElementFilter</a>, which causes the function to return only elements that match a particular set of constraints. If NULL (the default), the function will return all child objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a <a class="el" href="class_list.html" title=" Simple, plain, generic lists. ">List</a> of pointers to all children objects from plug-ins. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1db4c7f15e643a3cb27fe3b85e22f05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_base.html">SBase</a> * SBase::getAncestorOfType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pkgName</em> = <code>&quot;core&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first ancestor object that has the given SBML type code from the given package. </p>
<p>LibSBML attaches an identifying code to every kind of SBML object. These are known as <em>SBML type codes</em>. The set of possible type codes is defined in the enumeration <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfe" title="The enumeration of possible SBML core object types. ">SBMLTypeCode_t</a>. The names of the type codes all begin with the characters <code>SBML_</code>.</p>
<p>This method searches the tree of objects that are parents of this object, and returns the first one that has the given SBML type code from the given <code>pkgName</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the SBML type code of the object sought.</td></tr>
    <tr><td class="paramname">pkgName</td><td>(optional) the short name of an SBML Level&#160;3 package to which the sought-after object must belong.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ancestor SBML object of this SBML object that corresponds to the given <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfe" title="The enumeration of possible SBML core object types. ">SBMLTypeCode_t</a> value, or <code>NULL</code> if no ancestor exists.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The optional argument <code>pkgName</code> must be used for all type codes from SBML Level&#160;3 packages. Otherwise, the function will search the "core" namespace alone, not find any corresponding elements, and return NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a432c412387b4a5cb6771a1c0f40c47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_base.html">SBase</a> * SBase::getAncestorOfType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>pkgName</em> = <code>&quot;core&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first ancestor object that has the given SBML type code from the given package. </p>
<p>LibSBML attaches an identifying code to every kind of SBML object. These are known as <em>SBML type codes</em>. The set of possible type codes is defined in the enumeration <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfe" title="The enumeration of possible SBML core object types. ">SBMLTypeCode_t</a>. The names of the type codes all begin with the characters <code>SBML_</code>.</p>
<p>This method searches the tree of objects that are parents of this object, and returns the first one that has the given SBML type code from the given <code>pkgName</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the SBML type code of the object sought.</td></tr>
    <tr><td class="paramname">pkgName</td><td>(optional) the short name of an SBML Level&#160;3 package to which the sought-after object must belong.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ancestor SBML object of this SBML object that corresponds to the given <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfe" title="The enumeration of possible SBML core object types. ">SBMLTypeCode_t</a> value, or <code>NULL</code> if no ancestor exists.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The optional argument <code>pkgName</code> must be used for all type codes from SBML Level&#160;3 packages. Otherwise, the function will search the "core" namespace alone, not find any corresponding elements, and return NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a4fbf6701023075573bd76fa0bd276291"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_node.html">XMLNode</a> * SBase::getAnnotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the content of the "annotation" subelement of this object as a tree of <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> objects. </p>
<dl class="section user"><dt></dt><dd>Whereas the SBML "notes" subelement is a container for content to be shown directly to humans, the "annotation" element is a container for optional software-generated content <em>not</em> meant to be shown to humans. Every object derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> can have its own value for "annotation". The element's content type is <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls" target="_blank">XML type "any"</a>, allowing essentially arbitrary well-formed XML data content.</dd></dl>
<p>SBML places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the SBML specifications for more details.</p>
<p>The annotations returned by this method will be in XML form. LibSBML provides an object model and related interfaces for certain specific kinds of annotations, namely model history information and RDF content. See the <a class="el" href="class_model_history.html" title=" MIRIAM-compliant data about a model&#39;s history. ">ModelHistory</a>, <a class="el" href="class_c_v_term.html" title=" A MIRIAM-compliant controlled vocabulary term. ">CVTerm</a> and <a class="el" href="class_r_d_f_annotation_parser.html" title=" MIRIAM-compliant RDF annotation reader/writer. ">RDFAnnotationParser</a> classes for more information about the facilities available.</p>
<dl class="section return"><dt>Returns</dt><dd>the annotation of this SBML object as a tree of <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> objects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#adbff50c6c73c044a5c8e29e6b5dcefc6" title="Returns the content of the &quot;annotation&quot; subelement of this object as a character string. ">getAnnotationString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a279ce55f23330dc6bb0231774adfc42b" title="Predicate returning true if this object&#39;s &quot;annotation&quot; subelement exists and has content. ">isSetAnnotation()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a11d9c02a3690d9a13362835ef0133125" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object. ">setAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a75b1541bd854ad7edfe0aff79ab3231f" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object. ">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#accc96fb06a79df769eb3669e090771e5" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object. ">appendAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a118148398f5c626bf9697887296f97b8" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object. ">appendAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a9121d6a4f7401fe957cc75647a1e95ed" title="Unsets the value of the &quot;annotation&quot; subelement of this SBML object. ">unsetAnnotation()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab1b46329bd00e67fe52d3d75ae038714"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_node.html">XMLNode</a> * SBase::getAnnotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the content of the "annotation" subelement of this object as a tree of <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> objects. </p>
<dl class="section user"><dt></dt><dd>Whereas the SBML "notes" subelement is a container for content to be shown directly to humans, the "annotation" element is a container for optional software-generated content <em>not</em> meant to be shown to humans. Every object derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> can have its own value for "annotation". The element's content type is <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls" target="_blank">XML type "any"</a>, allowing essentially arbitrary well-formed XML data content.</dd></dl>
<p>SBML places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the SBML specifications for more details.</p>
<p>The annotations returned by this method will be in XML form. LibSBML provides an object model and related interfaces for certain specific kinds of annotations, namely model history information and RDF content. See the <a class="el" href="class_model_history.html" title=" MIRIAM-compliant data about a model&#39;s history. ">ModelHistory</a>, <a class="el" href="class_c_v_term.html" title=" A MIRIAM-compliant controlled vocabulary term. ">CVTerm</a> and <a class="el" href="class_r_d_f_annotation_parser.html" title=" MIRIAM-compliant RDF annotation reader/writer. ">RDFAnnotationParser</a> classes for more information about the facilities available.</p>
<dl class="section return"><dt>Returns</dt><dd>the annotation of this SBML object as a tree of <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> objects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#adbff50c6c73c044a5c8e29e6b5dcefc6" title="Returns the content of the &quot;annotation&quot; subelement of this object as a character string. ">getAnnotationString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a279ce55f23330dc6bb0231774adfc42b" title="Predicate returning true if this object&#39;s &quot;annotation&quot; subelement exists and has content. ">isSetAnnotation()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a11d9c02a3690d9a13362835ef0133125" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object. ">setAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a75b1541bd854ad7edfe0aff79ab3231f" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object. ">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#accc96fb06a79df769eb3669e090771e5" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object. ">appendAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a118148398f5c626bf9697887296f97b8" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object. ">appendAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a9121d6a4f7401fe957cc75647a1e95ed" title="Unsets the value of the &quot;annotation&quot; subelement of this SBML object. ">unsetAnnotation()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adbff50c6c73c044a5c8e29e6b5dcefc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string SBase::getAnnotationString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the content of the "annotation" subelement of this object as a character string. </p>
<dl class="section user"><dt></dt><dd>Whereas the SBML "notes" subelement is a container for content to be shown directly to humans, the "annotation" element is a container for optional software-generated content <em>not</em> meant to be shown to humans. Every object derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> can have its own value for "annotation". The element's content type is <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls" target="_blank">XML type "any"</a>, allowing essentially arbitrary well-formed XML data content.</dd></dl>
<p>SBML places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the SBML specifications for more details.</p>
<p>The annotations returned by this method will be in string form. See the method <a class="el" href="class_s_base.html#a4fbf6701023075573bd76fa0bd276291" title="Returns the content of the &quot;annotation&quot; subelement of this object as a tree of XMLNode objects...">getAnnotation()</a> for a version that returns annotations in XML form.</p>
<dl class="section return"><dt>Returns</dt><dd>the annotation of this SBML object as a character string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a4fbf6701023075573bd76fa0bd276291" title="Returns the content of the &quot;annotation&quot; subelement of this object as a tree of XMLNode objects...">getAnnotation()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a279ce55f23330dc6bb0231774adfc42b" title="Predicate returning true if this object&#39;s &quot;annotation&quot; subelement exists and has content. ">isSetAnnotation()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a11d9c02a3690d9a13362835ef0133125" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object. ">setAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a75b1541bd854ad7edfe0aff79ab3231f" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object. ">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#accc96fb06a79df769eb3669e090771e5" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object. ">appendAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a118148398f5c626bf9697887296f97b8" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object. ">appendAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a9121d6a4f7401fe957cc75647a1e95ed" title="Unsets the value of the &quot;annotation&quot; subelement of this SBML object. ">unsetAnnotation()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="print_annotation_8cpp-example.html#a6">printAnnotation.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a2acdb3d3c45b598d9a9741dce6ac6c15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string SBase::getAnnotationString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the content of the "annotation" subelement of this object as a character string. </p>
<dl class="section user"><dt></dt><dd>Whereas the SBML "notes" subelement is a container for content to be shown directly to humans, the "annotation" element is a container for optional software-generated content <em>not</em> meant to be shown to humans. Every object derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> can have its own value for "annotation". The element's content type is <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls" target="_blank">XML type "any"</a>, allowing essentially arbitrary well-formed XML data content.</dd></dl>
<p>SBML places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the SBML specifications for more details.</p>
<p>The annotations returned by this method will be in string form. See the method <a class="el" href="class_s_base.html#a4fbf6701023075573bd76fa0bd276291" title="Returns the content of the &quot;annotation&quot; subelement of this object as a tree of XMLNode objects...">getAnnotation()</a> for a version that returns annotations in XML form.</p>
<dl class="section return"><dt>Returns</dt><dd>the annotation of this SBML object as a character string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a4fbf6701023075573bd76fa0bd276291" title="Returns the content of the &quot;annotation&quot; subelement of this object as a tree of XMLNode objects...">getAnnotation()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a279ce55f23330dc6bb0231774adfc42b" title="Predicate returning true if this object&#39;s &quot;annotation&quot; subelement exists and has content. ">isSetAnnotation()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a11d9c02a3690d9a13362835ef0133125" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object. ">setAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a75b1541bd854ad7edfe0aff79ab3231f" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object. ">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#accc96fb06a79df769eb3669e090771e5" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object. ">appendAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a118148398f5c626bf9697887296f97b8" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object. ">appendAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a9121d6a4f7401fe957cc75647a1e95ed" title="Unsets the value of the &quot;annotation&quot; subelement of this SBML object. ">unsetAnnotation()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad3afa2adb559d29047c2ba2e1e60dd39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SBase::getColumn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the column number where this object first appears in the XML representation of the SBML document. </p>
<dl class="section return"><dt>Returns</dt><dd>the column number of this SBML object. If this object was created programmatically and not read from a file, this method will return the value <code>0</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The column number for each construct in an SBML model is set upon reading the model. The accuracy of the column number depends on the correctness of the XML representation of the model, and on the particular XML parser library being used. The former limitation relates to the following problem: if the model is actually invalid XML, then the parser may not be able to interpret the data correctly and consequently may not be able to establish the real column number. The latter limitation is simply that different parsers seem to have their own accuracy limitations, and out of all the parsers supported by libSBML, none have been 100% accurate in all situations. (At this time, libSBML supports the use of <a href="http://xmlsoft.org" target="_blank">libxml2</a>, <a href="http://expat.sourceforge.net/" target="_blank">Expat</a> and <a href="http://xerces.apache.org/xerces-c/" target="_blank">Xerces</a>.)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#acdeb5554fd732ec045b6b31f3b56b8cd" title="Returns the line number where this object first appears in the XML representation of the SBML documen...">getLine()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae07ccf83cfe580d386088d88b61e60ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_v_term.html">CVTerm</a> * SBase::getCVTerm </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the nth <a class="el" href="class_c_v_term.html" title=" A MIRIAM-compliant controlled vocabulary term. ">CVTerm</a> in the list of CVTerms of this SBML object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>unsigned int the index of the <a class="el" href="class_c_v_term.html" title=" A MIRIAM-compliant controlled vocabulary term. ">CVTerm</a> to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth <a class="el" href="class_c_v_term.html" title=" A MIRIAM-compliant controlled vocabulary term. ">CVTerm</a> in the list of CVTerms for this SBML object. If the index <code>n</code> is invalid, <code>NULL</code> is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b9dcb83f0b3da9466817e3d32f197f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_list.html">List</a> * SBase::getCVTerms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of <a class="el" href="class_c_v_term.html" title=" A MIRIAM-compliant controlled vocabulary term. ">CVTerm</a> objects in the annotations of this SBML object. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of CVTerms for this SBML object. </dd></dl>

</div>
</div>
<a class="anchor" id="a936cde6e165e162e0cd2f149ffe9b0d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_list.html">List</a> * SBase::getCVTerms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of <a class="el" href="class_c_v_term.html" title=" A MIRIAM-compliant controlled vocabulary term. ">CVTerm</a> objects in the annotations of this SBML object. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of CVTerms for this SBML object. </dd></dl>

</div>
</div>
<a class="anchor" id="aae3489e5f551ec6273d117bf45f563a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_unit_definition.html">UnitDefinition</a> * Rule::getDerivedUnitDefinition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns a <a class="el" href="class_unit_definition.html" title=" A definition of a unit used in an SBML model. ">UnitDefinition</a> that expresses the units of measurement assumed for the "math" expression of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>. </p>
<dl class="section user"><dt></dt><dd>The units are calculated based on the mathematical expression in the <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> and the model quantities referenced by <code>&lt;ci&gt;</code> elements used within that expression. The method <a class="el" href="class_rule.html#aae3489e5f551ec6273d117bf45f563a2" title="Calculates and returns a UnitDefinition that expresses the units of measurement assumed for the &quot;math...">Rule::getDerivedUnitDefinition()</a> returns the calculated units, to the extent that libSBML can compute them.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The functionality that facilitates unit analysis depends on the model as a whole. Thus, in cases where the object has not been added to a model or the model itself is incomplete, unit analysis is not possible and this method will return <code>NULL</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><span class="warning">Note that it is possible the "math" expression in the <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> contains pure numbers or parameters with undeclared units. In those cases, it is not possible to calculate the units of the overall expression without making assumptions. LibSBML does not make assumptions about the units, and <a class="el" href="class_rule.html#aae3489e5f551ec6273d117bf45f563a2" title="Calculates and returns a UnitDefinition that expresses the units of measurement assumed for the &quot;math...">Rule::getDerivedUnitDefinition()</a> only returns the units as far as it is able to determine them. For example, in an expression <em>X + Y</em>, if <em>X</em> has unambiguously-defined units and <em>Y</em> does not, it will return the units of <em>X</em>. <b>It is important that callers also invoke the method</b> <a class="el" href="class_rule.html#afa7ed3391f84555629a74c3fe2ee7eec" title="Predicate returning true if the math expression of this Rule contains parameters/numbers with undecla...">Rule::containsUndeclaredUnits()</a> <b>to determine whether this situation holds</b>. Callers may wish to take suitable actions in those scenarios.</span></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_unit_definition.html" title=" A definition of a unit used in an SBML model. ">UnitDefinition</a> that expresses the units of the math expression of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>, or <code>NULL</code> if one cannot be constructed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_rule.html#afa7ed3391f84555629a74c3fe2ee7eec" title="Predicate returning true if the math expression of this Rule contains parameters/numbers with undecla...">containsUndeclaredUnits()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="print_units_8cpp-example.html#a56">printUnits.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a25c79fac4eb2635ab2b54dae0588713f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_unit_definition.html">UnitDefinition</a> * Rule::getDerivedUnitDefinition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns a <a class="el" href="class_unit_definition.html" title=" A definition of a unit used in an SBML model. ">UnitDefinition</a> that expresses the units of measurement assumed for the "math" expression of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>. </p>
<dl class="section user"><dt></dt><dd>The units are calculated based on the mathematical expression in the <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> and the model quantities referenced by <code>&lt;ci&gt;</code> elements used within that expression. The method <a class="el" href="class_rule.html#aae3489e5f551ec6273d117bf45f563a2" title="Calculates and returns a UnitDefinition that expresses the units of measurement assumed for the &quot;math...">Rule::getDerivedUnitDefinition()</a> returns the calculated units, to the extent that libSBML can compute them.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The functionality that facilitates unit analysis depends on the model as a whole. Thus, in cases where the object has not been added to a model or the model itself is incomplete, unit analysis is not possible and this method will return <code>NULL</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><span class="warning">Note that it is possible the "math" expression in the <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> contains pure numbers or parameters with undeclared units. In those cases, it is not possible to calculate the units of the overall expression without making assumptions. LibSBML does not make assumptions about the units, and <a class="el" href="class_rule.html#aae3489e5f551ec6273d117bf45f563a2" title="Calculates and returns a UnitDefinition that expresses the units of measurement assumed for the &quot;math...">Rule::getDerivedUnitDefinition()</a> only returns the units as far as it is able to determine them. For example, in an expression <em>X + Y</em>, if <em>X</em> has unambiguously-defined units and <em>Y</em> does not, it will return the units of <em>X</em>. <b>It is important that callers also invoke the method</b> <a class="el" href="class_rule.html#afa7ed3391f84555629a74c3fe2ee7eec" title="Predicate returning true if the math expression of this Rule contains parameters/numbers with undecla...">Rule::containsUndeclaredUnits()</a> <b>to determine whether this situation holds</b>. Callers may wish to take suitable actions in those scenarios.</span></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_unit_definition.html" title=" A definition of a unit used in an SBML model. ">UnitDefinition</a> that expresses the units of the math expression of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>, or <code>NULL</code> if one cannot be constructed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_rule.html#afa7ed3391f84555629a74c3fe2ee7eec" title="Predicate returning true if the math expression of this Rule contains parameters/numbers with undecla...">containsUndeclaredUnits()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8012eba52b904a1fcfb2a483eef94810"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_base_plugin.html">SBasePlugin</a> * SBase::getDisabledPlugin </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the nth disabled plug-in object (extension interface) for an SBML Level&#160;3 package extension. </p>
<p>If no such plugin exists, NULL is returned.</p>
<dl class="section user"><dt></dt><dd>SBML Level&#160;3 consists of a <em>Core</em> definition that can be extended via optional SBML Level&#160;3 <em>packages</em>. A given model may indicate that it uses one or more SBML packages, and likewise, a software tool may be able to support one or more packages. LibSBML does not come preconfigured with all possible packages included and enabled, in part because not all package specifications have been finalized. To support the ability for software systems to enable support for the Level&#160;3 packages they choose, libSBML features a <em>plug-in</em> mechanism. Each SBML Level&#160;3 package is implemented in a separate code plug-in that can be enabled by the application to support working with that SBML package. A given SBML model may thus contain not only objects defined by SBML Level&#160;3 Core, but also objects created by libSBML plug-ins supporting additional Level&#160;3 packages.</dd></dl>
<dl class="section user"><dt></dt><dd>If a plugin is <em>disabled</em>, the package information it contains is no longer considered to be part of the SBML document for the purposes of searching the document or writing out the document. However, the information is still retained, so if the plugin is enabled again, the same information will once again be available, and will be written out to the final model.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the disabled plug-in to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth disabled plug-in object (the libSBML extension interface) of a package extension. If the index <code>n</code> is invalid, <code>NULL</code> is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a68708993ac87a7fee20fe46fea06a851" title="Returns the number of disabled plug-in objects (extension interfaces) for SBML Level&#160;3 package extens...">getNumDisabledPlugins()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">getPlugin(const std::string&amp; package)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad3cb30f3dedf374b937811ed54ec3364"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_base_plugin.html">SBasePlugin</a> * SBase::getDisabledPlugin </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the nth disabled plug-in object (extension interface) for an SBML Level&#160;3 package extension. </p>
<p>If no such plugin exists, NULL is returned.</p>
<dl class="section user"><dt></dt><dd>SBML Level&#160;3 consists of a <em>Core</em> definition that can be extended via optional SBML Level&#160;3 <em>packages</em>. A given model may indicate that it uses one or more SBML packages, and likewise, a software tool may be able to support one or more packages. LibSBML does not come preconfigured with all possible packages included and enabled, in part because not all package specifications have been finalized. To support the ability for software systems to enable support for the Level&#160;3 packages they choose, libSBML features a <em>plug-in</em> mechanism. Each SBML Level&#160;3 package is implemented in a separate code plug-in that can be enabled by the application to support working with that SBML package. A given SBML model may thus contain not only objects defined by SBML Level&#160;3 Core, but also objects created by libSBML plug-ins supporting additional Level&#160;3 packages.</dd></dl>
<dl class="section user"><dt></dt><dd>If a plugin is <em>disabled</em>, the package information it contains is no longer considered to be part of the SBML document for the purposes of searching the document or writing out the document. However, the information is still retained, so if the plugin is enabled again, the same information will once again be available, and will be written out to the final model.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the disabled plug-in to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth disabled plug-in object (the libSBML extension interface) of a package extension. If the index <code>n</code> is invalid, <code>NULL</code> is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a68708993ac87a7fee20fe46fea06a851" title="Returns the number of disabled plug-in objects (extension interfaces) for SBML Level&#160;3 package extens...">getNumDisabledPlugins()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">getPlugin(const std::string&amp; package)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5fd4be8061a6a0338ebc2b8018ffbd46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_base.html">SBase</a> * SBase::getElementByMetaId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>metaid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first child element it can find with a specific "metaid" attribute value, or <code>NULL</code> if no such object is found. </p>
<dl class="section user"><dt></dt><dd>The optional attribute named "metaid", present on every major SBML component type, is for supporting metadata annotations using RDF (<a href="http://www.w3.org/RDF/">Resource Description Format</a>). The attribute value has the data type <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a>, the XML identifier type, which means each "metaid" value must be globally unique within an SBML file. The latter point is important, because the uniqueness criterion applies across <em>any</em> attribute with type <code>ID</code> anywhere in the file, not just the "metaid" attribute used by SBML&mdash;something to be aware of if your application-specific XML content inside the "annotation" subelement happens to use the XML <code>ID</code> type. Although SBML itself specifies the use of <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a> only for the "metaid" attribute, SBML-compatible applications should be careful if they use XML <code>ID</code>'s in XML portions of a model that are not defined by SBML, such as in the application-specific content of the "annotation" subelement. Finally, note that LibSBML does not provide an explicit XML <code>ID</code> data type; it uses ordinary character strings, which is easier for applications to support.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metaid</td><td>string representing the "metaid" attribute value of the object to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first element found with the given meta-identifier. </dd></dl>

<p>Reimplemented in <a class="el" href="class_render_information_base.html#aa37b61a15f9d516e78a9c066fedc0184">RenderInformationBase</a>, <a class="el" href="class_render_group.html#ac81f85e5c6c11e7e719dcfb7182b6d89">RenderGroup</a>, <a class="el" href="class_group.html#a73f637f717f4f1d0b01c73c02497d758">Group</a>, <a class="el" href="class_gradient_base.html#acc53899e4194a92a582ef65fc64e77fd">GradientBase</a>, <a class="el" href="class_render_curve.html#a8974d664448976e1377e750533881219">RenderCurve</a>, <a class="el" href="class_style.html#a047eac01a9ae3a2313c8aa578eba5f92">Style</a>, <a class="el" href="class_line_ending.html#a0ebee519c9667316f9dcd439fa9e5972">LineEnding</a>, <a class="el" href="class_global_render_information.html#a198985617c1a7d9f0769cf40e786702d">GlobalRenderInformation</a>, <a class="el" href="class_local_render_information.html#a7b5ba9660f9a3c685d09ab7b32be79ea">LocalRenderInformation</a>, <a class="el" href="class_list_of_global_render_information.html#a81e1142c2b28959d50f2b9fe259cca4a">ListOfGlobalRenderInformation</a>, <a class="el" href="class_list_of_local_render_information.html#a27ea3b2c95b0c3fe75a79100cdc83ab1">ListOfLocalRenderInformation</a>, <a class="el" href="class_model.html#afb7059f3863360e329ccade685199805">Model</a>, <a class="el" href="class_polygon.html#a2be04416e37e76a56dfb287ce5d1670c">Polygon</a>, <a class="el" href="class_s_b_m_l_document.html#a29ea314fe828fb27f113ba519e603890">SBMLDocument</a>, <a class="el" href="class_event.html#a34106bba0cceda5c56fb73d3d61d64e9">Event</a>, <a class="el" href="class_unit_definition.html#a0a1762336e8d9ecec0cd1f92076b79f4">UnitDefinition</a>, <a class="el" href="class_list_of.html#ac0ce3ec01b441407d6fdf5644c2725fd">ListOf</a>, <a class="el" href="class_reaction.html#a2127a1fc3017428539cf534ab890a7ef">Reaction</a>, <a class="el" href="class_kinetic_law.html#a269e950c0092504fcc17762598e6a28a">KineticLaw</a>, <a class="el" href="class_submodel.html#a061095a3a9d14efe9ba8d8dbcd41cebc">Submodel</a>, <a class="el" href="class_s_base_ref.html#aba22cbcd1ed51fbd4f12785e0b0970e7">SBaseRef</a>, and <a class="el" href="class_transition.html#a5d7f61fb9ac2c9c5c03f246952ca687d">Transition</a>.</p>

</div>
</div>
<a class="anchor" id="a7ab46333d7e559e600c8fe770d715ce0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_base.html">SBase</a> * SBase::getElementByMetaId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>metaid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first child element it can find with a specific "metaid" attribute value, or <code>NULL</code> if no such object is found. </p>
<dl class="section user"><dt></dt><dd>The optional attribute named "metaid", present on every major SBML component type, is for supporting metadata annotations using RDF (<a href="http://www.w3.org/RDF/">Resource Description Format</a>). The attribute value has the data type <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a>, the XML identifier type, which means each "metaid" value must be globally unique within an SBML file. The latter point is important, because the uniqueness criterion applies across <em>any</em> attribute with type <code>ID</code> anywhere in the file, not just the "metaid" attribute used by SBML&mdash;something to be aware of if your application-specific XML content inside the "annotation" subelement happens to use the XML <code>ID</code> type. Although SBML itself specifies the use of <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a> only for the "metaid" attribute, SBML-compatible applications should be careful if they use XML <code>ID</code>'s in XML portions of a model that are not defined by SBML, such as in the application-specific content of the "annotation" subelement. Finally, note that LibSBML does not provide an explicit XML <code>ID</code> data type; it uses ordinary character strings, which is easier for applications to support.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metaid</td><td>string representing the "metaid" attribute value of the object to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first element found with the given meta-identifier. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9b81fdb8570c061842115f59d12ef99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_base.html">SBase</a> * SBase::getElementBySId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first child element found that has the given <code>id</code> in the model-wide <code>SId</code> namespace, or <code>NULL</code> if no such object is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>string representing the "id" attribute value of the object to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first element found with the given identifier. </dd></dl>

<p>Reimplemented in <a class="el" href="class_render_information_base.html#a3886eeb9b4289eb83af3cb85bbb15b61">RenderInformationBase</a>, <a class="el" href="class_render_group.html#a74e98d87a927883fd2d9a4812c770eb2">RenderGroup</a>, <a class="el" href="class_list_of_unit_definitions.html#a5a53e4ea1b8e3cc27827fc69a1467867">ListOfUnitDefinitions</a>, <a class="el" href="class_list_of_rules.html#a6e75cb86b68b4037614eb44bb79f6804">ListOfRules</a>, <a class="el" href="class_list_of_event_assignments.html#ac4908a1571236372d293c004190be796">ListOfEventAssignments</a>, <a class="el" href="class_list_of_initial_assignments.html#adfa8439528138ec80210ff9f17e23273">ListOfInitialAssignments</a>, <a class="el" href="class_group.html#aadee188ecb431fd3685dce85c9ac8d97">Group</a>, <a class="el" href="class_gradient_base.html#a3c9d3544236050a181547ff15bef20bc">GradientBase</a>, <a class="el" href="class_render_curve.html#a44de9f5198dc2b390d42d1690452cab1">RenderCurve</a>, <a class="el" href="class_style.html#a469209f6f5b876e66be22cb02ae8b915">Style</a>, <a class="el" href="class_line_ending.html#afce777f2420e84b4d2b8a8ceaca0d4b8">LineEnding</a>, <a class="el" href="class_list_of_local_parameters.html#a120ace95910434f09320650e7180eca8">ListOfLocalParameters</a>, <a class="el" href="class_global_render_information.html#a5858d11d8d704eb286e4c59c3ac5edd5">GlobalRenderInformation</a>, <a class="el" href="class_local_render_information.html#a3171c7891eda815d4f2e918a0c6071d6">LocalRenderInformation</a>, <a class="el" href="class_list_of_global_render_information.html#a136770ee7ab56db9e18a132aa1637266">ListOfGlobalRenderInformation</a>, <a class="el" href="class_list_of_local_render_information.html#aec220544aa861fb0de8d5b0b8866de26">ListOfLocalRenderInformation</a>, <a class="el" href="class_model.html#a68f6bd54475f4df29acf0e71399ce372">Model</a>, <a class="el" href="class_polygon.html#a68761ac3c33fd32d7c5b96079a2d9807">Polygon</a>, <a class="el" href="class_s_b_m_l_document.html#acb7e3ca2a0e5060818ca9129554c40f5">SBMLDocument</a>, <a class="el" href="class_event.html#ad6df4870a33fd8a01796d9ff88a67969">Event</a>, <a class="el" href="class_unit_definition.html#ae1bfd60e1a0efd8691866f62608c046d">UnitDefinition</a>, <a class="el" href="class_list_of.html#a2a1a8d70043a2386cbcfa299624de010">ListOf</a>, <a class="el" href="class_reaction.html#ae2ef556e179fb95e1c5c8b4799d3b8dd">Reaction</a>, <a class="el" href="class_kinetic_law.html#a44125a75319cc2bac2340d7fbc57c1e1">KineticLaw</a>, <a class="el" href="class_submodel.html#ad44910ded37e1908035e9d22476e884b">Submodel</a>, <a class="el" href="class_list_of_ports.html#ab1b928420a3caba7690c74dc164f90e2">ListOfPorts</a>, <a class="el" href="class_s_base_ref.html#adebc687aa99fb52f7d8d083128727ff2">SBaseRef</a>, and <a class="el" href="class_transition.html#a25b7e4ee4f40dc04c58cb911d7e508b6">Transition</a>.</p>

</div>
</div>
<a class="anchor" id="a58f9cf402bf4f5e090799270aad1c1cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_base.html">SBase</a> * SBase::getElementBySId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first child element found that has the given <code>id</code> in the model-wide <code>SId</code> namespace, or <code>NULL</code> if no such object is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>string representing the "id" attribute value of the object to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first element found with the given identifier. </dd></dl>

</div>
</div>
<a class="anchor" id="a92a86ec04e9fee983005cf7b24d9f1a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; Rule::getElementName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the XML element name of this object. </p>
<p>The returned value can be any of a number of different strings, depending on the SBML Level in use and the kind of <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> object this is. The rules as of libSBML version 5.18.0 are the following: </p><ul>
<li>
(Level&#160;2 and&#160;3) <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a>: returns <code>"rateRule"</code> </li>
<li>
(Level&#160;2 and&#160;3) <a class="el" href="class_assignment_rule.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule</a>: returns <code>"assignmentRule"</code> </li>
<li>
(Level&#160;2 and&#160;3) <a class="el" href="class_algebraic_rule.html" title=" An SBML algebraic rule representing 0 = f(W). ">AlgebraicRule</a>: returns <code>"algebraicRule"</code> </li>
<li>
(Level&#160;1 Version&#160;1) SpecieConcentrationRule: returns <code>"specieConcentrationRule"</code> </li>
<li>
(Level&#160;1 Version&#160;2) SpeciesConcentrationRule: returns <code>"speciesConcentrationRule"</code> </li>
<li>
(Level&#160;1) CompartmentVolumeRule: returns <code>"compartmentVolumeRule"</code> </li>
<li>
(Level&#160;1) ParameterRule: returns <code>"parameterRule"</code> </li>
<li>
Unknown rule type: returns <code>"unknownRule"</code> </li>
</ul>
<p>Beware that the last (<code>"unknownRule"</code>) is not a valid SBML element name.</p>
<dl class="section return"><dt>Returns</dt><dd>the name of this element. </dd></dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#a106e241767b89151e25ed89984c39564">SBase</a>.</p>

</div>
</div>
<a class="anchor" id="ab1309f4f14c012aec069340aa3dd9ddf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; Rule::getFormula </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mathematical expression of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> in text-string form. </p>
<p>The text string is produced by <a class="el" href="_formula_formatter_8cpp.html#a7621fa39bd34423ea59ed128bb17b6f4" title="Converts an AST to a string representation of a formula using a syntax basically derived from SBML Le...">SBML_formulaToString()</a>; please consult the documentation for that function to find out more about the format of the text-string formula.</p>
<dl class="section return"><dt>Returns</dt><dd>the formula text string for this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The attribute "formula" is specific to SBML Level&#160;1; in higher Levels of SBML, it has been replaced with a subelement named "math". However, libSBML provides a unified interface to the underlying math expression and this method can be used for models of all Levels of SBML.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_rule.html#ab1f1d983ede091d3096c51cdceb54135" title="Get the mathematical formula of this Rule as an ASTNode tree. ">getMath()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abd617bad05c960bee53c986e856b6ee1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Rule::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the "variable" attribute of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> (NOT the "id"). </p>
<dl class="section note"><dt>Note</dt><dd>Because of the inconsistent behavior of this function with respect to assignments and rules, it is now recommended to use the <a class="el" href="class_s_base.html#acd5e8dc937c46ace3af5125c8674c199" title="Returns the value of the &quot;id&quot; attribute of this SBML object. ">getIdAttribute()</a> or the <a class="el" href="class_rule.html#a21b6103384ba971fb7b1d85584566c7c" title="Get the value of the &quot;variable&quot; attribute of this Rule object. ">getVariable()</a> function instead.</dd></dl>
<p>The "variable" attribute of a <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> indicates the element which the results of the "math" are to be applied. An <a class="el" href="class_algebraic_rule.html" title=" An SBML algebraic rule representing 0 = f(W). ">AlgebraicRule</a> has no "variable", and will always return an empty string.</p>
<dl class="section return"><dt>Returns</dt><dd>the variable of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#acd5e8dc937c46ace3af5125c8674c199" title="Returns the value of the &quot;id&quot; attribute of this SBML object. ">getIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object. ">setIdAttribute(const std::string&amp; sid)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#ad201f20c9527cff5daf5d05bf49aac8c" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set. ">isSetIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object. ">unsetIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_rule.html#a21b6103384ba971fb7b1d85584566c7c" title="Get the value of the &quot;variable&quot; attribute of this Rule object. ">getVariable()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#a8bd7cb0de43db3680bd1eeb30022fcd3">SBase</a>.</p>

</div>
</div>
<a class="anchor" id="acd5e8dc937c46ace3af5125c8674c199"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; SBase::getIdAttribute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the "id" attribute of this SBML object. </p>
<dl class="section user"><dt></dt><dd>The identifier given by an object's "id" attribute value is used to identify the object within the SBML model definition. Other objects can refer to the component using this identifier. The data type of "id" is always <code>SId</code> or a type derived from that, such as <code>UnitSId</code>, depending on the object in question. All data types are defined as follows: <pre style="margin-left: 2em; border: none; font-weight: bold; color: black">
     letter ::= 'a'..'z','A'..'Z'
     digit  ::= '0'..'9'
     idChar ::= letter | digit | '_'
     SId    ::= ( letter | '_' ) idChar*
   </pre> The characters <code>(</code> and <code>)</code> are used for grouping, the character <code>*</code> "zero or more times", and the character <code>|</code> indicates logical "or". The equality of SBML identifiers is determined by an exact character sequence match; i.e., comparisons must be performed in a case-sensitive manner. This applies to all uses of <code>SId</code>, <code>SIdRef</code>, and derived types.</dd></dl>
<p>Users need to be aware of some important API issues that are the result of the history of SBML and libSBML. Prior to SBML Level&#160;3 Version&#160;2, SBML defined "id" and "name" attributes on only a subset of SBML objects. To simplify the work of programmers, libSBML's API provided get, set, check, and unset on the <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> object class itself instead of on individual subobject classes. This made the get/set/etc. methods uniformly available on all objects in the libSBML API. LibSBML simply returned empty strings or otherwise did not act when the methods were applied to SBML objects that were not defined by the SBML specification to have "id" or "name" attributes. Additional complications arose with the rule and assignment objects: <a class="el" href="class_initial_assignment.html" title=" An SBML initial assignment, evaluated once only. ">InitialAssignment</a>, <a class="el" href="class_event_assignment.html" title=" An assignment to a variable by an SBML event. ">EventAssignment</a>, <a class="el" href="class_assignment_rule.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule</a>, and <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a>. In early versions of SBML, the rule object hierarchy was different, and in addition, then as now, they possess different attributes: "variable" (for the rules and event assignments), "symbol" (for initial assignments), or neither (for algebraic rules). Prior to SBML Level&#160;3 Version&#160;2, <a class="el" href="class_s_base.html#a8bd7cb0de43db3680bd1eeb30022fcd3" title="Returns the value of the &quot;id&quot; attribute of this SBML object, if it has one, or the &quot;variable&quot; attribu...">getId()</a> would always return an empty string, and <a class="el" href="class_s_base.html#a20e059dca5f0e97bdc7dc2e8fd3e4c35" title="Predicate returning true if a call to getId() returns a non-empty string. ">isSetId()</a> would always return <code>false</code> for objects of these classes.</p>
<p>With the addition of "id" and "name" attributes on <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> in Level&#160;3 Version&#160;2, it became necessary to introduce a new way to interact with the attributes more consistently in libSBML to avoid breaking backward compatibility in the behavior of the original "id" methods. For this reason, libSBML provides four functions (<a class="el" href="class_s_base.html#acd5e8dc937c46ace3af5125c8674c199" title="Returns the value of the &quot;id&quot; attribute of this SBML object. ">getIdAttribute()</a>, <a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object. ">setIdAttribute()</a>, <a class="el" href="class_s_base.html#ad201f20c9527cff5daf5d05bf49aac8c" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set. ">isSetIdAttribute()</a>, and <a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object. ">unsetIdAttribute()</a>) that always act on the actual "id" attribute inherited from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a>, regardless of the object's type. <b>These new methods should be used instead of the older <a class="el" href="class_s_base.html#a8bd7cb0de43db3680bd1eeb30022fcd3" title="Returns the value of the &quot;id&quot; attribute of this SBML object, if it has one, or the &quot;variable&quot; attribu...">getId()</a>/setId()/etc. methods</b> unless the old behavior is somehow necessary. Regardless of the Level and Version of the SBML, these functions allow client applications to use more generalized code in some situations (for instance, when manipulating objects that are all known to have identifiers). If the object in question does not posess an "id" attribute according to the SBML specification for the Level and Version in use, libSBML will not allow the identifier to be set, nor will it read or write "id" attributes for those objects.</p>
<dl class="section return"><dt>Returns</dt><dd>the id of this SBML object, if set and valid for this level and version of SBML; an empty string otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Because of the inconsistent behavior of this function with respect to assignments and rules, callers should use <a class="el" href="class_s_base.html#acd5e8dc937c46ace3af5125c8674c199" title="Returns the value of the &quot;id&quot; attribute of this SBML object. ">getIdAttribute()</a> instead.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object. ">setIdAttribute(const std::string&amp; sid)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#ad201f20c9527cff5daf5d05bf49aac8c" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set. ">isSetIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object. ">unsetIdAttribute()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae97235bacc1a59b4ec29401254610229"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Rule::getL1TypeCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the SBML Level&#160;1 type code for this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> object. </p>
<p>This method only applies to SBML Level&#160;1 model objects. If this is not an SBML Level&#160;1 rule object, this method will return <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfea0316def67cdf9a94d4605d7efeb3cc23">SBML_UNKNOWN</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the SBML Level&#160;1 type code for this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> (namely, <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfeaf52d2bab1bdc55a5ad62cd6d42850067">SBML_COMPARTMENT_VOLUME_RULE</a>, <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfeabe09824edb95e4b4fa6967639eb4f567">SBML_PARAMETER_RULE</a>, <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfea5bdf0d6902889e1891aaaf3fb083145e">SBML_SPECIES_CONCENTRATION_RULE</a>, or <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfea0316def67cdf9a94d4605d7efeb3cc23">SBML_UNKNOWN</a>). </dd></dl>

</div>
</div>
<a class="anchor" id="ae22fcf03f946d415a46e4b8e4c69076a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SBase::getLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the SBML Level of the <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> object containing <em>this</em> object. </p>
<dl class="section user"><dt></dt><dd>LibSBML uses the class <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> as a top-level container for storing SBML content and data associated with it (such as warnings and error messages). An SBML model in libSBML is contained inside an <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> object. <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> corresponds roughly to the class <em>SBML</em> defined in the SBML Level&#160;3 and Level&#160;2 specifications, but it does not have a direct correspondence in SBML Level&#160;1. (But, it is created by libSBML no matter whether the model is Level&#160;1, Level&#160;2 or Level&#160;3.)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the SBML level of this SBML object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a555924b2486ab63a21fae675bdce8c5e" title="Returns the Version within the SBML Level of the SBMLDocument object containing this object...">getVersion()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a8726b2382c6945adddc1f469c6758be1" title="Returns a list of the XML Namespaces declared on the SBML document owning this object. ">getNamespaces()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#aa831f09f33c10055a222cd1900c99bf8" title="Returns the Version of the SBML Level&#160;3 package to which this element belongs to. ...">getPackageVersion()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="add_layout_8cpp-example.html#a5">addLayout.cpp</a>, <a class="el" href="convert_s_b_m_l_8cpp-example.html#a7">convertSBML.cpp</a>, and <a class="el" href="print_s_b_m_l_8cpp-example.html#a5">printSBML.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="acdeb5554fd732ec045b6b31f3b56b8cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SBase::getLine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the line number where this object first appears in the XML representation of the SBML document. </p>
<dl class="section return"><dt>Returns</dt><dd>the line number of this SBML object. If this object was created programmatically and not read from a file, this method will return the value <code>0</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The line number for each construct in an SBML model is set upon reading the model. The accuracy of the line number depends on the correctness of the XML representation of the model, and on the particular XML parser library being used. The former limitation relates to the following problem: if the model is actually invalid XML, then the parser may not be able to interpret the data correctly and consequently may not be able to establish the real line number. The latter limitation is simply that different parsers seem to have their own accuracy limitations, and out of all the parsers supported by libSBML, none have been 100% accurate in all situations. (At this time, libSBML supports the use of <a href="http://xmlsoft.org" target="_blank">libxml2</a>, <a href="http://expat.sourceforge.net/" target="_blank">Expat</a> and <a href="http://xerces.apache.org/xerces-c/" target="_blank">Xerces</a>.)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ad3afa2adb559d29047c2ba2e1e60dd39" title="Returns the column number where this object first appears in the XML representation of the SBML docum...">getColumn()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab1f1d983ede091d3096c51cdceb54135"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_a_s_t_node.html">ASTNode</a> * Rule::getMath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the mathematical formula of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> as an <a class="el" href="class_a_s_t_node.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode</a> tree. </p>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="class_a_s_t_node.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode</a>, the value of the "math" subelement of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>, or <code>NULL</code> if the math is not set.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The subelement "math" is present in SBML Levels&#160;2 and&#160;3. In SBML Level&#160;1, the equivalent construct is the attribute named "formula". LibSBML provides a unified interface to the underlying math expression and this method can be used for models of all Levels of SBML.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_rule.html#ab1309f4f14c012aec069340aa3dd9ddf" title="Returns the mathematical expression of this Rule in text-string form. ">getFormula()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="print_math_8cpp-example.html#a12">printMath.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad6dcf5f49d13567a1dfead284b7ac96b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; SBase::getMetaId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the "metaid" attribute of this SBML object. </p>
<dl class="section user"><dt></dt><dd>The optional attribute named "metaid", present on every major SBML component type, is for supporting metadata annotations using RDF (<a href="http://www.w3.org/RDF/">Resource Description Format</a>). The attribute value has the data type <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a>, the XML identifier type, which means each "metaid" value must be globally unique within an SBML file. The latter point is important, because the uniqueness criterion applies across <em>any</em> attribute with type <code>ID</code> anywhere in the file, not just the "metaid" attribute used by SBML&mdash;something to be aware of if your application-specific XML content inside the "annotation" subelement happens to use the XML <code>ID</code> type. Although SBML itself specifies the use of <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a> only for the "metaid" attribute, SBML-compatible applications should be careful if they use XML <code>ID</code>'s in XML portions of a model that are not defined by SBML, such as in the application-specific content of the "annotation" subelement. Finally, note that LibSBML does not provide an explicit XML <code>ID</code> data type; it uses ordinary character strings, which is easier for applications to support.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the meta-identifier of this SBML object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a24fc99c2ba9431594a78b78536699a0e" title="Predicate returning true if this object&#39;s &quot;metaid&quot; attribute is set. ">isSetMetaId()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a050779a94ecdb2d73d7edfef73bc1e55" title="Sets the value of the meta-identifier attribute of this SBML object. ">setMetaId(const std::string&amp; metaid)</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="adding_evidence_codes_2_8cpp-example.html#a23">addingEvidenceCodes_2.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a2880c1c6a2df519371637a9234ed68a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string &amp; SBase::getMetaId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the "metaid" attribute of this SBML object. </p>
<dl class="section user"><dt></dt><dd>The optional attribute named "metaid", present on every major SBML component type, is for supporting metadata annotations using RDF (<a href="http://www.w3.org/RDF/">Resource Description Format</a>). The attribute value has the data type <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a>, the XML identifier type, which means each "metaid" value must be globally unique within an SBML file. The latter point is important, because the uniqueness criterion applies across <em>any</em> attribute with type <code>ID</code> anywhere in the file, not just the "metaid" attribute used by SBML&mdash;something to be aware of if your application-specific XML content inside the "annotation" subelement happens to use the XML <code>ID</code> type. Although SBML itself specifies the use of <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a> only for the "metaid" attribute, SBML-compatible applications should be careful if they use XML <code>ID</code>'s in XML portions of a model that are not defined by SBML, such as in the application-specific content of the "annotation" subelement. Finally, note that LibSBML does not provide an explicit XML <code>ID</code> data type; it uses ordinary character strings, which is easier for applications to support.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the meta-identifier of this SBML object, as a string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a24fc99c2ba9431594a78b78536699a0e" title="Predicate returning true if this object&#39;s &quot;metaid&quot; attribute is set. ">isSetMetaId()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a050779a94ecdb2d73d7edfef73bc1e55" title="Sets the value of the meta-identifier attribute of this SBML object. ">setMetaId(const std::string&amp; metaid)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a74db90e4530b215a3884f50632b95cc8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_model.html">Model</a> * SBase::getModel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_model.html" title=" An SBML model. ">Model</a> object for the SBML Document in which the current object is located. </p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_model.html" title=" An SBML model. ">Model</a> object for the SBML Document of this SBML object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a5912bd9dc06f63029b86dbda467bb3c5" title="Returns the parent SBML object containing this object. ">getParentSBMLObject()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a7e1725f1b98e08e54485ec52404d579a" title="Returns the SBMLDocument object containing this object instance. ">getSBMLDocument()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a768c53757958b705c6bdedf3d184f8b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_model_history.html">ModelHistory</a> * SBase::getModelHistory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_model_history.html" title=" MIRIAM-compliant data about a model&#39;s history. ">ModelHistory</a> object, if any, attached to this object. </p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_model_history.html" title=" MIRIAM-compliant data about a model&#39;s history. ">ModelHistory</a> object attached to this object, or <code>NULL</code> if none exist.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In SBML Level&#160;2, model history annotations were only permitted on the <a class="el" href="class_model.html" title=" An SBML model. ">Model</a> element. In SBML Level&#160;3, they are permitted on all SBML components derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a027dbf22b8bf74bbb0ce5cd4453851c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_model_history.html">ModelHistory</a> * SBase::getModelHistory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_model_history.html" title=" MIRIAM-compliant data about a model&#39;s history. ">ModelHistory</a> object, if any, attached to this object. </p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_model_history.html" title=" MIRIAM-compliant data about a model&#39;s history. ">ModelHistory</a> object attached to this object, or <code>NULL</code> if none exist.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In SBML Level&#160;2, model history annotations were only permitted on the <a class="el" href="class_model.html" title=" An SBML model. ">Model</a> element. In SBML Level&#160;3, they are permitted on all SBML components derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab24c4b22c1ac115368032d558b6fe4e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; SBase::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the "name" attribute of this SBML object. </p>
<dl class="section user"><dt></dt><dd>In SBML Level&#160;3 Version&#160;2, the "id" and "name" attributes were moved to <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> directly, instead of being defined individually for many (but not all) objects. LibSBML has for a long time provided functions defined on <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> itself to get, set, and unset those attributes, which would fail or otherwise return empty strings if executed on any object for which those attributes were not defined. Now that all <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> objects define those attributes, those functions now succeed for any object with the appropriate level and version.</dd></dl>
<p>The "name" attribute is optional and is not intended to be used for cross-referencing purposes within a model. Its purpose instead is to provide a human-readable label for the component. The data type of "name" is the type <code>string</code> defined in XML Schema. SBML imposes no restrictions as to the content of "name" attributes beyond those restrictions defined by the <code>string</code> type in XML Schema.</p>
<p>The recommended practice for handling "name" is as follows. If a software tool has the capability for displaying the content of "name" attributes, it should display this content to the user as a component's label instead of the component's "id". If the user interface does not have this capability (e.g., because it cannot display or use special characters in symbol names), or if the "name" attribute is missing on a given component, then the user interface should display the value of the "id" attribute instead. (Script language interpreters are especially likely to display "id" instead of "name".)</p>
<p>As a consequence of the above, authors of systems that automatically generate the values of "id" attributes should be aware some systems may display the "id"'s to the user. Authors therefore may wish to take some care to have their software create "id" values that are: (a) reasonably easy for humans to type and read; and (b) likely to be meaningful, for example by making the "id" attribute be an abbreviated form of the name attribute value.</p>
<p>An additional point worth mentioning is although there are restrictions on the uniqueness of "id" values, there are no restrictions on the uniqueness of "name" values in a model. This allows software applications leeway in assigning component identifiers.</p>
<p>Regardless of the level and version of the SBML, these functions allow client applications to use more generalized code in some situations (for instance, when manipulating objects that are all known to have names). If the object in question does not posess a "name" attribute according to the SBML specification for the Level and Version in use, libSBML will not allow the name to be set, nor will it read or write "name" attributes for those objects.</p>
<dl class="section return"><dt>Returns</dt><dd>the name of this SBML object, or the empty string if not set or unsettable.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#acd5e8dc937c46ace3af5125c8674c199" title="Returns the value of the &quot;id&quot; attribute of this SBML object. ">getIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a541c62b7ad823db1f14674386a61b52f" title="Predicate returning true if this object&#39;s &quot;name&quot; attribute is set. ">isSetName()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a1531f729b16689aba3fb7f3567202a7c" title="Sets the value of the &quot;name&quot; attribute of this SBML object. ">setName(const std::string&amp; sid)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a4cf8825fb83925a508eaac3d7f8fbb8c" title="Unsets the value of the &quot;name&quot; attribute of this SBML object. ">unsetName()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_layout.html#a28f69f58508832f7eaaa7fe1cc844c19">Layout</a>, <a class="el" href="class_model.html#a0ca5c897d2532f74a0e6cea0688e4529">Model</a>, <a class="el" href="class_compartment.html#a23c564b84798d310957ab91bda002c21">Compartment</a>, <a class="el" href="class_species.html#a94f601a9317fcf004bc44aae92a13cf0">Species</a>, <a class="el" href="class_event.html#aad64e22ca4a265433d552b418c9b88ee">Event</a>, <a class="el" href="class_unit_definition.html#a4621a0349d88ecc803492368347e049f">UnitDefinition</a>, <a class="el" href="class_reaction.html#a1e0582aa49268774ba6fd53c426f3126">Reaction</a>, <a class="el" href="class_parameter.html#abd7a25cf8331ced3ce45454205ccc921">Parameter</a>, <a class="el" href="class_submodel.html#ad66ed4948127e4ac4d749a1b254c4e64">Submodel</a>, <a class="el" href="class_color_definition.html#a9a3ded047bb572f775e112528b5d0075">ColorDefinition</a>, <a class="el" href="class_group.html#a2eb38e32c4bdfb997496775a1a7b5d8d">Group</a>, <a class="el" href="class_outward_binding_site.html#aeaf4491ac3de2d7906b79c0471caa6e4">OutwardBindingSite</a>, <a class="el" href="class_external_model_definition.html#ac7b8f736cd9902f626c687a01ae346db">ExternalModelDefinition</a>, <a class="el" href="class_function_definition.html#a2fd9e6c12cd706db6bef3525aa6c918f">FunctionDefinition</a>, <a class="el" href="class_flux_bound.html#a8ded3d7aaa67f07534665c960e768d4b">FluxBound</a>, <a class="el" href="class_objective.html#a925ef5870f8de0288462546ed9c032ca">Objective</a>, <a class="el" href="class_gradient_base.html#a1539dd5ed5148c4921c9a7338fa16cac">GradientBase</a>, <a class="el" href="class_deletion.html#a3132132c3b3630cad05842bd2d36697c">Deletion</a>, <a class="el" href="class_sub_list_of_species_features.html#a35ddf5e8790476bf5d60d245838d09d6">SubListOfSpeciesFeatures</a>, <a class="el" href="class_input.html#a3b254d1c8cee9609329ed2e1ac52ebd8">Input</a>, <a class="el" href="class_compartment_type.html#a3af5cc4b816a339b505f6d39d0a3eec9">CompartmentType</a>, <a class="el" href="class_render_information_base.html#abf99d346519f35c702b7c2374627fea2">RenderInformationBase</a>, <a class="el" href="class_species_type.html#a03fbbd179e53d6be0a5038e36c42c118">SpeciesType</a>, <a class="el" href="class_output.html#abf26b9e0879e9a900123c9c7dca4dcd7">Output</a>, <a class="el" href="class_transition.html#a6852f323977dae89d297c08be3d38a9f">Transition</a>, <a class="el" href="class_multi_species_type.html#afe1f5c04ea33dc44ff4bb8438b9b96e9">MultiSpeciesType</a>, <a class="el" href="class_species_feature.html#a41b01d1e3788ac13c066e1a99a8384bc">SpeciesFeature</a>, <a class="el" href="class_qualitative_species.html#a24f8b50d8962e5c15ad2f65b8a02c35e">QualitativeSpecies</a>, <a class="el" href="class_gene_product_association.html#ab26a1ffd3daae5da124ed27baeebca02">GeneProductAssociation</a>, <a class="el" href="class_port.html#aa108d83495e8e116a51eb5a41bf93a12">Port</a>, <a class="el" href="class_flux_objective.html#a6620fded02a733855668ca304e655fe8">FluxObjective</a>, <a class="el" href="class_species_feature_type.html#a0541fc1b933fedfc0f1fbc0b194c3bfd">SpeciesFeatureType</a>, <a class="el" href="class_species_type_component_map_in_product.html#afb6b078e5be9400f9e4161fb43746b65">SpeciesTypeComponentMapInProduct</a>, <a class="el" href="class_species_type_instance.html#ace48210cfd5d1f84c851460e0cb85136">SpeciesTypeInstance</a>, <a class="el" href="class_style.html#a0696359465332400b7893941ae3a6d6e">Style</a>, <a class="el" href="class_species_type_component_index.html#add19a0c7bf63efa664c02e24c9f64893">SpeciesTypeComponentIndex</a>, <a class="el" href="class_list_of_members.html#a89ac3a73d6e22b4300ec0297723c6a0d">ListOfMembers</a>, <a class="el" href="class_gene_product.html#a86de1e5d2f87f0dea512498da7540975">GeneProduct</a>, <a class="el" href="class_gene_product_ref.html#a5e8c0e086131637562052c95e31029de">GeneProductRef</a>, <a class="el" href="class_in_species_type_bond.html#ab8a4c97f80f3cdef8f9deb8be3898a77">InSpeciesTypeBond</a>, <a class="el" href="class_possible_species_feature_value.html#a46df6be1cc9977ca9fe04db8b914575f">PossibleSpeciesFeatureValue</a>, <a class="el" href="class_compartment_reference.html#a051c6deaaed3bcc578cc4e53be320a56">CompartmentReference</a>, <a class="el" href="class_transformation.html#a4d3d1f1840dc6965ec2dbe4b73cb10d9">Transformation</a>, <a class="el" href="class_simple_species_reference.html#ac6bf93e3e6a6332359f03783ad21d778">SimpleSpeciesReference</a>, and <a class="el" href="class_member.html#a85ae3046485ebee46f160a1ab3211cdf">Member</a>.</p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="set_id_from_names_8cpp-example.html#a7">setIdFromNames.cpp</a>, and <a class="el" href="set_names_from_ids_8cpp-example.html#a7">setNamesFromIds.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a8726b2382c6945adddc1f469c6758be1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> * SBase::getNamespaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of the XML Namespaces declared on the SBML document owning this object. </p>
<p>The <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> object encapsulates SBML Level/Version/namespaces information. It is used to communicate the SBML Level, Version, and (in Level&#160;3) packages used in addition to SBML Level&#160;3 Core.</p>
<dl class="section return"><dt>Returns</dt><dd>the XML Namespaces associated with this SBML object, or <code>NULL</code> in certain very usual circumstances where a namespace is not set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ae22fcf03f946d415a46e4b8e4c69076a" title="Returns the SBML Level of the SBMLDocument object containing this object. ">getLevel()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a555924b2486ab63a21fae675bdce8c5e" title="Returns the Version within the SBML Level of the SBMLDocument object containing this object...">getVersion()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_s_b_m_l_document.html#a1ac6c4481a33242c941fd51e5410986a">SBMLDocument</a>.</p>

</div>
</div>
<a class="anchor" id="ac34eff3877f512b8bf31facff83c4483"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_node.html">XMLNode</a> * SBase::getNotes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the content of the "notes" subelement of this object as a tree of <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> objects. </p>
<dl class="section user"><dt></dt><dd>The optional SBML element named "notes", present on every major SBML component type (and in SBML Level&#160;3, the "message" subelement of <a class="el" href="class_constraint.html" title=" An SBML constraint, for stating validity assumptions. ">Constraint</a>), is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</dd></dl>
<p>The format of "notes" elements conform to the definition of <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. However, the content cannot be <em>entirely</em> free-form; it must satisfy certain requirements defined in the <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specifications</a> for specific SBML Levels. To help verify the formatting of "notes" content, libSBML provides the static utility method <a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content...">SyntaxChecker::hasExpectedXHTMLSyntax()</a>; this method implements a verification process that lets callers check whether the content of a given <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> object conforms to the SBML requirements for "notes" and "message" structure. Developers are urged to consult the appropriate <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specification document</a> for the Level and Version of their model for more in-depth explanations of using "notes" in SBML. The SBML Level&#160;2 and&#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<p>The "notes" element content returned by this method will be in XML form, but libSBML does not provide an object model specifically for the content of notes. Callers will need to traverse the XML tree structure using the facilities available on <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> and related objects. For an alternative method of accessing the notes, see <a class="el" href="class_s_base.html#a6eee96ee206a55837c0d7b936f20f14d" title="Returns the content of the &quot;notes&quot; subelement of this object as a string. ">getNotesString()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the content of the "notes" subelement of this SBML object as a tree structure composed of <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> objects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a6eee96ee206a55837c0d7b936f20f14d" title="Returns the content of the &quot;notes&quot; subelement of this object as a string. ">getNotesString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#aeff0554efc75440b5375b35a4d188ea0" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content. ">isSetNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e" title="Sets the value of the &quot;notes&quot; subelement of this SBML object. ">setNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a478ad1e0e2bb2dc27a9de6ab9bac4bf2" title="Sets the value of the &quot;notes&quot; subelement of this SBML object to a copy of the string notes...">setNotes(const std::string&amp; notes, bool addXHTMLMarkup)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adb8c800163c108a27880bd644d7767ad" title="Appends the given notes to the &quot;notes&quot; subelement of this object. ">appendNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a33da5a2b0b03cbe6af69730869e35212" title="Appends the given notes to the &quot;notes&quot; subelement of this object. ">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a89f626f2593df8e83da4cdbfe79142f7" title="Unsets the value of the &quot;notes&quot; subelement of this SBML object. ">unsetNotes()</a> </dd>
<dd>
<a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content...">SyntaxChecker::hasExpectedXHTMLSyntax()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac0b7859768bced5964304957f85775b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_node.html">XMLNode</a> * SBase::getNotes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the content of the "notes" subelement of this object as a tree of <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> objects. </p>
<dl class="section user"><dt></dt><dd>The optional SBML element named "notes", present on every major SBML component type (and in SBML Level&#160;3, the "message" subelement of <a class="el" href="class_constraint.html" title=" An SBML constraint, for stating validity assumptions. ">Constraint</a>), is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</dd></dl>
<p>The format of "notes" elements conform to the definition of <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. However, the content cannot be <em>entirely</em> free-form; it must satisfy certain requirements defined in the <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specifications</a> for specific SBML Levels. To help verify the formatting of "notes" content, libSBML provides the static utility method <a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content...">SyntaxChecker::hasExpectedXHTMLSyntax()</a>; this method implements a verification process that lets callers check whether the content of a given <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> object conforms to the SBML requirements for "notes" and "message" structure. Developers are urged to consult the appropriate <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specification document</a> for the Level and Version of their model for more in-depth explanations of using "notes" in SBML. The SBML Level&#160;2 and&#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<p>The "notes" element content returned by this method will be in XML form, but libSBML does not provide an object model specifically for the content of notes. Callers will need to traverse the XML tree structure using the facilities available on <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> and related objects. For an alternative method of accessing the notes, see <a class="el" href="class_s_base.html#a6eee96ee206a55837c0d7b936f20f14d" title="Returns the content of the &quot;notes&quot; subelement of this object as a string. ">getNotesString()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the content of the "notes" subelement of this SBML object as a tree structure composed of <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> objects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a6eee96ee206a55837c0d7b936f20f14d" title="Returns the content of the &quot;notes&quot; subelement of this object as a string. ">getNotesString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#aeff0554efc75440b5375b35a4d188ea0" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content. ">isSetNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e" title="Sets the value of the &quot;notes&quot; subelement of this SBML object. ">setNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a478ad1e0e2bb2dc27a9de6ab9bac4bf2" title="Sets the value of the &quot;notes&quot; subelement of this SBML object to a copy of the string notes...">setNotes(const std::string&amp; notes, bool addXHTMLMarkup)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adb8c800163c108a27880bd644d7767ad" title="Appends the given notes to the &quot;notes&quot; subelement of this object. ">appendNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a33da5a2b0b03cbe6af69730869e35212" title="Appends the given notes to the &quot;notes&quot; subelement of this object. ">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a89f626f2593df8e83da4cdbfe79142f7" title="Unsets the value of the &quot;notes&quot; subelement of this SBML object. ">unsetNotes()</a> </dd>
<dd>
<a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content...">SyntaxChecker::hasExpectedXHTMLSyntax()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6eee96ee206a55837c0d7b936f20f14d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string SBase::getNotesString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the content of the "notes" subelement of this object as a string. </p>
<dl class="section user"><dt></dt><dd>The optional SBML element named "notes", present on every major SBML component type (and in SBML Level&#160;3, the "message" subelement of <a class="el" href="class_constraint.html" title=" An SBML constraint, for stating validity assumptions. ">Constraint</a>), is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</dd></dl>
<p>The format of "notes" elements conform to the definition of <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. However, the content cannot be <em>entirely</em> free-form; it must satisfy certain requirements defined in the <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specifications</a> for specific SBML Levels. To help verify the formatting of "notes" content, libSBML provides the static utility method <a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content...">SyntaxChecker::hasExpectedXHTMLSyntax()</a>; this method implements a verification process that lets callers check whether the content of a given <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> object conforms to the SBML requirements for "notes" and "message" structure. Developers are urged to consult the appropriate <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specification document</a> for the Level and Version of their model for more in-depth explanations of using "notes" in SBML. The SBML Level&#160;2 and&#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<p>For an alternative method of accessing the notes, see <a class="el" href="class_s_base.html#ac34eff3877f512b8bf31facff83c4483" title="Returns the content of the &quot;notes&quot; subelement of this object as a tree of XMLNode objects...">getNotes()</a>, which returns the content as an <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> tree structure. Depending on an application's needs, one or the other method may be more convenient.</p>
<dl class="section return"><dt>Returns</dt><dd>the content of the "notes" subelement of this SBML object as a string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ac34eff3877f512b8bf31facff83c4483" title="Returns the content of the &quot;notes&quot; subelement of this object as a tree of XMLNode objects...">getNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#aeff0554efc75440b5375b35a4d188ea0" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content. ">isSetNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e" title="Sets the value of the &quot;notes&quot; subelement of this SBML object. ">setNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a478ad1e0e2bb2dc27a9de6ab9bac4bf2" title="Sets the value of the &quot;notes&quot; subelement of this SBML object to a copy of the string notes...">setNotes(const std::string&amp; notes, bool addXHTMLMarkup)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adb8c800163c108a27880bd644d7767ad" title="Appends the given notes to the &quot;notes&quot; subelement of this object. ">appendNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a33da5a2b0b03cbe6af69730869e35212" title="Appends the given notes to the &quot;notes&quot; subelement of this object. ">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a89f626f2593df8e83da4cdbfe79142f7" title="Unsets the value of the &quot;notes&quot; subelement of this SBML object. ">unsetNotes()</a> </dd>
<dd>
<a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content...">SyntaxChecker::hasExpectedXHTMLSyntax()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="print_notes_8cpp-example.html#a6">printNotes.cpp</a>, and <a class="el" href="_s_b_m_l_http_resolver_example_8cpp-example.html#a19">SBMLHttpResolverExample.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a45b5ef0e49324e94ea606478a8f8714d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string SBase::getNotesString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the content of the "notes" subelement of this object as a string. </p>
<dl class="section user"><dt></dt><dd>The optional SBML element named "notes", present on every major SBML component type (and in SBML Level&#160;3, the "message" subelement of <a class="el" href="class_constraint.html" title=" An SBML constraint, for stating validity assumptions. ">Constraint</a>), is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</dd></dl>
<p>The format of "notes" elements conform to the definition of <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. However, the content cannot be <em>entirely</em> free-form; it must satisfy certain requirements defined in the <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specifications</a> for specific SBML Levels. To help verify the formatting of "notes" content, libSBML provides the static utility method <a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content...">SyntaxChecker::hasExpectedXHTMLSyntax()</a>; this method implements a verification process that lets callers check whether the content of a given <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> object conforms to the SBML requirements for "notes" and "message" structure. Developers are urged to consult the appropriate <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specification document</a> for the Level and Version of their model for more in-depth explanations of using "notes" in SBML. The SBML Level&#160;2 and&#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<p>For an alternative method of accessing the notes, see <a class="el" href="class_s_base.html#ac34eff3877f512b8bf31facff83c4483" title="Returns the content of the &quot;notes&quot; subelement of this object as a tree of XMLNode objects...">getNotes()</a>, which returns the content as an <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> tree structure. Depending on an application's needs, one or the other method may be more convenient.</p>
<dl class="section return"><dt>Returns</dt><dd>the content of the "notes" subelement of this SBML object as a string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ac34eff3877f512b8bf31facff83c4483" title="Returns the content of the &quot;notes&quot; subelement of this object as a tree of XMLNode objects...">getNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#aeff0554efc75440b5375b35a4d188ea0" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content. ">isSetNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e" title="Sets the value of the &quot;notes&quot; subelement of this SBML object. ">setNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a478ad1e0e2bb2dc27a9de6ab9bac4bf2" title="Sets the value of the &quot;notes&quot; subelement of this SBML object to a copy of the string notes...">setNotes(const std::string&amp; notes, bool addXHTMLMarkup)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adb8c800163c108a27880bd644d7767ad" title="Appends the given notes to the &quot;notes&quot; subelement of this object. ">appendNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a33da5a2b0b03cbe6af69730869e35212" title="Appends the given notes to the &quot;notes&quot; subelement of this object. ">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a89f626f2593df8e83da4cdbfe79142f7" title="Unsets the value of the &quot;notes&quot; subelement of this SBML object. ">unsetNotes()</a> </dd>
<dd>
<a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content...">SyntaxChecker::hasExpectedXHTMLSyntax()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a33b34686c3620ef45eecdc41b2b7f1f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SBase::getNumCVTerms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of <a class="el" href="class_c_v_term.html" title=" A MIRIAM-compliant controlled vocabulary term. ">CVTerm</a> objects in the annotations of this SBML object. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of CVTerms for this SBML object. </dd></dl>

</div>
</div>
<a class="anchor" id="a68708993ac87a7fee20fe46fea06a851"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SBase::getNumDisabledPlugins </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of disabled plug-in objects (extension interfaces) for SBML Level&#160;3 package extensions known. </p>
<dl class="section user"><dt></dt><dd>SBML Level&#160;3 consists of a <em>Core</em> definition that can be extended via optional SBML Level&#160;3 <em>packages</em>. A given model may indicate that it uses one or more SBML packages, and likewise, a software tool may be able to support one or more packages. LibSBML does not come preconfigured with all possible packages included and enabled, in part because not all package specifications have been finalized. To support the ability for software systems to enable support for the Level&#160;3 packages they choose, libSBML features a <em>plug-in</em> mechanism. Each SBML Level&#160;3 package is implemented in a separate code plug-in that can be enabled by the application to support working with that SBML package. A given SBML model may thus contain not only objects defined by SBML Level&#160;3 Core, but also objects created by libSBML plug-ins supporting additional Level&#160;3 packages.</dd></dl>
<dl class="section user"><dt></dt><dd>If a plugin is <em>disabled</em>, the package information it contains is no longer considered to be part of the SBML document for the purposes of searching the document or writing out the document. However, the information is still retained, so if the plugin is enabled again, the same information will once again be available, and will be written out to the final model.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of disabled plug-in objects (extension interfaces) of package extensions known by this instance of libSBML. </dd></dl>

</div>
</div>
<a class="anchor" id="a78ec0d431ea99929055baebf1d97e421"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SBase::getNumPlugins </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of plug-in objects (extenstion interfaces) for SBML Level&#160;3 package extensions known. </p>
<dl class="section user"><dt></dt><dd>SBML Level&#160;3 consists of a <em>Core</em> definition that can be extended via optional SBML Level&#160;3 <em>packages</em>. A given model may indicate that it uses one or more SBML packages, and likewise, a software tool may be able to support one or more packages. LibSBML does not come preconfigured with all possible packages included and enabled, in part because not all package specifications have been finalized. To support the ability for software systems to enable support for the Level&#160;3 packages they choose, libSBML features a <em>plug-in</em> mechanism. Each SBML Level&#160;3 package is implemented in a separate code plug-in that can be enabled by the application to support working with that SBML package. A given SBML model may thus contain not only objects defined by SBML Level&#160;3 Core, but also objects created by libSBML plug-ins supporting additional Level&#160;3 packages.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of plug-in objects (extension interfaces) of package extensions known by this instance of libSBML.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a2bcd32c8ab7537433f7f7851818c60ed" title="Returns the nth plug-in object (extension interface) for an SBML Level&#160;3 package extension. ">getPlugin(unsigned int n)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa729b3e8fa153e4235f0407c40e32167"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SBase::getPackageCoreVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the SBML Core Version within the SBML Level of the actual object. </p>
<dl class="section user"><dt></dt><dd>LibSBML uses the class <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> as a top-level container for storing SBML content and data associated with it (such as warnings and error messages). An SBML model in libSBML is contained inside an <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> object. <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> corresponds roughly to the class <em>SBML</em> defined in the SBML Level&#160;3 and Level&#160;2 specifications, but it does not have a direct correspondence in SBML Level&#160;1. (But, it is created by libSBML no matter whether the model is Level&#160;1, Level&#160;2 or Level&#160;3.)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the SBML core version of this SBML object. </dd></dl>

</div>
</div>
<a class="anchor" id="a2fba4f047b5e009a42081bd685d4eb16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; SBase::getPackageName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the SBML Level&#160;3 package in which this element is defined. </p>
<dl class="section return"><dt>Returns</dt><dd>the name of the SBML package in which this element is defined. The string <code>&quot;core&quot;</code> will be returned if this element is defined in SBML Level&#160;3 Core. The string <code>&quot;unknown&quot;</code> will be returned if this element is not defined in any SBML package. </dd></dl>

</div>
</div>
<a class="anchor" id="aa831f09f33c10055a222cd1900c99bf8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SBase::getPackageVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Version of the SBML Level&#160;3 package to which this element belongs to. </p>
<dl class="section return"><dt>Returns</dt><dd>the version of the SBML Level&#160;3 package to which this element belongs. The value <code>0</code> will be returned if this element belongs to the SBML Level&#160;3 Core package.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ae22fcf03f946d415a46e4b8e4c69076a" title="Returns the SBML Level of the SBMLDocument object containing this object. ">getLevel()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a555924b2486ab63a21fae675bdce8c5e" title="Returns the Version within the SBML Level of the SBMLDocument object containing this object...">getVersion()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5912bd9dc06f63029b86dbda467bb3c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_base.html">SBase</a> * SBase::getParentSBMLObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the parent SBML object containing this object. </p>
<p>This returns the immediately-containing object. This method is convenient when holding an object nested inside other objects in an SBML model.</p>
<dl class="section return"><dt>Returns</dt><dd>the parent SBML object of this SBML object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a7e1725f1b98e08e54485ec52404d579a" title="Returns the SBMLDocument object containing this object instance. ">getSBMLDocument()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a74db90e4530b215a3884f50632b95cc8" title="Returns the Model object for the SBML Document in which the current object is located. ">getModel()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af65de47c82fbb90a0e27377c6164f8f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_base.html">SBase</a> * SBase::getParentSBMLObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the parent SBML object containing this object. </p>
<p>This returns the immediately-containing object. This method is convenient when holding an object nested inside other objects in an SBML model.</p>
<dl class="section return"><dt>Returns</dt><dd>the parent SBML object of this SBML object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a7e1725f1b98e08e54485ec52404d579a" title="Returns the SBMLDocument object containing this object instance. ">getSBMLDocument()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a74db90e4530b215a3884f50632b95cc8" title="Returns the Model object for the SBML Document in which the current object is located. ">getModel()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aee8d8b8cb1ae5980d228174073fc5abc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_base_plugin.html">SBasePlugin</a> * SBase::getPlugin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>package</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given package name or URI. </p>
<p>The returned plug-in will be the appropriate type of plugin requested: calling <a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">Model::getPlugin</a>("fbc") will return an <a class="el" href="class_fbc_model_plugin.html" title=" Extension of Model. ">FbcModelPlugin</a>; calling <a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">Parameter::getPlugin</a>("comp") will return <a class="el" href="class_comp_s_base_plugin.html" title=" Extension of SBase. ">CompSBasePlugin</a>, etc.</p>
<p>If no such plugin exists, NULL is returned.</p>
<dl class="section user"><dt></dt><dd>SBML Level&#160;3 consists of a <em>Core</em> definition that can be extended via optional SBML Level&#160;3 <em>packages</em>. A given model may indicate that it uses one or more SBML packages, and likewise, a software tool may be able to support one or more packages. LibSBML does not come preconfigured with all possible packages included and enabled, in part because not all package specifications have been finalized. To support the ability for software systems to enable support for the Level&#160;3 packages they choose, libSBML features a <em>plug-in</em> mechanism. Each SBML Level&#160;3 package is implemented in a separate code plug-in that can be enabled by the application to support working with that SBML package. A given SBML model may thus contain not only objects defined by SBML Level&#160;3 Core, but also objects created by libSBML plug-ins supporting additional Level&#160;3 packages.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">package</td><td>the name or URI of the package.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the plug-in object (the libSBML extension interface) of a package extension with the given package name or URI.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a2bcd32c8ab7537433f7f7851818c60ed" title="Returns the nth plug-in object (extension interface) for an SBML Level&#160;3 package extension. ">getPlugin(unsigned int n)</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="add_layout_8cpp-example.html#a12">addLayout.cpp</a>, <a class="el" href="convert_layout_8cpp-example.html#a18">convertLayout.cpp</a>, <a class="el" href="example1-_l3_8cpp-example.html#a34">example1-L3.cpp</a>, <a class="el" href="example1_8cpp-example.html#a29">example1.cpp</a>, <a class="el" href="example2-_l3_8cpp-example.html#a35">example2-L3.cpp</a>, <a class="el" href="example2_8cpp-example.html#a30">example2.cpp</a>, <a class="el" href="example3-_l3_8cpp-example.html#a9">example3-L3.cpp</a>, <a class="el" href="example3_8cpp-example.html#a11">example3.cpp</a>, <a class="el" href="fbc_example1_8cpp-example.html#a30">fbc_example1.cpp</a>, <a class="el" href="groups_example1_8cpp-example.html#a19">groups_example1.cpp</a>, <a class="el" href="groups_example2_8cpp-example.html#a34">groups_example2.cpp</a>, <a class="el" href="qual_example1_8cpp-example.html#a11">qual_example1.cpp</a>, <a class="el" href="_s_b_m_l_http_resolver_example_8cpp-example.html#a10">SBMLHttpResolverExample.cpp</a>, <a class="el" href="spec_example1_8cpp-example.html#a6">spec_example1.cpp</a>, <a class="el" href="spec_example2_8cpp-example.html#a6">spec_example2.cpp</a>, <a class="el" href="spec_example3_8cpp-example.html#a6">spec_example3.cpp</a>, and <a class="el" href="spec_example4_8cpp-example.html#a6">spec_example4.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a70b37e0ac6f9c6359fcad8bbe1d3a942"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_base_plugin.html">SBasePlugin</a> * SBase::getPlugin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>package</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given package name or URI. </p>
<p>The returned plug-in will be the appropriate type of plugin requested: calling <a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">Model::getPlugin</a>("fbc") will return an <a class="el" href="class_fbc_model_plugin.html" title=" Extension of Model. ">FbcModelPlugin</a>; calling <a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">Parameter::getPlugin</a>("comp") will return <a class="el" href="class_comp_s_base_plugin.html" title=" Extension of SBase. ">CompSBasePlugin</a>, etc.</p>
<p>If no such plugin exists, NULL is returned.</p>
<dl class="section user"><dt></dt><dd>SBML Level&#160;3 consists of a <em>Core</em> definition that can be extended via optional SBML Level&#160;3 <em>packages</em>. A given model may indicate that it uses one or more SBML packages, and likewise, a software tool may be able to support one or more packages. LibSBML does not come preconfigured with all possible packages included and enabled, in part because not all package specifications have been finalized. To support the ability for software systems to enable support for the Level&#160;3 packages they choose, libSBML features a <em>plug-in</em> mechanism. Each SBML Level&#160;3 package is implemented in a separate code plug-in that can be enabled by the application to support working with that SBML package. A given SBML model may thus contain not only objects defined by SBML Level&#160;3 Core, but also objects created by libSBML plug-ins supporting additional Level&#160;3 packages.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">package</td><td>the name or URI of the package.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the plug-in object (the libSBML extension interface) of a package extension with the given package name or URI.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a2bcd32c8ab7537433f7f7851818c60ed" title="Returns the nth plug-in object (extension interface) for an SBML Level&#160;3 package extension. ">getPlugin(unsigned int n)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2bcd32c8ab7537433f7f7851818c60ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_base_plugin.html">SBasePlugin</a> * SBase::getPlugin </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the nth plug-in object (extension interface) for an SBML Level&#160;3 package extension. </p>
<p>The returned plug-in will be the appropriate type of plugin requested: calling <a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">Model::getPlugin</a>("fbc") will return an <a class="el" href="class_fbc_model_plugin.html" title=" Extension of Model. ">FbcModelPlugin</a>; calling <a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">Parameter::getPlugin</a>("comp") will return <a class="el" href="class_comp_s_base_plugin.html" title=" Extension of SBase. ">CompSBasePlugin</a>, etc.</p>
<p>If no such plugin exists, NULL is returned.</p>
<dl class="section user"><dt></dt><dd>SBML Level&#160;3 consists of a <em>Core</em> definition that can be extended via optional SBML Level&#160;3 <em>packages</em>. A given model may indicate that it uses one or more SBML packages, and likewise, a software tool may be able to support one or more packages. LibSBML does not come preconfigured with all possible packages included and enabled, in part because not all package specifications have been finalized. To support the ability for software systems to enable support for the Level&#160;3 packages they choose, libSBML features a <em>plug-in</em> mechanism. Each SBML Level&#160;3 package is implemented in a separate code plug-in that can be enabled by the application to support working with that SBML package. A given SBML model may thus contain not only objects defined by SBML Level&#160;3 Core, but also objects created by libSBML plug-ins supporting additional Level&#160;3 packages.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the plug-in to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth plug-in object (the libSBML extension interface) of a package extension. If the index <code>n</code> is invalid, <code>NULL</code> is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a78ec0d431ea99929055baebf1d97e421" title="Returns the number of plug-in objects (extenstion interfaces) for SBML Level&#160;3 package extensions kno...">getNumPlugins()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">getPlugin(const std::string&amp; package)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a70be7c5915bea4bdb76993dafaeb3824"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_base_plugin.html">SBasePlugin</a> * SBase::getPlugin </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the nth plug-in object (extension interface) for an SBML Level&#160;3 package extension. </p>
<p>The returned plug-in will be the appropriate type of plugin requested: calling <a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">Model::getPlugin</a>("fbc") will return an <a class="el" href="class_fbc_model_plugin.html" title=" Extension of Model. ">FbcModelPlugin</a>; calling <a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">Parameter::getPlugin</a>("comp") will return <a class="el" href="class_comp_s_base_plugin.html" title=" Extension of SBase. ">CompSBasePlugin</a>, etc.</p>
<p>If no such plugin exists, NULL is returned.</p>
<dl class="section user"><dt></dt><dd>SBML Level&#160;3 consists of a <em>Core</em> definition that can be extended via optional SBML Level&#160;3 <em>packages</em>. A given model may indicate that it uses one or more SBML packages, and likewise, a software tool may be able to support one or more packages. LibSBML does not come preconfigured with all possible packages included and enabled, in part because not all package specifications have been finalized. To support the ability for software systems to enable support for the Level&#160;3 packages they choose, libSBML features a <em>plug-in</em> mechanism. Each SBML Level&#160;3 package is implemented in a separate code plug-in that can be enabled by the application to support working with that SBML package. A given SBML model may thus contain not only objects defined by SBML Level&#160;3 Core, but also objects created by libSBML plug-ins supporting additional Level&#160;3 packages.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the plug-in to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nth plug-in object (the libSBML extension interface) of a package extension. If the index <code>n</code> is invalid, <code>NULL</code> is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a78ec0d431ea99929055baebf1d97e421" title="Returns the number of plug-in objects (extenstion interfaces) for SBML Level&#160;3 package extensions kno...">getNumPlugins()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#aee8d8b8cb1ae5980d228174073fc5abc" title="Returns a plug-in object (extension interface) for an SBML Level&#160;3 package extension with the given p...">getPlugin(const std::string&amp; package)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a404fd41294b3f5fb84f4f4215755abb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string SBase::getPrefix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the XML namespace prefix of this element. </p>
<p>This reports the XML namespace prefix chosen for this class of object in the current SBML document. This may be an empty string if the component has no explicit prefix (for instance, if it is a core SBML object placed in the default SBML namespace of the document). If it is not empty, then it corresponds to the XML namespace prefix used set the object, whatever that may be in a given SBML document.</p>
<dl class="section return"><dt>Returns</dt><dd>a text string representing the XML namespace prefix. </dd></dl>

</div>
</div>
<a class="anchor" id="ac6ebee0bc9c56fe3444b8f230eddc129"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_c_v_term_8h.html#a7dbfb6956b3be9e61e65509cb2052f18">BiolQualifierType_t</a> SBase::getResourceBiologicalQualifier </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>resource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the MIRIAM <em>biological qualifier</em> associated with the given resource. </p>
<p>In <a href="http://biomodels.net/miriam" target="_blank">MIRIAM</a>, qualifiers are an optional means of indicating the relationship between a model component and its annotations. There are two broad kinds of annotations: <em>model</em> and <em>biological</em>. The latter kind is used to qualify the relationship between a model component and a biological entity which it represents. Examples of relationships include "is" and "has part", but many others are possible. MIRIAM defines <a href="http://www.ebi.ac.uk/miriam/main/qualifiers/" target="_blank">numerous relationship qualifiers</a> to enable different software tools to qualify biological annotations in the same standardized way. In libSBML, the MIRIAM controlled-vocabulary annotations on an SBML model element are represented using lists of <a class="el" href="class_c_v_term.html" title=" A MIRIAM-compliant controlled vocabulary term. ">CVTerm</a> objects, and the the MIRIAM biological qualifiers are represented using values from the enumeration type <a class="el" href="_c_v_term_8h.html#a7dbfb6956b3be9e61e65509cb2052f18" title="Enumeration of possible biological qualifiers used for annotations. ">BiolQualifierType_t</a>.</p>
<p>This method searches the controlled-vocabulary annotations (i.e., the list of <a class="el" href="class_c_v_term.html" title=" A MIRIAM-compliant controlled vocabulary term. ">CVTerm</a> objects) on the present object, then out of those that have biological qualifiers, looks for an annotation to the given <code>resource</code>. If such an annotation is found, it returns the type of biological qualifier associated with that resource as a value from the enumeration type <a class="el" href="_c_v_term_8h.html#a7dbfb6956b3be9e61e65509cb2052f18" title="Enumeration of possible biological qualifiers used for annotations. ">BiolQualifierType_t</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resource</td><td>string representing the resource; e.g., <code>"http://www.geneontology.org/#GO:0005892"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the qualifier associated with the resource, or <a class="el" href="_c_v_term_8h.html#a7dbfb6956b3be9e61e65509cb2052f18af1cf563d5624cd63df7777702421046b">BQB_UNKNOWN</a> if the resource does not exist.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The set of MIRIAM biological qualifiers grows over time, although relatively slowly. The values in the enumeration <a class="el" href="_c_v_term_8h.html#a7dbfb6956b3be9e61e65509cb2052f18" title="Enumeration of possible biological qualifiers used for annotations. ">BiolQualifierType_t</a> are up to date with MIRIAM at the time of a given libSBML release. The set of values may be expanded in later libSBML releases, to match the values defined by MIRIAM at that later time. </dd></dl>

</div>
</div>
<a class="anchor" id="af67710b870844b0465b0c5b9e43c6ed4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_c_v_term_8h.html#a969edcb49472d95685722a541f391d9d">ModelQualifierType_t</a> SBase::getResourceModelQualifier </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>resource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the MIRIAM <em>model qualifier</em> associated with the given resource. </p>
<p>In <a href="http://biomodels.net/miriam" target="_blank">MIRIAM</a>, qualifiers are an optional means of indicating the relationship between a model component and its annotations. There are two broad kinds of annotations: <em>model</em> and <em>biological</em>. The former kind is used to qualify the relationship between a model component and another modeling object. An example qualifier is "isDerivedFrom", to indicate that a given component of the model is derived from the modeling object represented by the referenced resource. MIRIAM defines <a href="http://www.ebi.ac.uk/miriam/main/qualifiers/" target="_blank">numerous relationship qualifiers</a> to enable different software tools to qualify model annotations in the same standardized way. In libSBML, the MIRIAM controlled-vocabulary annotations on an SBML model element are represented using lists of <a class="el" href="class_c_v_term.html" title=" A MIRIAM-compliant controlled vocabulary term. ">CVTerm</a> objects, and the the MIRIAM model qualifiers are represented using values from the enumeration type <a class="el" href="_c_v_term_8h.html#a969edcb49472d95685722a541f391d9d" title="Enumeration of possible model qualifiers used for annotations. ">ModelQualifierType_t</a>.</p>
<p>This method method searches the controlled-vocabulary annotations (i.e., the list of <a class="el" href="class_c_v_term.html" title=" A MIRIAM-compliant controlled vocabulary term. ">CVTerm</a> objects) on the present object, then out of those that have model qualifiers, looks for an annotation to the given <code>resource</code>. If such an annotation is found, it returns the type of type of model qualifier associated with that resource as a value from the enumeration type <a class="el" href="_c_v_term_8h.html#a969edcb49472d95685722a541f391d9d" title="Enumeration of possible model qualifiers used for annotations. ">ModelQualifierType_t</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resource</td><td>string representing the resource; e.g., <code>"http://www.geneontology.org/#GO:0005892"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="_c_v_term_8h.html#a969edcb49472d95685722a541f391d9d" title="Enumeration of possible model qualifiers used for annotations. ">ModelQualifierType_t</a> value associated with the resource, or <a class="el" href="_c_v_term_8h.html#a969edcb49472d95685722a541f391d9da8b1e2ab645e23a7f1c5dfde0b85e1b25">BQM_UNKNOWN</a> if the resource does not exist.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The set of MIRIAM biological qualifiers grows over time, although relatively slowly. The values in the enumeration <a class="el" href="_c_v_term_8h.html#a969edcb49472d95685722a541f391d9d" title="Enumeration of possible model qualifiers used for annotations. ">ModelQualifierType_t</a> are up to date with MIRIAM at the time of a given libSBML release. The set of values may be expanded in later libSBML releases, to match the values defined by MIRIAM at that later time. </dd></dl>

</div>
</div>
<a class="anchor" id="ab649bfd5586aec788536a5cd77ae963f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> * SBase::getSBMLDocument </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> object containing this object instance. </p>
<dl class="section user"><dt></dt><dd>LibSBML uses the class <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> as a top-level container for storing SBML content and data associated with it (such as warnings and error messages). An SBML model in libSBML is contained inside an <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> object. <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> corresponds roughly to the class <em>SBML</em> defined in the SBML Level&#160;3 and Level&#160;2 specifications, but it does not have a direct correspondence in SBML Level&#160;1. (But, it is created by libSBML no matter whether the model is Level&#160;1, Level&#160;2 or Level&#160;3.)</dd></dl>
<p>This method allows the caller to obtain the <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> for the current object.</p>
<dl class="section return"><dt>Returns</dt><dd>the parent <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> object of this SBML object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a5912bd9dc06f63029b86dbda467bb3c5" title="Returns the parent SBML object containing this object. ">getParentSBMLObject()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a74db90e4530b215a3884f50632b95cc8" title="Returns the Model object for the SBML Document in which the current object is located. ">getModel()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7e1725f1b98e08e54485ec52404d579a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_b_m_l_document.html">SBMLDocument</a> * SBase::getSBMLDocument </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> object containing this object instance. </p>
<dl class="section user"><dt></dt><dd>LibSBML uses the class <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> as a top-level container for storing SBML content and data associated with it (such as warnings and error messages). An SBML model in libSBML is contained inside an <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> object. <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> corresponds roughly to the class <em>SBML</em> defined in the SBML Level&#160;3 and Level&#160;2 specifications, but it does not have a direct correspondence in SBML Level&#160;1. (But, it is created by libSBML no matter whether the model is Level&#160;1, Level&#160;2 or Level&#160;3.)</dd></dl>
<p>This method allows the caller to obtain the <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> for the current object.</p>
<dl class="section return"><dt>Returns</dt><dd>the parent <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> object of this SBML object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a5912bd9dc06f63029b86dbda467bb3c5" title="Returns the parent SBML object containing this object. ">getParentSBMLObject()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a74db90e4530b215a3884f50632b95cc8" title="Returns the Model object for the SBML Document in which the current object is located. ">getModel()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af001f8160ee38a0b39bd69dc364dac8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::getSBOTerm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the integer portion of the value of the "sboTerm" attribute of this object. </p>
<dl class="section user"><dt></dt><dd>Beginning with SBML Level 2 Version 2, objects derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> have an optional attribute named "sboTerm" for supporting the use of the Systems Biology Ontology. In SBML proper, the data type of the attribute is a string of the form "SBO:NNNNNNN", where "NNNNNNN" is a seven digit integer number; libSBML simplifies the representation by only storing the "NNNNNNN" integer portion. Thus, in libSBML, the "sboTerm" attribute on <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> has data type <code>int</code>, and <a class="el" href="class_s_b_o.html" title=" Facilities for using the Systems Biology Ontology. ">SBO</a> identifiers are stored simply as integers. </dd></dl>
<dl class="section user"><dt></dt><dd><a class="el" href="class_s_b_o.html" title=" Facilities for using the Systems Biology Ontology. ">SBO</a> terms are a type of optional annotation, and each different class of SBML object derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> imposes its own requirements about the values permitted for "sboTerm". More details can be found in SBML specifications for Level&#160;2 Version&#160;2 and above.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the "sboTerm" attribute as an integer, or <code>-1</code> if the value is not set. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="print_s_b_m_l_8cpp-example.html#a12">printSBML.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af0eae047c6c4ddc8d17e4d3369da7b57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string SBase::getSBOTermAsURL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the URL representation of the "sboTerm" attribute of this object. </p>
<p>This method returns the entire <a class="el" href="class_s_b_o.html" title=" Facilities for using the Systems Biology Ontology. ">SBO</a> identifier as a text string in the form <code style="margin-right:0; padding-right:0">http</code><code style="margin-left:0; padding-left:0">://identifiers.org/biomodels.sbo/SBO:NNNNNNN"</code>.</p>
<dl class="section user"><dt></dt><dd><a class="el" href="class_s_b_o.html" title=" Facilities for using the Systems Biology Ontology. ">SBO</a> terms are a type of optional annotation, and each different class of SBML object derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> imposes its own requirements about the values permitted for "sboTerm". More details can be found in SBML specifications for Level&#160;2 Version&#160;2 and above.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the "sboTerm" attribute as an identifiers.org URL, or an empty string if the value is not set. </dd></dl>

</div>
</div>
<a class="anchor" id="a7abcd5c8b17994422c21cc1b291cf9d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string SBase::getSBOTermID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of the "sboTerm" attribute of this object. </p>
<dl class="section user"><dt></dt><dd>Beginning with SBML Level 2 Version 2, objects derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> have an optional attribute named "sboTerm" for supporting the use of the Systems Biology Ontology. In SBML proper, the data type of the attribute is a string of the form "SBO:NNNNNNN", where "NNNNNNN" is a seven digit integer number; libSBML simplifies the representation by only storing the "NNNNNNN" integer portion. Thus, in libSBML, the "sboTerm" attribute on <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> has data type <code>int</code>, and <a class="el" href="class_s_b_o.html" title=" Facilities for using the Systems Biology Ontology. ">SBO</a> identifiers are stored simply as integers. </dd></dl>
<dl class="section user"><dt></dt><dd><a class="el" href="class_s_b_o.html" title=" Facilities for using the Systems Biology Ontology. ">SBO</a> terms are a type of optional annotation, and each different class of SBML object derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> imposes its own requirements about the values permitted for "sboTerm". More details can be found in SBML specifications for Level&#160;2 Version&#160;2 and above.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the "sboTerm" attribute as a string (its value will be of the form "SBO:NNNNNNN"), or an empty string if the value is not set. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e5a245e34bc27da4818558796dc6654"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_rule_8h.html#ad5d6b2dda840b827f5c4857296c739a7">RuleType_t</a> Rule::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a code representing the type of rule this is. </p>
<dl class="section return"><dt>Returns</dt><dd>the rule type, which will be one of the following three possible values: <ul>
<li><a class="el" href="_rule_8h.html#ad5d6b2dda840b827f5c4857296c739a7ae4b2aaaecdabc4d50eadea4e61b09f2d">RULE_TYPE_RATE</a> </li>
<li><a class="el" href="_rule_8h.html#ad5d6b2dda840b827f5c4857296c739a7a23d32c5ba722ac969aa49899aedad2e4">RULE_TYPE_SCALAR</a> </li>
<li><a class="el" href="_rule_8h.html#ad5d6b2dda840b827f5c4857296c739a7ad703ec8a3f92b80ae3f118cc96086a35">RULE_TYPE_INVALID</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The attribute "type" on <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> objects is present only in SBML Level&#160;1. In SBML Level&#160;2 and later, the type has been replaced by subclassing the <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> object. </dd></dl>

</div>
</div>
<a class="anchor" id="a88c7637ff4280635853fe59489fcbcc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Rule::getTypeCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the libSBML type code for this SBML object. </p>
<dl class="section user"><dt></dt><dd>LibSBML attaches an identifying code to every kind of SBML object. These are integer constants known as <em>SBML type codes</em>. The names of all the codes begin with the characters <code>SBML_</code>. The set of possible type codes for core elements is defined in the enumeration <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfe" title="The enumeration of possible SBML core object types. ">SBMLTypeCode_t</a>, and in addition, libSBML plug-ins for SBML Level&#160;3 packages define their own extra enumerations of type codes (e.g., <a class="el" href="_layout_extension_8h.html#a6b80c825e1507341de5540b8e7de003d" title="SBMLFbcTypeCode_t Enumeration of possible types in the libSBML layout package implementation...">SBMLLayoutTypeCode_t</a> for the Level&#160;3 <a class="el" href="class_layout.html" title=" The layout of a diagram of an SBML model. ">Layout</a> package). Note that different Level&#160;3 package plug-ins may use overlapping type codes; to identify the package to which a given object belongs, call the <code><a class="el" href="class_s_base.html#a2fba4f047b5e009a42081bd685d4eb16" title="Returns the name of the SBML Level&#160;3 package in which this element is defined. ">SBase::getPackageName()</a> </code> method on the object.</dd></dl>
<p>The exception to this is lists: all SBML-style list elements have the type <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfeaa111b52def73380487c84f062f47dadc">SBML_LIST_OF</a>, regardless of what package they are from.</p>
<dl class="section return"><dt>Returns</dt><dd>the SBML type code for this object, either <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfeaeb87df9f7e9efbabd7e92403ea4e1914">SBML_ASSIGNMENT_RULE</a>, <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfea8577e7f4bc6d014398fd8c0d75859427">SBML_RATE_RULE</a>, or <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfeab2d405a60c7a2a93ab2604858f1f3e1e">SBML_ALGEBRAIC_RULE</a> for SBML Core.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><span class="warning">The specific integer values of the possible type codes may be reused by different libSBML plug-ins for SBML Level&#160;3. packages, To fully identify the correct code, <b>it is necessary to invoke both <a class="el" href="class_s_base.html#a2fba4f047b5e009a42081bd685d4eb16" title="Returns the name of the SBML Level&#160;3 package in which this element is defined. ">getPackageName()</a> and <a class="el" href="class_rule.html#a88c7637ff4280635853fe59489fcbcc9" title="Returns the libSBML type code for this SBML object. ">getTypeCode()</a></b> (or <a class="el" href="class_list_of.html#aa977968da3458cc6e1cff3b04ee21b02" title="Get the type code of the objects contained in this ListOf. ">ListOf::getItemTypeCode()</a>).</span></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_rule.html#a92a86ec04e9fee983005cf7b24d9f1a3" title="Returns the XML element name of this object. ">getElementName()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a2fba4f047b5e009a42081bd685d4eb16" title="Returns the name of the SBML Level&#160;3 package in which this element is defined. ">getPackageName()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#ab25bdba15506fecd7eff3def4fa64d95">SBase</a>.</p>

</div>
</div>
<a class="anchor" id="ac65c881cf77ae692c4d7cc6a98e474f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; Rule::getUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the units for the mathematical formula of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the identifier of the units for the expression of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The attribute "units" exists on SBML Level&#160;1 ParameterRule objects only. It is not present in SBML Levels&#160;2 and&#160;3. </dd></dl>

</div>
</div>
<a class="anchor" id="ae616f1910aa4764813c10347e0e776fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string SBase::getURI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the namespace URI to which this element belongs to. </p>
<p>For example, all elements that belong to SBML Level&#160;3 Version&#160;1 Core must would have the URI <code>"http://www.sbml.org/sbml/level3/version1/core"</code>; all elements that belong to <a class="el" href="class_layout.html" title=" The layout of a diagram of an SBML model. ">Layout</a> Extension Version 1 for SBML Level&#160;3 Version&#160;1 Core must would have the URI <code>"http://www.sbml.org/sbml/level3/version1/layout/version1"</code>.</p>
<p>This function first returns the URI for this element by looking into the <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> object of the document with the its package name. If not found, it will then look for the namespace associated with the element itself.</p>
<dl class="section return"><dt>Returns</dt><dd>the URI of this element, as a text string.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a7e1725f1b98e08e54485ec52404d579a" title="Returns the SBMLDocument object containing this object instance. ">getSBMLDocument()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a2fba4f047b5e009a42081bd685d4eb16" title="Returns the name of the SBML Level&#160;3 package in which this element is defined. ">getPackageName()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2cf88daa030d52a6a9494f9277e91cc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * SBase::getUserData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the user data that has been previously set via <a class="el" href="class_s_base.html#ac3b1bbfe22bad0dbc577b61c529f37bb" title="Sets the user data of this element. ">setUserData()</a>. </p>
<dl class="section user"><dt></dt><dd>The user data associated with an SBML object can be used by an application developer to attach custom information to that object in the model. In case of a deep copy, this attribute will passed as it is. The attribute will never be interpreted by libSBML.</dd></dl>
<dl class="section user"><dt></dt><dd>The user data associated with an SBML object can be used by an application developer to attach custom information to that object in the model. In case of a deep copy, this data will passed as-is. The data attribute will never be interpreted by libSBML.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the user data of this node, or <code>NULL</code> if no user data has been set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_a_s_t_node.html#adae163e5a31a74d62c665db0b9704220" title="Sets the user data of this node. ">ASTNode::setUserData(void *userData)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a21b6103384ba971fb7b1d85584566c7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; Rule::getVariable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of the "variable" attribute of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> object. </p>
<dl class="section user"><dt></dt><dd>In SBML Level&#160;1, the different rule types each have a different name for the attribute holding the reference to the object constituting the left-hand side of the rule. (E.g., for SBML Level&#160;1's SpeciesConcentrationRule the attribute is "species", for CompartmentVolumeRule it is "compartment", etc.) In SBML Levels&#160;2 and&#160;3, the only two types of <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> objects with a left-hand side object reference are <a class="el" href="class_assignment_rule.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule</a> and <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a>, and both of them use the same name for attribute: "variable". In order to make it easier for application developers to work with all Levels of SBML, libSBML uses a uniform name for all such attributes, and it is "variable", regardless of whether Level&#160;1 rules or Level&#160;2&ndash;3 rules are being used.</dd></dl>
<p>The "variable" attribute of a <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> indicates the element which the results of the "math" are to be applied. An <a class="el" href="class_algebraic_rule.html" title=" An SBML algebraic rule representing 0 = f(W). ">AlgebraicRule</a> has no "variable", and will always return an empty string.</p>
<dl class="section return"><dt>Returns</dt><dd>the identifier string stored as the "variable" attribute value in this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>, or <code>NULL</code> if this object is an <a class="el" href="class_algebraic_rule.html" title=" An SBML algebraic rule representing 0 = f(W). ">AlgebraicRule</a> object, or if the attribute is unset. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="print_math_8cpp-example.html#a13">printMath.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a555924b2486ab63a21fae675bdce8c5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SBase::getVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Version within the SBML Level of the <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> object containing <em>this</em> object. </p>
<dl class="section user"><dt></dt><dd>LibSBML uses the class <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> as a top-level container for storing SBML content and data associated with it (such as warnings and error messages). An SBML model in libSBML is contained inside an <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> object. <a class="el" href="class_s_b_m_l_document.html" title=" Overall SBML container object. ">SBMLDocument</a> corresponds roughly to the class <em>SBML</em> defined in the SBML Level&#160;3 and Level&#160;2 specifications, but it does not have a direct correspondence in SBML Level&#160;1. (But, it is created by libSBML no matter whether the model is Level&#160;1, Level&#160;2 or Level&#160;3.)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the SBML version of this SBML object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ae22fcf03f946d415a46e4b8e4c69076a" title="Returns the SBML Level of the SBMLDocument object containing this object. ">getLevel()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a8726b2382c6945adddc1f469c6758be1" title="Returns a list of the XML Namespaces declared on the SBML document owning this object. ">getNamespaces()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="add_layout_8cpp-example.html#a14">addLayout.cpp</a>, <a class="el" href="convert_s_b_m_l_8cpp-example.html#a8">convertSBML.cpp</a>, and <a class="el" href="print_s_b_m_l_8cpp-example.html#a6">printSBML.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6aaf5962c6268adb1ebfcc95b18a59fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RateRule::hasRequiredAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if all the required attributes for this <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> object have been set. </p>
<p>In SBML Levels&#160;2&ndash;3, the only required attribute for a <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> object is "variable". For Level&#160;1, where the equivalent attribute is known by different names ("compartment", "species", or "name", depending on the type of object), there is an additional required attribute called "formula".</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the required attributes have been set, <code>false</code> otherwise. </dd></dl>

<p>Reimplemented from <a class="el" href="class_rule.html#ad560d5073aa935a71d5bb23fe3da62d6">Rule</a>.</p>

</div>
</div>
<a class="anchor" id="a4de991eb944dd12f49f795a0432dfa06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rule::hasRequiredElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if all the required elements for this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> object have been set. </p>
<p>The only required element for a <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> object is the "math" subelement in SBML Level&#160;2 and Level&#160;3 Version&#160;1. In SBML Level&#160;3 Version&#160;2+, it is no longer required.</p>
<dl class="section return"><dt>Returns</dt><dd>a boolean value indicating whether all the required elements for this object have been defined. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c78f1941d1d0fc804b6b4a1dd0db54e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::hasValidLevelVersionNamespaceCombination </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this object's level/version and namespace values correspond to a valid SBML specification. </p>
<p>The valid combinations of SBML Level, Version and Namespace as of this release of libSBML are the following: </p><ul>
<li>
Level&#160;1 Version&#160;2: &quot;<code style="margin-right:0; padding-right:0">http</code><code style="margin-left:0; padding-left:0">://www.sbml.org/sbml/level1</code>&quot; </li>
<li>
Level&#160;2 Version&#160;1: &quot;<code style="margin-right:0; padding-right:0">http</code><code style="margin-left:0; padding-left:0">://www.sbml.org/sbml/level2</code>&quot; </li>
<li>
Level&#160;2 Version&#160;2: &quot;<code style="margin-right:0; padding-right:0">http</code><code style="margin-left:0; padding-left:0">://www.sbml.org/sbml/level2/version2</code>&quot; </li>
<li>
Level&#160;2 Version&#160;3: &quot;<code style="margin-right:0; padding-right:0">http</code><code style="margin-left:0; padding-left:0">://www.sbml.org/sbml/level2/version3</code>&quot; </li>
<li>
Level&#160;2 Version&#160;4: &quot;<code style="margin-right:0; padding-right:0">http</code><code style="margin-left:0; padding-left:0">://www.sbml.org/sbml/level2/version4</code>&quot; </li>
<li>
Level&#160;2 Version&#160;5: &quot;<code style="margin-right:0; padding-right:0">http</code><code style="margin-left:0; padding-left:0">://www.sbml.org/sbml/level2/version5</code>&quot; </li>
<li>
Level&#160;3 Version&#160;1 Core: &quot;<code style="margin-right:0; padding-right:0">http</code><code style="margin-left:0; padding-left:0">://www.sbml.org/sbml/level3/version1/core</code>&quot; </li>
<li>
Level&#160;3 Version&#160;2 Core: &quot;<code style="margin-right:0; padding-right:0">http</code><code style="margin-left:0; padding-left:0">://www.sbml.org/sbml/level3/version2/core</code>&quot; </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the level, version and namespace values of this SBML object correspond to a valid set of values, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a57bfc9dcae803017df4730c9619ee9f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rule::isAlgebraic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is an <a class="el" href="class_algebraic_rule.html" title=" An SBML algebraic rule representing 0 = f(W). ">AlgebraicRule</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is an <a class="el" href="class_algebraic_rule.html" title=" An SBML algebraic rule representing 0 = f(W). ">AlgebraicRule</a>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aba9d996c385325d233e9d2b0484a4610"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rule::isAssignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is an <a class="el" href="class_assignment_rule.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is an <a class="el" href="class_assignment_rule.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule</a>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="afe96b3ecf285d008dc401d4baba34786"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rule::isCompartmentVolume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is an CompartmentVolumeRule or equivalent. </p>
<p>This libSBML method works for SBML Level&#160;1 models (where there is such a thing as an explicit CompartmentVolumeRule), as well as other Levels of SBML. For Levels above Level&#160;1, this method checks the symbol being affected by the rule, and returns <code>true</code> if the symbol is the identifier of a <a class="el" href="class_compartment.html" title=" An SBML compartment, where species are located. ">Compartment</a> object defined in the model.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is a CompartmentVolumeRule, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a60ea0c99c7dffe1f0afc710358b537a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isPackageEnabled </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pkgName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if the given SBML Level&#160;3 package is enabled with this object. </p>
<p>The search ignores the package version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkgName</td><td>the name of the package.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given package is enabled within this object, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ad9f68f8a35a952df01c3e81248bb51f4" title="Predicate returning true if an SBML Level&#160;3 package with the given URI is enabled with this object...">isPackageURIEnabled()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad9f68f8a35a952df01c3e81248bb51f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isPackageURIEnabled </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pkgURI</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if an SBML Level&#160;3 package with the given URI is enabled with this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkgURI</td><td>the URI of the package.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given package is enabled within this object, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a60ea0c99c7dffe1f0afc710358b537a3" title="Predicate returning true if the given SBML Level&#160;3 package is enabled with this object. ">isPackageEnabled()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8195a67115217b55f42241d00d951134"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rule::isParameter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is an ParameterRule or equivalent. </p>
<p>This libSBML method works for SBML Level&#160;1 models (where there is such a thing as an explicit ParameterRule), as well as other Levels of SBML. For Levels above Level&#160;1, this method checks the symbol being affected by the rule, and returns <code>true</code> if the symbol is the identifier of a <a class="el" href="class_parameter.html" title=" An SBML parameter: a named symbol with a value. ">Parameter</a> object defined in the model.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is a ParameterRule, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1dadc50ef089b47e70e2608e7ca2785e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isPkgEnabled </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pkgName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if the given SBML Level&#160;3 package is enabled with this object. </p>
<p>The search ignores the package version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkgName</td><td>the name of the package.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given package is enabled within this object, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ac2c034c6274fa5da28b781a4c30e7088" title="Predicate returning true if an SBML Level&#160;3 package with the given URI is enabled with this object...">isPkgURIEnabled()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac2c034c6274fa5da28b781a4c30e7088"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isPkgURIEnabled </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pkgURI</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if an SBML Level&#160;3 package with the given URI is enabled with this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkgURI</td><td>the URI of the package.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given package is enabled within this object, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a1dadc50ef089b47e70e2608e7ca2785e" title="Predicate returning true if the given SBML Level&#160;3 package is enabled with this object. ">isPkgEnabled()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1ce2768a6aa73c8fdb0426397bcac1c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rule::isRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is a <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> (SBML Levels&#160;2&ndash;3) or has a "type" attribute value of <code>"rate"</code> (SBML Level&#160;1). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is a <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a> (Level&#160;2) or has type "rate" (Level&#160;1), <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ecd9b9dfecc5b784e5b624d25e7b47c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rule::isScalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is an <a class="el" href="class_assignment_rule.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule</a> (SBML Levels&#160;2&ndash;3) or has a "type" attribute value of <code>"scalar"</code> (SBML Level&#160;1). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is an <a class="el" href="class_assignment_rule.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule</a> (Level&#160;2) or has type "scalar" (Level&#160;1), <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a279ce55f23330dc6bb0231774adfc42b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isSetAnnotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this object's "annotation" subelement exists and has content. </p>
<p>Whereas the <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> "notes" subelement is a container for content to be shown directly to humans, the "annotation" element is a container for optional software-generated content <em>not</em> meant to be shown to humans. Every object derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> can have its own value for "annotation". The element's content type is <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls" target="_blank">XML type "any"</a>, allowing essentially arbitrary well-formed XML data content.</p>
<p>SBML places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the SBML specifications for more details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a "annotation" subelement exists, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a4fbf6701023075573bd76fa0bd276291" title="Returns the content of the &quot;annotation&quot; subelement of this object as a tree of XMLNode objects...">getAnnotation()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adbff50c6c73c044a5c8e29e6b5dcefc6" title="Returns the content of the &quot;annotation&quot; subelement of this object as a character string. ">getAnnotationString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a11d9c02a3690d9a13362835ef0133125" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object. ">setAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a75b1541bd854ad7edfe0aff79ab3231f" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object. ">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#accc96fb06a79df769eb3669e090771e5" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object. ">appendAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a118148398f5c626bf9697887296f97b8" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object. ">appendAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a9121d6a4f7401fe957cc75647a1e95ed" title="Unsets the value of the &quot;annotation&quot; subelement of this SBML object. ">unsetAnnotation()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="print_annotation_8cpp-example.html#a2">printAnnotation.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a30847417c7341e8fefc494293f59e1cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rule::isSetFormula </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>'s mathematical expression is set. </p>
<p>This method is equivalent to <a class="el" href="class_rule.html#aef7da5cccceb8ead3aeb318e5617d265" title="Predicate returning true if this Rule&#39;s mathematical expression is set. ">isSetMath()</a>. This version is present for easier compatibility with SBML Level&#160;1, in which mathematical formulas were written in text-string form.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the mathematical formula for this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is set, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The attribute "formula" is specific to SBML Level&#160;1; in higher Levels of SBML, it has been replaced with a subelement named "math". However, libSBML provides a unified interface to the underlying math expression and this method can be used for models of all Levels of SBML.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_rule.html#aef7da5cccceb8ead3aeb318e5617d265" title="Predicate returning true if this Rule&#39;s mathematical expression is set. ">isSetMath()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a20e059dca5f0e97bdc7dc2e8fd3e4c35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isSetId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if a call to <a class="el" href="class_s_base.html#a8bd7cb0de43db3680bd1eeb30022fcd3" title="Returns the value of the &quot;id&quot; attribute of this SBML object, if it has one, or the &quot;variable&quot; attribu...">getId()</a> returns a non-empty string. </p>
<p>For most objects, this function will return <code>true</code> if its "id" attribute is set, and <code>false</code> if it is not, or if the object has no "id" attribute at all. However, for an <a class="el" href="class_event_assignment.html" title=" An assignment to a variable by an SBML event. ">EventAssignment</a> or a <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>, <a class="el" href="class_s_base.html#a20e059dca5f0e97bdc7dc2e8fd3e4c35" title="Predicate returning true if a call to getId() returns a non-empty string. ">isSetId()</a> checks whether the "variable" attribute is set, and for an <a class="el" href="class_initial_assignment.html" title=" An SBML initial assignment, evaluated once only. ">InitialAssignment</a>, it checks whether the "symbol" attribute is set. Because those elements will also have an "id" attribute in SBML Level&#160;3 Version&#160;2 which <a class="el" href="class_s_base.html#a20e059dca5f0e97bdc7dc2e8fd3e4c35" title="Predicate returning true if a call to getId() returns a non-empty string. ">isSetId()</a> will not check, the function itself is deprecated, and it is recommended to use <a class="el" href="class_s_base.html#ad201f20c9527cff5daf5d05bf49aac8c" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set. ">isSetIdAttribute()</a> in all cases where one needs to know whether the "id" attribute is set, and to use <a class="el" href="class_event_assignment.html#a7c0ddb6b27387e88c7604795a65b7a3a" title="Predicate for testing whether the attribute &quot;variable&quot; of this EventAssignment is set...">EventAssignment::isSetVariable()</a>, <a class="el" href="class_rule.html#a8a5fcb43d75b82d54382d2a28eea8e45" title="Predicate returning true if this Rule&#39;s &quot;variable&quot; attribute is set. ">Rule::isSetVariable()</a> and <a class="el" href="class_initial_assignment.html#a74a7e8df23786d048dbe82e3a104f535" title="Predicate returning true if this InitialAssignment&#39;s &quot;symbol&quot; attribute is set. ">InitialAssignment::isSetSymbol()</a> when the status of the "variable" or "symbol" attributes need to be checked.</p>
<dl class="section user"><dt></dt><dd>The identifier given by an object's "id" attribute value is used to identify the object within the SBML model definition. Other objects can refer to the component using this identifier. The data type of "id" is always <code>SId</code> or a type derived from that, such as <code>UnitSId</code>, depending on the object in question. All data types are defined as follows: <pre style="margin-left: 2em; border: none; font-weight: bold; color: black">
     letter ::= 'a'..'z','A'..'Z'
     digit  ::= '0'..'9'
     idChar ::= letter | digit | '_'
     SId    ::= ( letter | '_' ) idChar*
   </pre> The characters <code>(</code> and <code>)</code> are used for grouping, the character <code>*</code> "zero or more times", and the character <code>|</code> indicates logical "or". The equality of SBML identifiers is determined by an exact character sequence match; i.e., comparisons must be performed in a case-sensitive manner. This applies to all uses of <code>SId</code>, <code>SIdRef</code>, and derived types.</dd></dl>
<p>Users need to be aware of some important API issues that are the result of the history of SBML and libSBML. Prior to SBML Level&#160;3 Version&#160;2, SBML defined "id" and "name" attributes on only a subset of SBML objects. To simplify the work of programmers, libSBML's API provided get, set, check, and unset on the <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> object class itself instead of on individual subobject classes. This made the get/set/etc. methods uniformly available on all objects in the libSBML API. LibSBML simply returned empty strings or otherwise did not act when the methods were applied to SBML objects that were not defined by the SBML specification to have "id" or "name" attributes. Additional complications arose with the rule and assignment objects: <a class="el" href="class_initial_assignment.html" title=" An SBML initial assignment, evaluated once only. ">InitialAssignment</a>, <a class="el" href="class_event_assignment.html" title=" An assignment to a variable by an SBML event. ">EventAssignment</a>, <a class="el" href="class_assignment_rule.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule</a>, and <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a>. In early versions of SBML, the rule object hierarchy was different, and in addition, then as now, they possess different attributes: "variable" (for the rules and event assignments), "symbol" (for initial assignments), or neither (for algebraic rules). Prior to SBML Level&#160;3 Version&#160;2, <a class="el" href="class_s_base.html#a8bd7cb0de43db3680bd1eeb30022fcd3" title="Returns the value of the &quot;id&quot; attribute of this SBML object, if it has one, or the &quot;variable&quot; attribu...">getId()</a> would always return an empty string, and <a class="el" href="class_s_base.html#a20e059dca5f0e97bdc7dc2e8fd3e4c35" title="Predicate returning true if a call to getId() returns a non-empty string. ">isSetId()</a> would always return <code>false</code> for objects of these classes.</p>
<p>With the addition of "id" and "name" attributes on <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> in Level&#160;3 Version&#160;2, it became necessary to introduce a new way to interact with the attributes more consistently in libSBML to avoid breaking backward compatibility in the behavior of the original "id" methods. For this reason, libSBML provides four functions (<a class="el" href="class_s_base.html#acd5e8dc937c46ace3af5125c8674c199" title="Returns the value of the &quot;id&quot; attribute of this SBML object. ">getIdAttribute()</a>, <a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object. ">setIdAttribute()</a>, <a class="el" href="class_s_base.html#ad201f20c9527cff5daf5d05bf49aac8c" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set. ">isSetIdAttribute()</a>, and <a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object. ">unsetIdAttribute()</a>) that always act on the actual "id" attribute inherited from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a>, regardless of the object's type. <b>These new methods should be used instead of the older <a class="el" href="class_s_base.html#a8bd7cb0de43db3680bd1eeb30022fcd3" title="Returns the value of the &quot;id&quot; attribute of this SBML object, if it has one, or the &quot;variable&quot; attribu...">getId()</a>/setId()/etc. methods</b> unless the old behavior is somehow necessary. Regardless of the Level and Version of the SBML, these functions allow client applications to use more generalized code in some situations (for instance, when manipulating objects that are all known to have identifiers). If the object in question does not posess an "id" attribute according to the SBML specification for the Level and Version in use, libSBML will not allow the identifier to be set, nor will it read or write "id" attributes for those objects.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the "id" attribute of this SBML object is set, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Because of the inconsistent behavior of this function with respect to assignments and rules, it is recommended that callers use <a class="el" href="class_s_base.html#ad201f20c9527cff5daf5d05bf49aac8c" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set. ">isSetIdAttribute()</a> instead.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#acd5e8dc937c46ace3af5125c8674c199" title="Returns the value of the &quot;id&quot; attribute of this SBML object. ">getIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object. ">setIdAttribute(const std::string&amp; sid)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object. ">unsetIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#ad201f20c9527cff5daf5d05bf49aac8c" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set. ">isSetIdAttribute()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_layout.html#a4b3c7c4be15ccef1591c7819d7efff51">Layout</a>, <a class="el" href="class_compartment.html#a0f1e7aa7c39250e66ad9d340953adb2c">Compartment</a>, <a class="el" href="class_model.html#afc947d05cc98790a9cf9387488864dfd">Model</a>, <a class="el" href="class_species.html#a3c66735629942690a5a286507bc8fb67">Species</a>, <a class="el" href="class_event.html#ac6f24906598184f85d395912f57a49c6">Event</a>, <a class="el" href="class_reaction.html#ad9beda0c909fc08583da05c637b673b4">Reaction</a>, <a class="el" href="class_unit_definition.html#a060f359a8cced2344de5adbbfaf6c6a4">UnitDefinition</a>, <a class="el" href="class_parameter.html#ac4e5f2d5d13e63c636f80d013b3f7ad7">Parameter</a>, <a class="el" href="class_color_definition.html#ab71284e53850af2623d245e4923420d9">ColorDefinition</a>, <a class="el" href="class_group.html#a26c2e8695db817afe9112be662803d0a">Group</a>, <a class="el" href="class_gradient_base.html#ad2f500b332d8ce335411c77e776e0f74">GradientBase</a>, <a class="el" href="class_render_information_base.html#abdc1b8039178e8c0c85b62de34b4a69f">RenderInformationBase</a>, <a class="el" href="class_submodel.html#aac93e63a964b82c0db131de14890c614">Submodel</a>, <a class="el" href="class_function_definition.html#a2df7ed830af3098009186c7292abd848">FunctionDefinition</a>, <a class="el" href="class_objective.html#aa639fb51823620903bea7442800e90c0">Objective</a>, <a class="el" href="class_dimensions.html#a3d84de5ba7b09515ad55772fe4a45141">Dimensions</a>, <a class="el" href="class_gene_product_association.html#ab4795a1372907d9a3fae12b76c5ff8b4">GeneProductAssociation</a>, <a class="el" href="class_input.html#a87726e8fe5d2f192f88f7937978a7c38">Input</a>, <a class="el" href="class_graphical_primitive1_d.html#afcfe9d1a4389f0398ae05666cda59962">GraphicalPrimitive1D</a>, <a class="el" href="class_graphical_object.html#a57f8976dda14f6a73f167f973617edcc">GraphicalObject</a>, <a class="el" href="class_qualitative_species.html#accd833b13b912c973a687fbace49bde4">QualitativeSpecies</a>, <a class="el" href="class_output.html#ac989ad438c8a544a0ccbbff53675fae0">Output</a>, <a class="el" href="class_flux_objective.html#a615e197269340a8453eac08f0fb284e5">FluxObjective</a>, <a class="el" href="class_compartment_type.html#a6001346c5dcf6d879050c8c2c6a9d467">CompartmentType</a>, <a class="el" href="class_external_model_definition.html#aa8c76946709decda82a8e5da1acdaa2d">ExternalModelDefinition</a>, <a class="el" href="class_outward_binding_site.html#a51b1846c9c9965ed593535a77e912190">OutwardBindingSite</a>, <a class="el" href="class_point.html#a336043154d3d612c579a3766b3fb1d6a">Point</a>, <a class="el" href="class_line_ending.html#a1bea6a10dd785c4a80f2a830569ea297">LineEnding</a>, <a class="el" href="class_species_type.html#a86a5916cba5a642e855da43a51663911">SpeciesType</a>, <a class="el" href="class_flux_bound.html#a08b50ac9e3dc5539ba25426f0460cd09">FluxBound</a>, <a class="el" href="class_transition.html#a3018fb305bb6e9e54f8e498f370cfc64">Transition</a>, <a class="el" href="class_gene_product.html#a8a4bdc9d85e026ba92a05ff573d762fb">GeneProduct</a>, <a class="el" href="class_image.html#ad08c17ed92ba999a86b8e1519cc3ec04">Image</a>, <a class="el" href="class_style.html#a633ef7724ba0833c7f0b52d9cd53eee5">Style</a>, <a class="el" href="class_deletion.html#a17ffd05015555d594a21881f1dac8e99">Deletion</a>, <a class="el" href="class_list_of_members.html#ad01dd60e32324953205aeee519972ad0">ListOfMembers</a>, <a class="el" href="class_gene_product_ref.html#aba81bcb73db2eed27d4a8f398b0c9bba">GeneProductRef</a>, <a class="el" href="class_sub_list_of_species_features.html#ade1fcb25b97f3bb115a8d6559c8e71ce">SubListOfSpeciesFeatures</a>, <a class="el" href="class_member.html#a4aad70dcf37dec696ae6831f8e996934">Member</a>, <a class="el" href="class_simple_species_reference.html#a28d19b434bc6bc8b04bc3df93c8c7d4b">SimpleSpeciesReference</a>, <a class="el" href="class_bounding_box.html#a8275de89f71af33e9bbe1b2a6c0f2e7a">BoundingBox</a>, <a class="el" href="class_multi_species_type.html#a05100d80f8ad2e58094f56a1e2e2dc3b">MultiSpeciesType</a>, <a class="el" href="class_species_feature.html#ac402979be16e7bbe4b7247664e24a213">SpeciesFeature</a>, <a class="el" href="class_port.html#a5c3e4aad504e52dee3353ff13aec6f59">Port</a>, <a class="el" href="class_species_feature_type.html#a8e022ce5a3a281988c815f3c038426f7">SpeciesFeatureType</a>, <a class="el" href="class_species_type_instance.html#a01143789d7394e3a27ec17dc364e075c">SpeciesTypeInstance</a>, <a class="el" href="class_species_type_component_map_in_product.html#ad8a3b238b235d9433f47709f9f13b803">SpeciesTypeComponentMapInProduct</a>, <a class="el" href="class_gene_association.html#ae00470ee8fcbd7d045662739f5b158cd">GeneAssociation</a>, <a class="el" href="class_species_type_component_index.html#a601a439b51dfa356017020534d14fdad">SpeciesTypeComponentIndex</a>, <a class="el" href="class_in_species_type_bond.html#aa8a45ab893592498692ee49d7939fe2f">InSpeciesTypeBond</a>, <a class="el" href="class_possible_species_feature_value.html#a44d5d1adb6a883387dc266740b170a45">PossibleSpeciesFeatureValue</a>, and <a class="el" href="class_compartment_reference.html#a5c4b32630d8b51e155ae7295c5380d31">CompartmentReference</a>.</p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="get_all_elements_with_notes_8cpp-example.html#a4">getAllElementsWithNotes.cpp</a>, <a class="el" href="print_annotation_8cpp-example.html#a3">printAnnotation.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a3">printNotes.cpp</a>, <a class="el" href="set_id_from_names_8cpp-example.html#a12">setIdFromNames.cpp</a>, and <a class="el" href="set_names_from_ids_8cpp-example.html#a5">setNamesFromIds.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad201f20c9527cff5daf5d05bf49aac8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isSetIdAttribute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this object's "id" attribute is set. </p>
<dl class="section user"><dt></dt><dd>The identifier given by an object's "id" attribute value is used to identify the object within the SBML model definition. Other objects can refer to the component using this identifier. The data type of "id" is always <code>SId</code> or a type derived from that, such as <code>UnitSId</code>, depending on the object in question. All data types are defined as follows: <pre style="margin-left: 2em; border: none; font-weight: bold; color: black">
     letter ::= 'a'..'z','A'..'Z'
     digit  ::= '0'..'9'
     idChar ::= letter | digit | '_'
     SId    ::= ( letter | '_' ) idChar*
   </pre> The characters <code>(</code> and <code>)</code> are used for grouping, the character <code>*</code> "zero or more times", and the character <code>|</code> indicates logical "or". The equality of SBML identifiers is determined by an exact character sequence match; i.e., comparisons must be performed in a case-sensitive manner. This applies to all uses of <code>SId</code>, <code>SIdRef</code>, and derived types.</dd></dl>
<p>Users need to be aware of some important API issues that are the result of the history of SBML and libSBML. Prior to SBML Level&#160;3 Version&#160;2, SBML defined "id" and "name" attributes on only a subset of SBML objects. To simplify the work of programmers, libSBML's API provided get, set, check, and unset on the <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> object class itself instead of on individual subobject classes. This made the get/set/etc. methods uniformly available on all objects in the libSBML API. LibSBML simply returned empty strings or otherwise did not act when the methods were applied to SBML objects that were not defined by the SBML specification to have "id" or "name" attributes. Additional complications arose with the rule and assignment objects: <a class="el" href="class_initial_assignment.html" title=" An SBML initial assignment, evaluated once only. ">InitialAssignment</a>, <a class="el" href="class_event_assignment.html" title=" An assignment to a variable by an SBML event. ">EventAssignment</a>, <a class="el" href="class_assignment_rule.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule</a>, and <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a>. In early versions of SBML, the rule object hierarchy was different, and in addition, then as now, they possess different attributes: "variable" (for the rules and event assignments), "symbol" (for initial assignments), or neither (for algebraic rules). Prior to SBML Level&#160;3 Version&#160;2, <a class="el" href="class_s_base.html#a8bd7cb0de43db3680bd1eeb30022fcd3" title="Returns the value of the &quot;id&quot; attribute of this SBML object, if it has one, or the &quot;variable&quot; attribu...">getId()</a> would always return an empty string, and <a class="el" href="class_s_base.html#a20e059dca5f0e97bdc7dc2e8fd3e4c35" title="Predicate returning true if a call to getId() returns a non-empty string. ">isSetId()</a> would always return <code>false</code> for objects of these classes.</p>
<p>With the addition of "id" and "name" attributes on <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> in Level&#160;3 Version&#160;2, it became necessary to introduce a new way to interact with the attributes more consistently in libSBML to avoid breaking backward compatibility in the behavior of the original "id" methods. For this reason, libSBML provides four functions (<a class="el" href="class_s_base.html#acd5e8dc937c46ace3af5125c8674c199" title="Returns the value of the &quot;id&quot; attribute of this SBML object. ">getIdAttribute()</a>, <a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object. ">setIdAttribute()</a>, <a class="el" href="class_s_base.html#ad201f20c9527cff5daf5d05bf49aac8c" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set. ">isSetIdAttribute()</a>, and <a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object. ">unsetIdAttribute()</a>) that always act on the actual "id" attribute inherited from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a>, regardless of the object's type. <b>These new methods should be used instead of the older <a class="el" href="class_s_base.html#a8bd7cb0de43db3680bd1eeb30022fcd3" title="Returns the value of the &quot;id&quot; attribute of this SBML object, if it has one, or the &quot;variable&quot; attribu...">getId()</a>/setId()/etc. methods</b> unless the old behavior is somehow necessary. Regardless of the Level and Version of the SBML, these functions allow client applications to use more generalized code in some situations (for instance, when manipulating objects that are all known to have identifiers). If the object in question does not posess an "id" attribute according to the SBML specification for the Level and Version in use, libSBML will not allow the identifier to be set, nor will it read or write "id" attributes for those objects.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the "id" attribute of this SBML object is set, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#acd5e8dc937c46ace3af5125c8674c199" title="Returns the value of the &quot;id&quot; attribute of this SBML object. ">getIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object. ">setIdAttribute(const std::string&amp; sid)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object. ">unsetIdAttribute()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aef7da5cccceb8ead3aeb318e5617d265"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rule::isSetMath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>'s mathematical expression is set. </p>
<p>This method is equivalent to <a class="el" href="class_rule.html#a30847417c7341e8fefc494293f59e1cc" title="Predicate returning true if this Rule&#39;s mathematical expression is set. ">isSetFormula()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the formula (or equivalently the math) for this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is set, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The subelement "math" is present in SBML Levels&#160;2 and&#160;3. In SBML Level&#160;1, the equivalent construct is the attribute named "formula". LibSBML provides a unified interface to the underlying math expression and this method can be used for models of all Levels of SBML.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_rule.html#a30847417c7341e8fefc494293f59e1cc" title="Predicate returning true if this Rule&#39;s mathematical expression is set. ">isSetFormula()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="print_math_8cpp-example.html#a11">printMath.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a24fc99c2ba9431594a78b78536699a0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isSetMetaId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this object's "metaid" attribute is set. </p>
<dl class="section user"><dt></dt><dd>The optional attribute named "metaid", present on every major SBML component type, is for supporting metadata annotations using RDF (<a href="http://www.w3.org/RDF/">Resource Description Format</a>). The attribute value has the data type <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a>, the XML identifier type, which means each "metaid" value must be globally unique within an SBML file. The latter point is important, because the uniqueness criterion applies across <em>any</em> attribute with type <code>ID</code> anywhere in the file, not just the "metaid" attribute used by SBML&mdash;something to be aware of if your application-specific XML content inside the "annotation" subelement happens to use the XML <code>ID</code> type. Although SBML itself specifies the use of <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a> only for the "metaid" attribute, SBML-compatible applications should be careful if they use XML <code>ID</code>'s in XML portions of a model that are not defined by SBML, such as in the application-specific content of the "annotation" subelement. Finally, note that LibSBML does not provide an explicit XML <code>ID</code> data type; it uses ordinary character strings, which is easier for applications to support.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the "metaid" attribute of this SBML object is set, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a2880c1c6a2df519371637a9234ed68a4" title="Returns the value of the &quot;metaid&quot; attribute of this SBML object. ">getMetaId()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a050779a94ecdb2d73d7edfef73bc1e55" title="Sets the value of the meta-identifier attribute of this SBML object. ">setMetaId(const std::string&amp; metaid)</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="adding_evidence_codes_1_8cpp-example.html#a9">addingEvidenceCodes_1.cpp</a>, and <a class="el" href="adding_evidence_codes_2_8cpp-example.html#a9">addingEvidenceCodes_2.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a03795a0c11687c49f9b4a2017607de95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isSetModelHistory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this object has a <a class="el" href="class_model_history.html" title=" MIRIAM-compliant data about a model&#39;s history. ">ModelHistory</a> object attached to it. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="class_model_history.html" title=" MIRIAM-compliant data about a model&#39;s history. ">ModelHistory</a> of this object is set, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In SBML Level&#160;2, model history annotations were only permitted on the <a class="el" href="class_model.html" title=" An SBML model. ">Model</a> element. In SBML Level&#160;3, they are permitted on all SBML components derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a541c62b7ad823db1f14674386a61b52f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isSetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this object's "name" attribute is set. </p>
<dl class="section user"><dt></dt><dd>In SBML Level&#160;3 Version&#160;2, the "id" and "name" attributes were moved to <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> directly, instead of being defined individually for many (but not all) objects. LibSBML has for a long time provided functions defined on <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> itself to get, set, and unset those attributes, which would fail or otherwise return empty strings if executed on any object for which those attributes were not defined. Now that all <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> objects define those attributes, those functions now succeed for any object with the appropriate level and version.</dd></dl>
<p>The "name" attribute is optional and is not intended to be used for cross-referencing purposes within a model. Its purpose instead is to provide a human-readable label for the component. The data type of "name" is the type <code>string</code> defined in XML Schema. SBML imposes no restrictions as to the content of "name" attributes beyond those restrictions defined by the <code>string</code> type in XML Schema.</p>
<p>The recommended practice for handling "name" is as follows. If a software tool has the capability for displaying the content of "name" attributes, it should display this content to the user as a component's label instead of the component's "id". If the user interface does not have this capability (e.g., because it cannot display or use special characters in symbol names), or if the "name" attribute is missing on a given component, then the user interface should display the value of the "id" attribute instead. (Script language interpreters are especially likely to display "id" instead of "name".)</p>
<p>As a consequence of the above, authors of systems that automatically generate the values of "id" attributes should be aware some systems may display the "id"'s to the user. Authors therefore may wish to take some care to have their software create "id" values that are: (a) reasonably easy for humans to type and read; and (b) likely to be meaningful, for example by making the "id" attribute be an abbreviated form of the name attribute value.</p>
<p>An additional point worth mentioning is although there are restrictions on the uniqueness of "id" values, there are no restrictions on the uniqueness of "name" values in a model. This allows software applications leeway in assigning component identifiers.</p>
<p>Regardless of the level and version of the SBML, these functions allow client applications to use more generalized code in some situations (for instance, when manipulating objects that are all known to have names). If the object in question does not posess a "name" attribute according to the SBML specification for the Level and Version in use, libSBML will not allow the name to be set, nor will it read or write "name" attributes for those objects.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the "name" attribute of this SBML object is set, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ab24c4b22c1ac115368032d558b6fe4e4" title="Returns the value of the &quot;name&quot; attribute of this SBML object. ">getName()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a1531f729b16689aba3fb7f3567202a7c" title="Sets the value of the &quot;name&quot; attribute of this SBML object. ">setName(const std::string&amp; sid)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a4cf8825fb83925a508eaac3d7f8fbb8c" title="Unsets the value of the &quot;name&quot; attribute of this SBML object. ">unsetName()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_layout.html#a2f1008cfbd4ef91571e38b0f7fb7c7fa">Layout</a>, <a class="el" href="class_compartment.html#a60a0a13cec120bc52e19acb51347a620">Compartment</a>, <a class="el" href="class_model.html#a17b8a22e01c8326283adb879876c3646">Model</a>, <a class="el" href="class_species.html#a5c34e959199081258140fc53c6c164cb">Species</a>, <a class="el" href="class_event.html#a9bdf1ed8580b651704acfef384ecd915">Event</a>, <a class="el" href="class_reaction.html#a376c7a4c20186c6ab5220a09f1177bdb">Reaction</a>, <a class="el" href="class_unit_definition.html#a07235710fd166464d3a0eb76bf625f3e">UnitDefinition</a>, <a class="el" href="class_parameter.html#ae25a6ed25c7b7babb67e95de99d6f003">Parameter</a>, <a class="el" href="class_color_definition.html#a762a46c16c15b3ec068d415ea15feb44">ColorDefinition</a>, <a class="el" href="class_submodel.html#a027d37abc6ab9f89552ca1aeac302d81">Submodel</a>, <a class="el" href="class_gradient_base.html#afd0638f3cb2a2af9fece9ef4341a70fa">GradientBase</a>, <a class="el" href="class_group.html#a635e7b95072f3ecdf0e0b10335350aba">Group</a>, <a class="el" href="class_render_information_base.html#acd41af7276ea7c3b9090882504faec2a">RenderInformationBase</a>, <a class="el" href="class_input.html#ae94df0eae3beaa3cc8e6a47ac9e4bd55">Input</a>, <a class="el" href="class_function_definition.html#a640fa812a6c88871760c174cd3dcc4a4">FunctionDefinition</a>, <a class="el" href="class_objective.html#aac28ac18da28b13371e781bff9a0ddbe">Objective</a>, <a class="el" href="class_outward_binding_site.html#af33ee588a3af4a0d5139cd6fc66244a0">OutwardBindingSite</a>, <a class="el" href="class_qualitative_species.html#a42a4b2555e481c0ebb0418e35f8bdab8">QualitativeSpecies</a>, <a class="el" href="class_output.html#adcbc13cd5a3951255fe7914e5db7fcd1">Output</a>, <a class="el" href="class_external_model_definition.html#a2625a04c4b085d3683a4319ffedfec1c">ExternalModelDefinition</a>, <a class="el" href="class_gene_product_association.html#afe2ddea5662035b4590c21c6af828875">GeneProductAssociation</a>, <a class="el" href="class_flux_bound.html#aa1a98536f609e64a770f306b1a584358">FluxBound</a>, <a class="el" href="class_sub_list_of_species_features.html#a64679205e3e64e6755c3d5bf131c84e0">SubListOfSpeciesFeatures</a>, <a class="el" href="class_deletion.html#afc0f9fd7597387f2bfc034419b179855">Deletion</a>, <a class="el" href="class_flux_objective.html#a113cf753d4b24ff055af7d7da6008c5c">FluxObjective</a>, <a class="el" href="class_compartment_type.html#a770bbbd84ec51ea34e48462f40aabfd0">CompartmentType</a>, <a class="el" href="class_species_type.html#ac7da0437bcc716391beca271a649b3eb">SpeciesType</a>, <a class="el" href="class_transition.html#a54d8bb81694695ae68ba35fcdb061c57">Transition</a>, <a class="el" href="class_gene_product.html#a914d46ee9527240acea9805925124242">GeneProduct</a>, <a class="el" href="class_transformation.html#ad9d20e68c83ef4ba68ce9854f0cf6c4e">Transformation</a>, <a class="el" href="class_gene_product_ref.html#a06ed08a9f73ee6ef8c6478963da9d1cc">GeneProductRef</a>, <a class="el" href="class_multi_species_type.html#aa1d7cddd5ce3ff549ac2e643cd7a249e">MultiSpeciesType</a>, <a class="el" href="class_species_feature.html#a9b68c14b9ab37112cd937f161b1abe44">SpeciesFeature</a>, <a class="el" href="class_style.html#af0845b8cc9c2f08f1d43fa26375d8dea">Style</a>, <a class="el" href="class_list_of_members.html#a1d3ab690df91537d10bd00da4c42a61e">ListOfMembers</a>, <a class="el" href="class_species_feature_type.html#a0f37cbe0377497d85d68ab18dbeb8f10">SpeciesFeatureType</a>, <a class="el" href="class_species_type_component_map_in_product.html#abc9277e2e9dbcc2ffe5285496fe2171b">SpeciesTypeComponentMapInProduct</a>, <a class="el" href="class_port.html#a39a055554c47cd6d8786c027ec9e7052">Port</a>, <a class="el" href="class_species_type_instance.html#a4db81e7889ad0fb6c2a53f87966c20d6">SpeciesTypeInstance</a>, <a class="el" href="class_species_type_component_index.html#a30907c3c33554baf226bf27ae0bd92ea">SpeciesTypeComponentIndex</a>, <a class="el" href="class_in_species_type_bond.html#a7b30ba8e94d28272e6f6e72de2451637">InSpeciesTypeBond</a>, <a class="el" href="class_possible_species_feature_value.html#aaad5a608ce15fdfa3b6a8e6adbc25164">PossibleSpeciesFeatureValue</a>, <a class="el" href="class_member.html#a5de262fd0b347b70bef778a1519f9a34">Member</a>, <a class="el" href="class_simple_species_reference.html#a173dc437308d713bfb0741c4e86f4e79">SimpleSpeciesReference</a>, and <a class="el" href="class_compartment_reference.html#a29cc079ec529ef0a22be6c55c24ff7c2">CompartmentReference</a>.</p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="set_id_from_names_8cpp-example.html#a5">setIdFromNames.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aeff0554efc75440b5375b35a4d188ea0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isSetNotes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this object's "notes" subelement exists and has content. </p>
<p>The optional SBML element named "notes", present on every major SBML component type, is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</p>
<p>The format of "notes" elements must be <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. To help verify the formatting of "notes" content, libSBML provides the static utility method <a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content...">SyntaxChecker::hasExpectedXHTMLSyntax()</a>; however, readers are urged to consult the appropriate <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specification document</a> for the Level and Version of their model for more in-depth explanations. The SBML Level&#160;2 and&#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a "notes" subelement exists, <code>false</code> otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ac34eff3877f512b8bf31facff83c4483" title="Returns the content of the &quot;notes&quot; subelement of this object as a tree of XMLNode objects...">getNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a6eee96ee206a55837c0d7b936f20f14d" title="Returns the content of the &quot;notes&quot; subelement of this object as a string. ">getNotesString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e" title="Sets the value of the &quot;notes&quot; subelement of this SBML object. ">setNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a478ad1e0e2bb2dc27a9de6ab9bac4bf2" title="Sets the value of the &quot;notes&quot; subelement of this SBML object to a copy of the string notes...">setNotes(const std::string&amp; notes, bool addXHTMLMarkup)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adb8c800163c108a27880bd644d7767ad" title="Appends the given notes to the &quot;notes&quot; subelement of this object. ">appendNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a33da5a2b0b03cbe6af69730869e35212" title="Appends the given notes to the &quot;notes&quot; subelement of this object. ">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a89f626f2593df8e83da4cdbfe79142f7" title="Unsets the value of the &quot;notes&quot; subelement of this SBML object. ">unsetNotes()</a> </dd>
<dd>
<a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content...">SyntaxChecker::hasExpectedXHTMLSyntax()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="get_all_elements_with_notes_8cpp-example.html#a3">getAllElementsWithNotes.cpp</a>, <a class="el" href="print_notes_8cpp-example.html#a2">printNotes.cpp</a>, and <a class="el" href="_s_b_m_l_http_resolver_example_8cpp-example.html#a18">SBMLHttpResolverExample.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a535a9b7edadff8681c9f5f30b32378a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isSetSBOTerm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this object's "sboTerm" attribute is set. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the "sboTerm" attribute of this SBML object is set, <code>false</code> otherwise. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="print_s_b_m_l_8cpp-example.html#a11">printSBML.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a52efbbf15fe8d48a46b82ad21a667121"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rule::isSetUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>'s "units" attribute is set. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the units for this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is set, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The attribute "units" exists on SBML Level&#160;1 ParameterRule objects only. It is not present in SBML Levels&#160;2 and&#160;3. </dd></dl>

</div>
</div>
<a class="anchor" id="a469f7adb20116ecfd755c6ab43931763"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::isSetUserData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning true or false depending on whether the user data of this element has been set. </p>
<dl class="section user"><dt></dt><dd>The user data associated with an SBML object can be used by an application developer to attach custom information to that object in the model. In case of a deep copy, this attribute will passed as it is. The attribute will never be interpreted by libSBML.</dd></dl>
<dl class="section user"><dt></dt><dd>The user data associated with an SBML object can be used by an application developer to attach custom information to that object in the model. In case of a deep copy, this data will passed as-is. The data attribute will never be interpreted by libSBML.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>boolean, <code>true</code> if this object's user data has been set, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a5fcb43d75b82d54382d2a28eea8e45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rule::isSetVariable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>'s "variable" attribute is set. </p>
<dl class="section user"><dt></dt><dd>In SBML Level&#160;1, the different rule types each have a different name for the attribute holding the reference to the object constituting the left-hand side of the rule. (E.g., for SBML Level&#160;1's SpeciesConcentrationRule the attribute is "species", for CompartmentVolumeRule it is "compartment", etc.) In SBML Levels&#160;2 and&#160;3, the only two types of <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> objects with a left-hand side object reference are <a class="el" href="class_assignment_rule.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule</a> and <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a>, and both of them use the same name for attribute: "variable". In order to make it easier for application developers to work with all Levels of SBML, libSBML uses a uniform name for all such attributes, and it is "variable", regardless of whether Level&#160;1 rules or Level&#160;2&ndash;3 rules are being used.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the "variable" attribute value of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is set, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a64dbf17f774c3969ae77b96afc8a06de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Rule::isSpeciesConcentration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate returning <code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is a SpeciesConcentrationRule or equivalent. </p>
<p>This libSBML method works for SBML Level&#160;1 models (where there is such a thing as an explicit SpeciesConcentrationRule), as well as other Levels of SBML. For Levels above Level&#160;1, this method checks the symbol being affected by the rule, and returns <code>true</code> if the symbol is the identifier of a <a class="el" href="class_species.html" title=" An SBML species  a pool of entities. ">Species</a> object defined in the model.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> is a SpeciesConcentrationRule, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a94ead78ebf80118b1027af5438f22516"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::matchesRequiredSBMLNamespacesForAddition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_base.html">SBase</a> *&#160;</td>
          <td class="paramname"><em>sb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this object's set of XML namespaces are a subset of the given object's XML namespaces. </p>
<dl class="section user"><dt></dt><dd>The <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> object encapsulates SBML Level/Version/namespaces information. It is used to communicate the SBML Level, Version, and (in Level&#160;3) packages used in addition to SBML Level&#160;3 Core. A common approach to using libSBML's <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> facilities is to create an <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> object somewhere in a program once, then hand that object as needed to object constructors that accept <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> as arguments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sb</td><td>an object to compare with respect to namespaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean, <code>true</code> if this object's collection of namespaces is a subset of <code>sb's</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8800aa51fa0ab0a36f47723c3ecf0a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::matchesRequiredSBMLNamespacesForAddition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_base.html">SBase</a> *&#160;</td>
          <td class="paramname"><em>sb</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this object's set of XML namespaces are a subset of the given object's XML namespaces. </p>
<dl class="section user"><dt></dt><dd>The <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> object encapsulates SBML Level/Version/namespaces information. It is used to communicate the SBML Level, Version, and (in Level&#160;3) packages used in addition to SBML Level&#160;3 Core. A common approach to using libSBML's <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> facilities is to create an <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> object somewhere in a program once, then hand that object as needed to object constructors that accept <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> as arguments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sb</td><td>an object to compare with respect to namespaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean, <code>true</code> if this object's collection of namespaces is a subset of <code>sb's</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a936f753a9032913c569dafa3642d8252"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::matchesSBMLNamespaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_base.html">SBase</a> *&#160;</td>
          <td class="paramname"><em>sb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this object's set of XML namespaces are the same as the given object's XML namespaces. </p>
<dl class="section user"><dt></dt><dd>The <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> object encapsulates SBML Level/Version/namespaces information. It is used to communicate the SBML Level, Version, and (in Level&#160;3) packages used in addition to SBML Level&#160;3 Core. A common approach to using libSBML's <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> facilities is to create an <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> object somewhere in a program once, then hand that object as needed to object constructors that accept <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> as arguments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sb</td><td>an object to compare with respect to namespaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean, <code>true</code> if this object's collection of namespaces is the same as <code>sb's</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aac5eb7774ffab4af86ee4cb9468b267d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SBase::matchesSBMLNamespaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_base.html">SBase</a> *&#160;</td>
          <td class="paramname"><em>sb</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this object's set of XML namespaces are the same as the given object's XML namespaces. </p>
<dl class="section user"><dt></dt><dd>The <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> object encapsulates SBML Level/Version/namespaces information. It is used to communicate the SBML Level, Version, and (in Level&#160;3) packages used in addition to SBML Level&#160;3 Core. A common approach to using libSBML's <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> facilities is to create an <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> object somewhere in a program once, then hand that object as needed to object constructors that accept <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> as arguments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sb</td><td>an object to compare with respect to namespaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean, <code>true</code> if this object's collection of namespaces is the same as <code>sb's</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5907f34420c9eaf65c7cf41b0a8b6954"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SBase::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_x_m_l_node.html">XMLNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_x_m_l_error_8h.html#a8a35e0419c4745cae351cfcec58dc710">XMLErrorSeverityOverride_t</a>&#160;</td>
          <td class="paramname"><em>flag</em> = <code><a class="el" href="_x_m_l_error_8h.html#a8a35e0419c4745cae351cfcec58dc710add6235c114a38f4b2b00c4e79761d4c7">LIBSBML_OVERRIDE_DISABLED</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads (initializes) this SBML object by reading from the given <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> to read from.</td></tr>
    <tr><td class="paramname">flag</td><td>an optional flag that determines how how errors are logged during the reading process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd><span class="warning">This method is computationally expensive, because the given node has to be serialized to a string first. Attempting to serialize a large tree structure (e.g., a large <a class="el" href="class_model.html" title=" An SBML model. ">Model</a>) may consume significant computer memory and time.</span> </dd></dl>

</div>
</div>
<a class="anchor" id="ae431ca4044e40e1fe8e0ff4136dce838"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::removeFromParentAndDelete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes this object from its parent. </p>
<p>If the parent was storing this object as a pointer, it is deleted. If not, it is simply cleared (as in <a class="el" href="class_list_of.html" title=" Parent class for libSBML&#39;s &quot;ListOfXYZ&quot; classes. ">ListOf</a> objects). This is a pure virtual method, as every <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> element has different parents, and therefore different methods of removing itself. Will fail (and not delete itself) if it has no parent object. This function is designed to be overridden, but for all objects whose parent is of the class <a class="el" href="class_list_of.html" title=" Parent class for libSBML&#39;s &quot;ListOfXYZ&quot; classes. ">ListOf</a>, the default implementation will work.</p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
</ul>
</dd></dl>

<p>Reimplemented in <a class="el" href="class_model.html#a7d1d8abe17e84f928af67844352c3b5b">Model</a>, <a class="el" href="class_kinetic_law.html#a9fe684ad75989035c60b65eddf7236b2">KineticLaw</a>, <a class="el" href="class_s_base_ref.html#a3c8dc40514170419c31891aea938fab7">SBaseRef</a>, <a class="el" href="class_stoichiometry_math.html#a9e150516fa90eb49f3d798dbe276dd78">StoichiometryMath</a>, <a class="el" href="class_trigger.html#aeea459f44bc7e64e1f1c0c6c2ff863c3">Trigger</a>, <a class="el" href="class_delay.html#af2051cbfafcdbc5d31dd106dd5fe0dbd">Delay</a>, <a class="el" href="class_list_of.html#a67d87d36d7999249f6dd36a1469b0b49">ListOf</a>, <a class="el" href="class_priority.html#abaa0366dc367f2decdc83a66a34985e1">Priority</a>, <a class="el" href="class_model_definition.html#a2cdd3a92e416ccfb76b6e77dcb56689e">ModelDefinition</a>, and <a class="el" href="class_replaced_by.html#a1784ddb78ffa8973af40025767e22239">ReplacedBy</a>.</p>

</div>
</div>
<a class="anchor" id="a40dba8a849dbda05d3f9f42000119dc5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::removeTopLevelAnnotationElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>elementName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>elementURI</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>removeEmpty</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the top-level element within the "annotation" subelement of this SBML object with the given name and optional URI. </p>
<p>SBML places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the SBML specifications for more details.</p>
<p>Calling this method allows a particular annotation element to be removed whilst the remaining annotations remain intact.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elementName</td><td>a string representing the name of the top level annotation element that is to be removed. </td></tr>
    <tr><td class="paramname">elementURI</td><td>an optional string that is used to check both the name and URI of the top level element to be removed. </td></tr>
    <tr><td class="paramname">removeEmpty</td><td>if after removing of the element, the annotation is empty, and the removeEmpty argument is true, the annotation node will be deleted (default).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dae07dbe0754cce77c772d3f19e257101e">LIBSBML_ANNOTATION_NAME_NOT_FOUND</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daa4232e6e18957883269dc412ad7a0479">LIBSBML_ANNOTATION_NS_NOT_FOUND</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a14876bd1b05a660593ed2cf46aece3ee" title="Replaces the given top-level element within the &quot;annotation&quot; subelement of this SBML object and with ...">replaceTopLevelAnnotationElement(const XMLNode *)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a21580da1d75f4782effcc57b45ed37c8" title="Replaces the given top-level element within the &quot;annotation&quot; subelement of this SBML object and with ...">replaceTopLevelAnnotationElement(const std::string&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4df4f196b8e11d08013c436c689465a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SBase::renameMetaIdRefs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oldid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all uses of a given meta identifier attribute value with another value. </p>
<dl class="section user"><dt></dt><dd>In SBML, object "meta" identifiers are of the XML data type <code>ID</code>; the SBML object attribute itself is typically named <code>metaid</code>. All attributes that hold values <em>referring</em> to values of type <code>ID</code> are of the XML data type <code>IDREF</code>. They are also sometimes informally referred to as "metaid refs", in analogy to the SBML-defined type <code>SIdRef</code>.</dd></dl>
<p>This method works by looking at all meta-identifier attribute values, comparing the identifiers to the value of <code>oldid</code>. If any matches are found, the matching identifiers are replaced with <code>newid</code>. The method does <em>not</em> descend into child elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldid</td><td>the old identifier. </td></tr>
    <tr><td class="paramname">newid</td><td>the new identifier. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_port.html#aefdef35fefbf7846d0ba8ad9c3ea4af4">Port</a>, and <a class="el" href="class_graphical_object.html#ac41980f09dbc1950f6b23c6d3b624692">GraphicalObject</a>.</p>

</div>
</div>
<a class="anchor" id="a80385825484be2980ece92154cf78197"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RateRule::renameSIdRefs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oldid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all uses of a given <code>SIdRef</code> type attribute value with another value. </p>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>In SBML, object identifiers are of a data type called <code>SId</code>. In SBML Level&#160;3, an explicit data type called <code>SIdRef</code> was introduced for attribute values that refer to <code>SId</code> values; in previous Levels of SBML, this data type did not exist and attributes were simply described to as "referring to an identifier", but the effective data type was the same as <code>SIdRef</code> in Level&#160;3. These and other methods of libSBML refer to the type <code>SIdRef</code> for all Levels of SBML, even if the corresponding SBML specification did not explicitly name the data type.</p>
<p>This method works by looking at all attributes and (if appropriate) mathematical formulas in MathML content, comparing the referenced identifiers to the value of <code>oldid</code>. If any matches are found, the matching values are replaced with <code>newid</code>. The method does <em>not</em> descend into child elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldid</td><td>the old identifier. </td></tr>
    <tr><td class="paramname">newid</td><td>the new identifier. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_rule.html#a87a288f29d38b00f759e7ac4bf1628fc">Rule</a>.</p>

</div>
</div>
<a class="anchor" id="a340d4cea8317cca28bb14dcf52574e47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Rule::renameUnitSIdRefs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oldid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces all uses of a given <code>UnitSIdRef</code> type attribute value with another value. </p>
<dl class="section user"><dt></dt><dd>In SBML, unit definitions have identifiers of type <code>UnitSId</code>. In SBML Level&#160;3, an explicit data type called <code>UnitSIdRef</code> was introduced for attribute values that refer to <code>UnitSId</code> values; in previous Levels of SBML, this data type did not exist and attributes were simply described to as "referring to a unit identifier", but the effective data type was the same as <code>UnitSIdRef</code> in Level&#160;3. These and other methods of libSBML refer to the type <code>UnitSIdRef</code> for all Levels of SBML, even if the corresponding SBML specification did not explicitly name the data type.</dd></dl>
<p>This method works by looking at all unit identifier attribute values (including, if appropriate, inside mathematical formulas), comparing the referenced unit identifiers to the value of <code>oldid</code>. If any matches are found, the matching values are replaced with <code>newid</code>. The method does <em>not</em> descend into child elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldid</td><td>the old identifier. </td></tr>
    <tr><td class="paramname">newid</td><td>the new identifier. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_s_base.html#aac93855c11d3e29c120fad461d6cab80">SBase</a>.</p>

</div>
</div>
<a class="anchor" id="a14876bd1b05a660593ed2cf46aece3ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::replaceTopLevelAnnotationElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>annotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the given top-level element within the "annotation" subelement of this SBML object and with the annotation element supplied. </p>
<p>SBML places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the SBML specifications for more details.</p>
<p>This method determines the name of the element to be replaced from the annotation argument. Functionally it is equivalent to calling <code> removeTopLevelAnnotationElement(name)</code> followed by calling <code>appendAnnotation(annotation_with_name)</code>, with the exception that the placement of the annotation element remains the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annotation</td><td><a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> representing the replacement top level annotation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>removeTopLevelAnnotationElement(const std::string elementName, const std::string elementURI, bool removeEmpty) </dd>
<dd>
<a class="el" href="class_s_base.html#a21580da1d75f4782effcc57b45ed37c8" title="Replaces the given top-level element within the &quot;annotation&quot; subelement of this SBML object and with ...">replaceTopLevelAnnotationElement(const std::string&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a21580da1d75f4782effcc57b45ed37c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::replaceTopLevelAnnotationElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>annotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the given top-level element within the "annotation" subelement of this SBML object and with the annotation element supplied. </p>
<p>SBML places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the SBML specifications for more details.</p>
<p>This method determines the name of the element to be replaced from the annotation argument. Functionally it is equivalent to calling <code> removeTopLevelAnnotationElement(name)</code> followed by calling <code>appendAnnotation(annotation_with_name)</code>, with the exception that the placement of the annotation element remains the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annotation</td><td>string representing the replacement top level annotation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>removeTopLevelAnnotationElement(const std::string elementName, const std::string elementURI) </dd>
<dd>
<a class="el" href="class_s_base.html#a14876bd1b05a660593ed2cf46aece3ee" title="Replaces the given top-level element within the &quot;annotation&quot; subelement of this SBML object and with ...">replaceTopLevelAnnotationElement(const XMLNode*)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a11d9c02a3690d9a13362835ef0133125"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::setAnnotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>annotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of the "annotation" subelement of this SBML object. </p>
<p>The content of <code>annotation</code> is copied, and any previous content of this object's "annotation" subelement is deleted.</p>
<p>Whereas the <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> "notes" subelement is a container for content to be shown directly to humans, the "annotation" element is a container for optional software-generated content <em>not</em> meant to be shown to humans. Every object derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> can have its own value for "annotation". The element's content type is <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls" target="_blank">XML type "any"</a>, allowing essentially arbitrary well-formed XML data content.</p>
<p>SBML places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the SBML specifications for more details.</p>
<p>Call this method will result in any existing content of the "annotation" subelement to be discarded. Unless you have taken steps to first copy and reconstitute any existing annotations into the <code>annotation</code> that is about to be assigned, it is likely that performing such wholesale replacement is unfriendly towards other software applications whose annotations are discarded. An alternative may be to use <a class="el" href="class_s_base.html#accc96fb06a79df769eb3669e090771e5" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object. ">SBase::appendAnnotation(const XMLNode* annotation)</a> or <a class="el" href="class_s_base.html#a118148398f5c626bf9697887296f97b8" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object. ">SBase::appendAnnotation(const std::string&amp; annotation)</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annotation</td><td>an XML structure that is to be used as the new content of the "annotation" subelement of this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. This particular function only does one thing irrespective of user input or object state, and thus will only return a single value: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#adbff50c6c73c044a5c8e29e6b5dcefc6" title="Returns the content of the &quot;annotation&quot; subelement of this object as a character string. ">getAnnotationString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a279ce55f23330dc6bb0231774adfc42b" title="Predicate returning true if this object&#39;s &quot;annotation&quot; subelement exists and has content. ">isSetAnnotation()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a75b1541bd854ad7edfe0aff79ab3231f" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object. ">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#accc96fb06a79df769eb3669e090771e5" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object. ">appendAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a118148398f5c626bf9697887296f97b8" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object. ">appendAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a9121d6a4f7401fe957cc75647a1e95ed" title="Unsets the value of the &quot;annotation&quot; subelement of this SBML object. ">unsetAnnotation()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_model.html#a440da667491f2a78fa305460a63471a5">Model</a>, and <a class="el" href="class_species_reference.html#a53cdf5197ae654bad28316f3cea03f69">SpeciesReference</a>.</p>

</div>
</div>
<a class="anchor" id="a75b1541bd854ad7edfe0aff79ab3231f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::setAnnotation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>annotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of the "annotation" subelement of this SBML object. </p>
<p>The content of <code>annotation</code> is copied, and any previous content of this object's "annotation" subelement is deleted.</p>
<p>Whereas the <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> "notes" subelement is a container for content to be shown directly to humans, the "annotation" element is a container for optional software-generated content <em>not</em> meant to be shown to humans. Every object derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> can have its own value for "annotation". The element's content type is <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls" target="_blank">XML type "any"</a>, allowing essentially arbitrary well-formed XML data content.</p>
<p>SBML places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the SBML specifications for more details.</p>
<p>Call this method will result in any existing content of the "annotation" subelement to be discarded. Unless you have taken steps to first copy and reconstitute any existing annotations into the <code>annotation</code> that is about to be assigned, it is likely that performing such wholesale replacement is unfriendly towards other software applications whose annotations are discarded. An alternative may be to use <a class="el" href="class_s_base.html#accc96fb06a79df769eb3669e090771e5" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object. ">SBase::appendAnnotation(const XMLNode* annotation)</a> or <a class="el" href="class_s_base.html#a118148398f5c626bf9697887296f97b8" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object. ">SBase::appendAnnotation(const std::string&amp; annotation)</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annotation</td><td>an XML string that is to be used as the content of the "annotation" subelement of this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#adbff50c6c73c044a5c8e29e6b5dcefc6" title="Returns the content of the &quot;annotation&quot; subelement of this object as a character string. ">getAnnotationString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a279ce55f23330dc6bb0231774adfc42b" title="Predicate returning true if this object&#39;s &quot;annotation&quot; subelement exists and has content. ">isSetAnnotation()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a11d9c02a3690d9a13362835ef0133125" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object. ">setAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#accc96fb06a79df769eb3669e090771e5" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object. ">appendAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a118148398f5c626bf9697887296f97b8" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object. ">appendAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a9121d6a4f7401fe957cc75647a1e95ed" title="Unsets the value of the &quot;annotation&quot; subelement of this SBML object. ">unsetAnnotation()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_model.html#a99d849cf4973bd4eef2dc69a16c69a75">Model</a>, and <a class="el" href="class_species_reference.html#ad133502b17eca429ec748537b6bb875a">SpeciesReference</a>.</p>

</div>
</div>
<a class="anchor" id="aa78ef1ca7e89aa9be18302622aad221f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SBase::setElementText </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When overridden allows <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> elements to use the text included in between the elements tags. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>the text string found between the element tags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad001eb0d7da33033a2b33e5c6665b723"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Rule::setFormula </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>formula</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the "math" subelement of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> to an expression in text-string form. </p>
<p>This is equivalent to <a class="el" href="class_rule.html#a524690d35b8bf6177a2c9c144d257fa7" title="Sets the &quot;math&quot; subelement of this Rule to a copy of the given ASTNode. ">setMath(const ASTNode* math)</a>. The provision of using text-string formulas is retained for easier SBML Level&#160;1 compatibility. The formula is converted to an <a class="el" href="class_a_s_t_node.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode</a> internally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">formula</td><td>a mathematical formula in text-string form.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The attribute "formula" is specific to SBML Level&#160;1; in higher Levels of SBML, it has been replaced with a subelement named "math". However, libSBML provides a unified interface to the underlying math expression and this method can be used for models of all Levels of SBML.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_rule.html#a524690d35b8bf6177a2c9c144d257fa7" title="Sets the &quot;math&quot; subelement of this Rule to a copy of the given ASTNode. ">setMath(const ASTNode* math)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac9f9a3703526cd1fb929778df3050692"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::setId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of the "id" attribute of this SBML object. </p>
<dl class="section user"><dt></dt><dd>The string <code>sid</code> is copied.</dd></dl>
<dl class="section user"><dt></dt><dd>The identifier given by an object's "id" attribute value is used to identify the object within the SBML model definition. Other objects can refer to the component using this identifier. The data type of "id" is always <code>SId</code> or a type derived from that, such as <code>UnitSId</code>, depending on the object in question. All data types are defined as follows: <pre style="margin-left: 2em; border: none; font-weight: bold; color: black">
     letter ::= 'a'..'z','A'..'Z'
     digit  ::= '0'..'9'
     idChar ::= letter | digit | '_'
     SId    ::= ( letter | '_' ) idChar*
   </pre> The characters <code>(</code> and <code>)</code> are used for grouping, the character <code>*</code> "zero or more times", and the character <code>|</code> indicates logical "or". The equality of SBML identifiers is determined by an exact character sequence match; i.e., comparisons must be performed in a case-sensitive manner. This applies to all uses of <code>SId</code>, <code>SIdRef</code>, and derived types.</dd></dl>
<p>Users need to be aware of some important API issues that are the result of the history of SBML and libSBML. Prior to SBML Level&#160;3 Version&#160;2, SBML defined "id" and "name" attributes on only a subset of SBML objects. To simplify the work of programmers, libSBML's API provided get, set, check, and unset on the <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> object class itself instead of on individual subobject classes. This made the get/set/etc. methods uniformly available on all objects in the libSBML API. LibSBML simply returned empty strings or otherwise did not act when the methods were applied to SBML objects that were not defined by the SBML specification to have "id" or "name" attributes. Additional complications arose with the rule and assignment objects: <a class="el" href="class_initial_assignment.html" title=" An SBML initial assignment, evaluated once only. ">InitialAssignment</a>, <a class="el" href="class_event_assignment.html" title=" An assignment to a variable by an SBML event. ">EventAssignment</a>, <a class="el" href="class_assignment_rule.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule</a>, and <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a>. In early versions of SBML, the rule object hierarchy was different, and in addition, then as now, they possess different attributes: "variable" (for the rules and event assignments), "symbol" (for initial assignments), or neither (for algebraic rules). Prior to SBML Level&#160;3 Version&#160;2, <a class="el" href="class_s_base.html#a8bd7cb0de43db3680bd1eeb30022fcd3" title="Returns the value of the &quot;id&quot; attribute of this SBML object, if it has one, or the &quot;variable&quot; attribu...">getId()</a> would always return an empty string, and <a class="el" href="class_s_base.html#a20e059dca5f0e97bdc7dc2e8fd3e4c35" title="Predicate returning true if a call to getId() returns a non-empty string. ">isSetId()</a> would always return <code>false</code> for objects of these classes.</p>
<p>With the addition of "id" and "name" attributes on <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> in Level&#160;3 Version&#160;2, it became necessary to introduce a new way to interact with the attributes more consistently in libSBML to avoid breaking backward compatibility in the behavior of the original "id" methods. For this reason, libSBML provides four functions (<a class="el" href="class_s_base.html#acd5e8dc937c46ace3af5125c8674c199" title="Returns the value of the &quot;id&quot; attribute of this SBML object. ">getIdAttribute()</a>, <a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object. ">setIdAttribute()</a>, <a class="el" href="class_s_base.html#ad201f20c9527cff5daf5d05bf49aac8c" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set. ">isSetIdAttribute()</a>, and <a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object. ">unsetIdAttribute()</a>) that always act on the actual "id" attribute inherited from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a>, regardless of the object's type. <b>These new methods should be used instead of the older <a class="el" href="class_s_base.html#a8bd7cb0de43db3680bd1eeb30022fcd3" title="Returns the value of the &quot;id&quot; attribute of this SBML object, if it has one, or the &quot;variable&quot; attribu...">getId()</a>/setId()/etc. methods</b> unless the old behavior is somehow necessary. Regardless of the Level and Version of the SBML, these functions allow client applications to use more generalized code in some situations (for instance, when manipulating objects that are all known to have identifiers). If the object in question does not posess an "id" attribute according to the SBML specification for the Level and Version in use, libSBML will not allow the identifier to be set, nor will it read or write "id" attributes for those objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the string to use as the identifier of this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#acd5e8dc937c46ace3af5125c8674c199" title="Returns the value of the &quot;id&quot; attribute of this SBML object. ">getIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object. ">setIdAttribute(const std::string&amp; sid)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#ad201f20c9527cff5daf5d05bf49aac8c" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set. ">isSetIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object. ">unsetIdAttribute()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_layout.html#a3448f07e3102e4c88c056e87f2643e3e">Layout</a>, <a class="el" href="class_compartment.html#adcf670534ab78dc0f42140a399f91935">Compartment</a>, <a class="el" href="class_species.html#ac1f8c4724b30a8a060056dfe61528480">Species</a>, <a class="el" href="class_model.html#a9f5805553e7d385ced27c4065fa190fe">Model</a>, <a class="el" href="class_event.html#a1ce30dd3deb24348c0d8d0b7251dd6b6">Event</a>, <a class="el" href="class_reaction.html#a40d7d4448dcf3682e40636a49f45f69f">Reaction</a>, <a class="el" href="class_parameter.html#ae159bda5492c97ef1ee62cf184f49e1d">Parameter</a>, <a class="el" href="class_unit_definition.html#a6dfedd750842ff04e2dde978aa33c1a5">UnitDefinition</a>, <a class="el" href="class_render_information_base.html#a2165e5b67627a125b3421bfaac982fb7">RenderInformationBase</a>, <a class="el" href="class_color_definition.html#ad44c2676d6cc97fdc434a8a9fb2d09b4">ColorDefinition</a>, <a class="el" href="class_gradient_base.html#af6a17c206608fd36f06e63bd8c2101a0">GradientBase</a>, <a class="el" href="class_group.html#ace4b70102e43ab0f8bc062642719e469">Group</a>, <a class="el" href="class_input.html#a58280a67168d7d467907eb03a86b69da">Input</a>, <a class="el" href="class_graphical_primitive1_d.html#a2c1618200dd567b4dc1c82252ee5ac04">GraphicalPrimitive1D</a>, <a class="el" href="class_function_definition.html#ad1ea568b801d10c6905166f9092a681c">FunctionDefinition</a>, <a class="el" href="class_submodel.html#ac26090f1eff3814381804e3761687fa2">Submodel</a>, <a class="el" href="class_objective.html#a0167b9a7a0b15cef34522d6c09a3e245">Objective</a>, <a class="el" href="class_qualitative_species.html#a150e945cc098baa098ed8c8b6d4d06f5">QualitativeSpecies</a>, <a class="el" href="class_output.html#a187d963c3d00617e49144a0f0f98b457">Output</a>, <a class="el" href="class_gene_product_association.html#a32321dc0989edaa6038d52a231adf78b">GeneProductAssociation</a>, <a class="el" href="class_flux_objective.html#add4419a8a622f93677b2914b6fa347a8">FluxObjective</a>, <a class="el" href="class_dimensions.html#aa061b33e451431b8cf44ad40f5f40177">Dimensions</a>, <a class="el" href="class_gene_product.html#a35529f3d9ef83df01b8d304f3c8bfb58">GeneProduct</a>, <a class="el" href="class_image.html#ab42914f4b19629bbb1d5950de198738e">Image</a>, <a class="el" href="class_line_ending.html#a0eacae34c20da16074913acb0060668f">LineEnding</a>, <a class="el" href="class_graphical_object.html#a9111014eaaac093f844f483513ca4159">GraphicalObject</a>, <a class="el" href="class_compartment_type.html#a57e0dae1d3161c217e7b682d0cca5d00">CompartmentType</a>, <a class="el" href="class_species_type.html#a9d728c1b32339676da064d04636e6001">SpeciesType</a>, <a class="el" href="class_transition.html#a369f6db401f51aa02ba5e9d1830410c7">Transition</a>, <a class="el" href="class_outward_binding_site.html#a91c3366517e9b4e847f9f3cab13aea73">OutwardBindingSite</a>, <a class="el" href="class_member.html#a1ad0d6960adcf73a041e7f4fc2efe9cb">Member</a>, <a class="el" href="class_point.html#a4eb592d99601f924f7a4f4c27f78a631">Point</a>, <a class="el" href="class_style.html#a7662cfc9a4db5ef2d4f917e6f9568b19">Style</a>, <a class="el" href="class_simple_species_reference.html#a0dd1592deacb767a8a41fb8551714c0c">SimpleSpeciesReference</a>, <a class="el" href="class_flux_bound.html#a34a5cc84a97a906f5f4c191dc7771a2c">FluxBound</a>, <a class="el" href="class_list_of_members.html#a5a53742760fd6dc36d7fffe3604eb7ef">ListOfMembers</a>, <a class="el" href="class_gene_product_ref.html#a276783d55020dcd073501ddf57314132">GeneProductRef</a>, <a class="el" href="class_sub_list_of_species_features.html#a07f20d03896e0b077c3a10a0e8dbe94b">SubListOfSpeciesFeatures</a>, <a class="el" href="class_external_model_definition.html#a02ef309367a118e03c371941971f5d9c">ExternalModelDefinition</a>, <a class="el" href="class_bounding_box.html#a4dd3eb497a63953e56dbdc50cfaf9dfd">BoundingBox</a>, <a class="el" href="class_multi_species_type.html#a08160cd30b1ce65b96df2272d532d3a5">MultiSpeciesType</a>, <a class="el" href="class_species_feature.html#a4292527850a05daf668c5df0d40b37ce">SpeciesFeature</a>, <a class="el" href="class_port.html#a39c95e6cfeab647e039befb310dfb6c6">Port</a>, <a class="el" href="class_species_feature_type.html#a0798a02962ee1991b1d995554878e3b6">SpeciesFeatureType</a>, <a class="el" href="class_species_type_instance.html#a291f41fa4ba10498a13a384fccda40ec">SpeciesTypeInstance</a>, <a class="el" href="class_species_type_component_map_in_product.html#a409445c6b1cfcd53edeee74c2f8ce4de">SpeciesTypeComponentMapInProduct</a>, <a class="el" href="class_species_type_component_index.html#a60ac570cf4c26d1c811e9276800ed3de">SpeciesTypeComponentIndex</a>, <a class="el" href="class_deletion.html#a99c7786fa5cdf7ab1c760feb8c089a71">Deletion</a>, <a class="el" href="class_gene_association.html#ae1a0f8b471ac61ccbd3f14d10998eac3">GeneAssociation</a>, <a class="el" href="class_in_species_type_bond.html#a4eec55e5e63166affcb26c7bd64da6cb">InSpeciesTypeBond</a>, <a class="el" href="class_possible_species_feature_value.html#a5a4fe8b22ed625abbd816238f0a662fe">PossibleSpeciesFeatureValue</a>, and <a class="el" href="class_compartment_reference.html#a07821fa85fa5cbc86c4f6e3388b26da0">CompartmentReference</a>.</p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rename_s_id_8cpp-example.html#a10">renameSId.cpp</a>, and <a class="el" href="set_id_from_names_8cpp-example.html#a8">setIdFromNames.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a8a342a0f8387842fb6700c50c4c43344"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::setIdAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of the "id" attribute of this SBML object. </p>
<dl class="section user"><dt></dt><dd>The string <code>sid</code> is copied.</dd></dl>
<dl class="section user"><dt></dt><dd>The identifier given by an object's "id" attribute value is used to identify the object within the SBML model definition. Other objects can refer to the component using this identifier. The data type of "id" is always <code>SId</code> or a type derived from that, such as <code>UnitSId</code>, depending on the object in question. All data types are defined as follows: <pre style="margin-left: 2em; border: none; font-weight: bold; color: black">
     letter ::= 'a'..'z','A'..'Z'
     digit  ::= '0'..'9'
     idChar ::= letter | digit | '_'
     SId    ::= ( letter | '_' ) idChar*
   </pre> The characters <code>(</code> and <code>)</code> are used for grouping, the character <code>*</code> "zero or more times", and the character <code>|</code> indicates logical "or". The equality of SBML identifiers is determined by an exact character sequence match; i.e., comparisons must be performed in a case-sensitive manner. This applies to all uses of <code>SId</code>, <code>SIdRef</code>, and derived types.</dd></dl>
<p>Users need to be aware of some important API issues that are the result of the history of SBML and libSBML. Prior to SBML Level&#160;3 Version&#160;2, SBML defined "id" and "name" attributes on only a subset of SBML objects. To simplify the work of programmers, libSBML's API provided get, set, check, and unset on the <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> object class itself instead of on individual subobject classes. This made the get/set/etc. methods uniformly available on all objects in the libSBML API. LibSBML simply returned empty strings or otherwise did not act when the methods were applied to SBML objects that were not defined by the SBML specification to have "id" or "name" attributes. Additional complications arose with the rule and assignment objects: <a class="el" href="class_initial_assignment.html" title=" An SBML initial assignment, evaluated once only. ">InitialAssignment</a>, <a class="el" href="class_event_assignment.html" title=" An assignment to a variable by an SBML event. ">EventAssignment</a>, <a class="el" href="class_assignment_rule.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule</a>, and <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a>. In early versions of SBML, the rule object hierarchy was different, and in addition, then as now, they possess different attributes: "variable" (for the rules and event assignments), "symbol" (for initial assignments), or neither (for algebraic rules). Prior to SBML Level&#160;3 Version&#160;2, <a class="el" href="class_s_base.html#a8bd7cb0de43db3680bd1eeb30022fcd3" title="Returns the value of the &quot;id&quot; attribute of this SBML object, if it has one, or the &quot;variable&quot; attribu...">getId()</a> would always return an empty string, and <a class="el" href="class_s_base.html#a20e059dca5f0e97bdc7dc2e8fd3e4c35" title="Predicate returning true if a call to getId() returns a non-empty string. ">isSetId()</a> would always return <code>false</code> for objects of these classes.</p>
<p>With the addition of "id" and "name" attributes on <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> in Level&#160;3 Version&#160;2, it became necessary to introduce a new way to interact with the attributes more consistently in libSBML to avoid breaking backward compatibility in the behavior of the original "id" methods. For this reason, libSBML provides four functions (<a class="el" href="class_s_base.html#acd5e8dc937c46ace3af5125c8674c199" title="Returns the value of the &quot;id&quot; attribute of this SBML object. ">getIdAttribute()</a>, <a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object. ">setIdAttribute()</a>, <a class="el" href="class_s_base.html#ad201f20c9527cff5daf5d05bf49aac8c" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set. ">isSetIdAttribute()</a>, and <a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object. ">unsetIdAttribute()</a>) that always act on the actual "id" attribute inherited from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a>, regardless of the object's type. <b>These new methods should be used instead of the older <a class="el" href="class_s_base.html#a8bd7cb0de43db3680bd1eeb30022fcd3" title="Returns the value of the &quot;id&quot; attribute of this SBML object, if it has one, or the &quot;variable&quot; attribu...">getId()</a>/setId()/etc. methods</b> unless the old behavior is somehow necessary. Regardless of the Level and Version of the SBML, these functions allow client applications to use more generalized code in some situations (for instance, when manipulating objects that are all known to have identifiers). If the object in question does not posess an "id" attribute according to the SBML specification for the Level and Version in use, libSBML will not allow the identifier to be set, nor will it read or write "id" attributes for those objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the string to use as the identifier of this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#acd5e8dc937c46ace3af5125c8674c199" title="Returns the value of the &quot;id&quot; attribute of this SBML object. ">getIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object. ">setIdAttribute(const std::string&amp; sid)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#ad201f20c9527cff5daf5d05bf49aac8c" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set. ">isSetIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object. ">unsetIdAttribute()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9f59a6ad607c2fc32a8c14f30fce1a9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Rule::setL1TypeCode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the SBML Level&#160;1 type code for this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the SBML Level&#160;1 type code for this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>. The allowable values are <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfeaf52d2bab1bdc55a5ad62cd6d42850067">SBML_COMPARTMENT_VOLUME_RULE</a>, <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfeabe09824edb95e4b4fa6967639eb4f567">SBML_PARAMETER_RULE</a>, and <a class="el" href="_s_b_m_l_type_codes_8h.html#aa283dddfd7671179362b2f38e2938cfea5bdf0d6902889e1891aaaf3fb083145e">SBML_SPECIES_CONCENTRATION_RULE</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a> if given <code>type</code> value is not one of the above. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a524690d35b8bf6177a2c9c144d257fa7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Rule::setMath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_s_t_node.html">ASTNode</a> *&#160;</td>
          <td class="paramname"><em>math</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the "math" subelement of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> to a copy of the given <a class="el" href="class_a_s_t_node.html" title=" Abstract Syntax Tree (AST) representation of a mathematical expression. ">ASTNode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">math</td><td>the AST structure of the mathematical formula.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The subelement "math" is present in SBML Levels&#160;2 and&#160;3. In SBML Level&#160;1, the equivalent construct is the attribute named "formula". LibSBML provides a unified interface to the underlying math expression and this method can be used for models of all Levels of SBML.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_rule.html#ad001eb0d7da33033a2b33e5c6665b723" title="Sets the &quot;math&quot; subelement of this Rule to an expression in text-string form. ">setFormula(const std::string&amp; formula)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a050779a94ecdb2d73d7edfef73bc1e55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::setMetaId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>metaid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of the meta-identifier attribute of this SBML object. </p>
<dl class="section user"><dt></dt><dd>The optional attribute named "metaid", present on every major SBML component type, is for supporting metadata annotations using RDF (<a href="http://www.w3.org/RDF/">Resource Description Format</a>). The attribute value has the data type <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a>, the XML identifier type, which means each "metaid" value must be globally unique within an SBML file. The latter point is important, because the uniqueness criterion applies across <em>any</em> attribute with type <code>ID</code> anywhere in the file, not just the "metaid" attribute used by SBML&mdash;something to be aware of if your application-specific XML content inside the "annotation" subelement happens to use the XML <code>ID</code> type. Although SBML itself specifies the use of <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a> only for the "metaid" attribute, SBML-compatible applications should be careful if they use XML <code>ID</code>'s in XML portions of a model that are not defined by SBML, such as in the application-specific content of the "annotation" subelement. Finally, note that LibSBML does not provide an explicit XML <code>ID</code> data type; it uses ordinary character strings, which is easier for applications to support.</dd></dl>
<p>The string <code>metaid</code> is copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metaid</td><td>the identifier string to use as the value of the "metaid" attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a2880c1c6a2df519371637a9234ed68a4" title="Returns the value of the &quot;metaid&quot; attribute of this SBML object. ">getMetaId()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a24fc99c2ba9431594a78b78536699a0e" title="Predicate returning true if this object&#39;s &quot;metaid&quot; attribute is set. ">isSetMetaId()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="adding_evidence_codes_1_8cpp-example.html#a10">addingEvidenceCodes_1.cpp</a>, and <a class="el" href="adding_evidence_codes_2_8cpp-example.html#a10">addingEvidenceCodes_2.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aef0ea49f9a3ad67d72edb2c1cf92ad82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::setModelHistory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_model_history.html">ModelHistory</a> *&#160;</td>
          <td class="paramname"><em>history</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <a class="el" href="class_model_history.html" title=" MIRIAM-compliant data about a model&#39;s history. ">ModelHistory</a> of this object. </p>
<p>The content of <code>history</code> is copied, and this object's existing model history content is deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">history</td><td><a class="el" href="class_model_history.html" title=" MIRIAM-compliant data about a model&#39;s history. ">ModelHistory</a> of this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In SBML Level&#160;2, model history annotations were only permitted on the <a class="el" href="class_model.html" title=" An SBML model. ">Model</a> element. In SBML Level&#160;3, they are permitted on all SBML components derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="add_model_history_8cpp-example.html#a19">addModelHistory.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a1531f729b16689aba3fb7f3567202a7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::setName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of the "name" attribute of this SBML object. </p>
<dl class="section user"><dt></dt><dd></dd></dl>
<p>The string in <code>name</code> is copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the new name for the SBML object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a> </li>
</ul>
</dd></dl>

<p>Reimplemented in <a class="el" href="class_layout.html#ad577378f40dab2c6aa5ff347a8c76b74">Layout</a>, <a class="el" href="class_compartment.html#a1d065d2a063a313bf19b50a266940c21">Compartment</a>, <a class="el" href="class_species.html#a6c3d6dd31a1dba80c21b1dbcc1d8d30a">Species</a>, <a class="el" href="class_model.html#aa9f4b34956328dece618208f1f61f8e8">Model</a>, <a class="el" href="class_event.html#af1aafdffb3d1969cd0f6be8c93e1d066">Event</a>, <a class="el" href="class_reaction.html#a27417ed3d01cc64642d1f5dfbc1537ad">Reaction</a>, <a class="el" href="class_parameter.html#a2dd95fab703bf22868b5495712f6c9c3">Parameter</a>, <a class="el" href="class_unit_definition.html#a185893661f6b8c2eec820be41e7c47ff">UnitDefinition</a>, <a class="el" href="class_render_information_base.html#ab4c15cbd303315f4efbd2ccd8607b3ea">RenderInformationBase</a>, <a class="el" href="class_color_definition.html#a650dc71eef4b451810e35e7ad57b4bd7">ColorDefinition</a>, <a class="el" href="class_gradient_base.html#a47641d95dbec17e052aa1ec0e3155148">GradientBase</a>, <a class="el" href="class_group.html#ac24ce84e8ef8e1de7294bfda5793b5ba">Group</a>, <a class="el" href="class_input.html#a7a949e1389b647a20770bbd68f8825ed">Input</a>, <a class="el" href="class_submodel.html#afa12dad44828cae29525bbfa772305d1">Submodel</a>, <a class="el" href="class_qualitative_species.html#adbfdfe06ac14097cabbcc085fcc10309">QualitativeSpecies</a>, <a class="el" href="class_output.html#aa418c7d5fc6cd750921c42eb6a19c832">Output</a>, <a class="el" href="class_function_definition.html#a78ace3d92393d08650e2e5ff8907a5a0">FunctionDefinition</a>, <a class="el" href="class_objective.html#a8ce0ae5e1b61b8f06d6fee623b140e5c">Objective</a>, <a class="el" href="class_gene_product_association.html#a5b40def0f33bd60494ed53c00aff3077">GeneProductAssociation</a>, <a class="el" href="class_outward_binding_site.html#a2108455c838a73b93678f1032c8f68de">OutwardBindingSite</a>, <a class="el" href="class_flux_objective.html#a75075b249c53f9942bb58282510d0d9b">FluxObjective</a>, <a class="el" href="class_gene_product.html#affc141586a789f5cab545d8a8293c3d9">GeneProduct</a>, <a class="el" href="class_flux_bound.html#a5eea411a945c6d0b829eafa0a30dfbdd">FluxBound</a>, <a class="el" href="class_transformation.html#a8016b3652527de00a30edb16f054427c">Transformation</a>, <a class="el" href="class_compartment_type.html#aa7b2342493e0393bc57b53be880880e4">CompartmentType</a>, <a class="el" href="class_sub_list_of_species_features.html#a70d9b12d4e8702a60d36d80914d81323">SubListOfSpeciesFeatures</a>, <a class="el" href="class_gene_product_ref.html#ae7bc0695d1ebf73799c07669d9a1cdfd">GeneProductRef</a>, <a class="el" href="class_species_type.html#a94009657f921728b0b01a3a303875d06">SpeciesType</a>, <a class="el" href="class_member.html#a6d084cba4ac24ce53fbd4445b8433313">Member</a>, <a class="el" href="class_transition.html#af9aa9d4d2c1c3513048fecfa82e0816c">Transition</a>, <a class="el" href="class_style.html#ae4286717d30d86d608ed83dd46085e95">Style</a>, <a class="el" href="class_list_of_members.html#a772bdc795855213ca491e9e5d03e2d56">ListOfMembers</a>, <a class="el" href="class_external_model_definition.html#a0fb0f0deb6bea053f830ae06c68a275d">ExternalModelDefinition</a>, <a class="el" href="class_simple_species_reference.html#a9dbb10fa6c343f520d5214d7b13a6b3d">SimpleSpeciesReference</a>, <a class="el" href="class_multi_species_type.html#a57cc29870155baf355efcdd1c2ca2629">MultiSpeciesType</a>, <a class="el" href="class_species_feature.html#a4630dc428814d6992fb39bb6ba1cb3fd">SpeciesFeature</a>, <a class="el" href="class_species_type_component_map_in_product.html#a3df343b2dbc4a855f8ac98693a8a8874">SpeciesTypeComponentMapInProduct</a>, <a class="el" href="class_species_feature_type.html#a785f99fb6881449e6326d559d221fec5">SpeciesFeatureType</a>, <a class="el" href="class_species_type_instance.html#a9d576b832889845888058c3902ddd6f1">SpeciesTypeInstance</a>, <a class="el" href="class_deletion.html#ab05ca65610c8aea2ae6bb9849baae9ae">Deletion</a>, <a class="el" href="class_species_type_component_index.html#a5e88ff908b0df9274633b6bf337e61d2">SpeciesTypeComponentIndex</a>, <a class="el" href="class_port.html#af325b7b99cc219de482f72613a21a305">Port</a>, <a class="el" href="class_in_species_type_bond.html#ab4eb64d87e0ab9e6e9ddd08dae79f3a7">InSpeciesTypeBond</a>, <a class="el" href="class_possible_species_feature_value.html#aeaa0eb43bd2f673d53b8441295332901">PossibleSpeciesFeatureValue</a>, and <a class="el" href="class_compartment_reference.html#a9554ce5720cb196f743fbb27a873d365">CompartmentReference</a>.</p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="set_names_from_ids_8cpp-example.html#a8">setNamesFromIds.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a7a6dc5a02be520ea43c7cf71c5062c71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::setNamespaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_x_m_l_namespaces.html">XMLNamespaces</a> *&#160;</td>
          <td class="paramname"><em>xmlns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the namespaces relevant of this SBML object. </p>
<p>The content of <code>xmlns</code> is copied, and this object's existing namespace content is deleted.</p>
<p>The <a class="el" href="class_s_b_m_l_namespaces.html" title=" Set of SBML Level + Version + namespace triples. ">SBMLNamespaces</a> object encapsulates SBML Level/Version/namespaces information. It is used to communicate the SBML Level, Version, and (in Level&#160;3) packages used in addition to SBML Level&#160;3 Core.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xmlns</td><td>the namespaces to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a611a4bd98a4e32e3573980b2481ce77e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::setNotes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_x_m_l_node.html">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>notes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of the "notes" subelement of this SBML object. </p>
<p>The content of <code>notes</code> is copied, and any existing content of this object's "notes" subelement is deleted.</p>
<p>The optional SBML element named "notes", present on every major SBML component type, is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</p>
<p>The format of "notes" elements must be <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. To help verify the formatting of "notes" content, libSBML provides the static utility method <a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content...">SyntaxChecker::hasExpectedXHTMLSyntax()</a>; however, readers are urged to consult the appropriate <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specification document</a> for the Level and Version of their model for more in-depth explanations. The SBML Level&#160;2 and&#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">notes</td><td>an XML structure that is to be used as the content of the "notes" subelement of this object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a6eee96ee206a55837c0d7b936f20f14d" title="Returns the content of the &quot;notes&quot; subelement of this object as a string. ">getNotesString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#aeff0554efc75440b5375b35a4d188ea0" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content. ">isSetNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a478ad1e0e2bb2dc27a9de6ab9bac4bf2" title="Sets the value of the &quot;notes&quot; subelement of this SBML object to a copy of the string notes...">setNotes(const std::string&amp; notes, bool addXHTMLMarkup)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adb8c800163c108a27880bd644d7767ad" title="Appends the given notes to the &quot;notes&quot; subelement of this object. ">appendNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a33da5a2b0b03cbe6af69730869e35212" title="Appends the given notes to the &quot;notes&quot; subelement of this object. ">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a89f626f2593df8e83da4cdbfe79142f7" title="Unsets the value of the &quot;notes&quot; subelement of this SBML object. ">unsetNotes()</a> </dd>
<dd>
<a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content...">SyntaxChecker::hasExpectedXHTMLSyntax()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="create_example_s_b_m_l_8cpp-example.html#a53">createExampleSBML.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a478ad1e0e2bb2dc27a9de6ab9bac4bf2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::setNotes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>notes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addXHTMLMarkup</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of the "notes" subelement of this SBML object to a copy of the string <code>notes</code>. </p>
<p>The content of <code>notes</code> is copied, and any existing content of this object's "notes" subelement is deleted.</p>
<p>The optional SBML element named "notes", present on every major SBML component type, is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</p>
<p>The format of "notes" elements must be <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. To help verify the formatting of "notes" content, libSBML provides the static utility method <a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content...">SyntaxChecker::hasExpectedXHTMLSyntax()</a>; however, readers are urged to consult the appropriate <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specification document</a> for the Level and Version of their model for more in-depth explanations. The SBML Level&#160;2 and&#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<p>The following code illustrates a very simple way of setting the notes using this method. Here, the object being annotated is the whole SBML document, but that is for illustration purposes only; you could of course use this same approach to annotate any other SBML component. </p><div class="fragment"><div class="line"><a class="code" href="class_s_b_m_l_document.html">SBMLDocument</a>* s = <span class="keyword">new</span> <a class="code" href="class_s_b_m_l_document.html">SBMLDocument</a>(3, 1);</div><div class="line">s-&gt;<a class="code" href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e">setNotes</a>(<span class="stringliteral">&quot;&lt;body xmlns=&#39;http://www.w3.org/1999/xhtml&#39;&gt;&lt;p&gt;here is my note&lt;/p&gt;&lt;/body&gt;&quot;</span>);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">notes</td><td>an XML string that is to be used as the content of the "notes" subelement of this object.</td></tr>
    <tr><td class="paramname">addXHTMLMarkup</td><td>a boolean indicating whether to wrap the contents of the <code>notes</code> argument with XHTML paragraph (<code>&lt;p&gt;</code>) tags. This is appropriate when the string in <code>notes</code> does not already containg the appropriate XHTML markup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da9fb84324c51e63460901490374a4ea82">LIBSBML_INVALID_OBJECT</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a6eee96ee206a55837c0d7b936f20f14d" title="Returns the content of the &quot;notes&quot; subelement of this object as a string. ">getNotesString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#aeff0554efc75440b5375b35a4d188ea0" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content. ">isSetNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e" title="Sets the value of the &quot;notes&quot; subelement of this SBML object. ">setNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adb8c800163c108a27880bd644d7767ad" title="Appends the given notes to the &quot;notes&quot; subelement of this object. ">appendNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a33da5a2b0b03cbe6af69730869e35212" title="Appends the given notes to the &quot;notes&quot; subelement of this object. ">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a89f626f2593df8e83da4cdbfe79142f7" title="Unsets the value of the &quot;notes&quot; subelement of this SBML object. ">unsetNotes()</a> </dd>
<dd>
<a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content...">SyntaxChecker::hasExpectedXHTMLSyntax()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a37287e48bd51353012b74e4d200bb446"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::setSBOTerm </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of the "sboTerm" attribute. </p>
<dl class="section user"><dt></dt><dd>Beginning with SBML Level 2 Version 2, objects derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> have an optional attribute named "sboTerm" for supporting the use of the Systems Biology Ontology. In SBML proper, the data type of the attribute is a string of the form "SBO:NNNNNNN", where "NNNNNNN" is a seven digit integer number; libSBML simplifies the representation by only storing the "NNNNNNN" integer portion. Thus, in libSBML, the "sboTerm" attribute on <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> has data type <code>int</code>, and <a class="el" href="class_s_b_o.html" title=" Facilities for using the Systems Biology Ontology. ">SBO</a> identifiers are stored simply as integers. </dd></dl>
<dl class="section user"><dt></dt><dd><a class="el" href="class_s_b_o.html" title=" Facilities for using the Systems Biology Ontology. ">SBO</a> terms are a type of optional annotation, and each different class of SBML object derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> imposes its own requirements about the values permitted for "sboTerm". More details can be found in SBML specifications for Level&#160;2 Version&#160;2 and above.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the NNNNNNN integer portion of the <a class="el" href="class_s_b_o.html" title=" Facilities for using the Systems Biology Ontology. ">SBO</a> identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a7b7b199563437a7977cc13cabb21ef63" title="Sets the value of the &quot;sboTerm&quot; attribute by string. ">setSBOTerm(const std::string &amp;sboid)</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="groups_example1_8cpp-example.html#a25">groups_example1.cpp</a>, and <a class="el" href="qual_example1_8cpp-example.html#a23">qual_example1.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a7b7b199563437a7977cc13cabb21ef63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::setSBOTerm </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sboid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of the "sboTerm" attribute by string. </p>
<dl class="section user"><dt></dt><dd>Beginning with SBML Level 2 Version 2, objects derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> have an optional attribute named "sboTerm" for supporting the use of the Systems Biology Ontology. In SBML proper, the data type of the attribute is a string of the form "SBO:NNNNNNN", where "NNNNNNN" is a seven digit integer number; libSBML simplifies the representation by only storing the "NNNNNNN" integer portion. Thus, in libSBML, the "sboTerm" attribute on <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> has data type <code>int</code>, and <a class="el" href="class_s_b_o.html" title=" Facilities for using the Systems Biology Ontology. ">SBO</a> identifiers are stored simply as integers. </dd></dl>
<dl class="section user"><dt></dt><dd><a class="el" href="class_s_b_o.html" title=" Facilities for using the Systems Biology Ontology. ">SBO</a> terms are a type of optional annotation, and each different class of SBML object derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> imposes its own requirements about the values permitted for "sboTerm". More details can be found in SBML specifications for Level&#160;2 Version&#160;2 and above.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sboid</td><td>the <a class="el" href="class_s_b_o.html" title=" Facilities for using the Systems Biology Ontology. ">SBO</a> identifier string of the form "SBO:NNNNNNN".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a37287e48bd51353012b74e4d200bb446" title="Sets the value of the &quot;sboTerm&quot; attribute. ">setSBOTerm(int value)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab78ca6ed2b4e131061fd5f8669e4e27e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Rule::setUnits </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the units for this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sname</td><td>the identifier of the units.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The attribute "units" exists on SBML Level&#160;1 ParameterRule objects only. It is not present in SBML Levels&#160;2 and&#160;3. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3b1bbfe22bad0dbc577b61c529f37bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::setUserData </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the user data of this element. </p>
<dl class="section user"><dt></dt><dd>The user data associated with an SBML object can be used by an application developer to attach custom information to that object in the model. In case of a deep copy, this attribute will passed as it is. The attribute will never be interpreted by libSBML.</dd></dl>
<dl class="section user"><dt></dt><dd>The user data associated with an SBML object can be used by an application developer to attach custom information to that object in the model. In case of a deep copy, this data will passed as-is. The data attribute will never be interpreted by libSBML.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userData</td><td>specifies the new user data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a2ea784a5a8a3594270dfc5b5e83dc315"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Rule::setVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the "variable" attribute value of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> object. </p>
<dl class="section user"><dt></dt><dd>In SBML Level&#160;1, the different rule types each have a different name for the attribute holding the reference to the object constituting the left-hand side of the rule. (E.g., for SBML Level&#160;1's SpeciesConcentrationRule the attribute is "species", for CompartmentVolumeRule it is "compartment", etc.) In SBML Levels&#160;2 and&#160;3, the only two types of <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> objects with a left-hand side object reference are <a class="el" href="class_assignment_rule.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule</a> and <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a>, and both of them use the same name for attribute: "variable". In order to make it easier for application developers to work with all Levels of SBML, libSBML uses a uniform name for all such attributes, and it is "variable", regardless of whether Level&#160;1 rules or Level&#160;2&ndash;3 rules are being used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>the identifier of a <a class="el" href="class_compartment.html" title=" An SBML compartment, where species are located. ">Compartment</a>, <a class="el" href="class_species.html" title=" An SBML species  a pool of entities. ">Species</a> or <a class="el" href="class_parameter.html" title=" An SBML parameter: a named symbol with a value. ">Parameter</a> elsewhere in the enclosing <a class="el" href="class_model.html" title=" An SBML model. ">Model</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da2018dcd1ec4e8d61debae043b1697d4e">LIBSBML_INVALID_ATTRIBUTE_VALUE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae8317d5157b70e4f1bc68e33e5c84001"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * SBase::toSBML </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string consisting of a partial SBML corresponding to just this object. </p>
<dl class="section return"><dt>Returns</dt><dd>the partial SBML that describes this SBML object.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><span class="warning">This is primarily provided for testing and debugging purposes. It may be removed in a future version of libSBML.</span> </dd></dl>

</div>
</div>
<a class="anchor" id="a5c949d524aca47b84b18b57b76e6ee0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_x_m_l_node.html">XMLNode</a>* SBase::toXMLNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this element as an <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>this element as an <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><span class="warning">This operation is computationally expensive, because the element has to be fully serialized to a string and then parsed into the <a class="el" href="class_x_m_l_node.html" title=" A node in libSBML&#39;s XML document tree. ">XMLNode</a> structure. Attempting to convert a large tree structure (e.g., a large <a class="el" href="class_model.html" title=" An SBML model. ">Model</a>) may consume significant computer memory and time.</span> </dd></dl>

</div>
</div>
<a class="anchor" id="a9121d6a4f7401fe957cc75647a1e95ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::unsetAnnotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the value of the "annotation" subelement of this SBML object. </p>
<p>Whereas the <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> "notes" subelement is a container for content to be shown directly to humans, the "annotation" element is a container for optional software-generated content <em>not</em> meant to be shown to humans. Every object derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> can have its own value for "annotation". The element's content type is <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls" target="_blank">XML type "any"</a>, allowing essentially arbitrary well-formed XML data content.</p>
<p>SBML places a few restrictions on the organization of the content of annotations; these are intended to help software tools read and write the data as well as help reduce conflicts between annotations added by different tools. Please see the SBML specifications for more details.</p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. This particular function only does one thing irrespective of user input or object state, and thus will only return a single value: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a4fbf6701023075573bd76fa0bd276291" title="Returns the content of the &quot;annotation&quot; subelement of this object as a tree of XMLNode objects...">getAnnotation()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adbff50c6c73c044a5c8e29e6b5dcefc6" title="Returns the content of the &quot;annotation&quot; subelement of this object as a character string. ">getAnnotationString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a279ce55f23330dc6bb0231774adfc42b" title="Predicate returning true if this object&#39;s &quot;annotation&quot; subelement exists and has content. ">isSetAnnotation()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a11d9c02a3690d9a13362835ef0133125" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object. ">setAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a75b1541bd854ad7edfe0aff79ab3231f" title="Sets the value of the &quot;annotation&quot; subelement of this SBML object. ">setAnnotation(const std::string&amp; annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#accc96fb06a79df769eb3669e090771e5" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object. ">appendAnnotation(const XMLNode* annotation)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a118148398f5c626bf9697887296f97b8" title="Appends the given annotation to the &quot;annotation&quot; subelement of this object. ">appendAnnotation(const std::string&amp; annotation)</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="unset_annotation_8cpp-example.html#a8">unsetAnnotation.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a1e89a7890f2fb291f1ba4c38866d1dcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::unsetCVTerms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the list of <a class="el" href="class_c_v_term.html" title=" A MIRIAM-compliant controlled vocabulary term. ">CVTerm</a> objects attached to this SBML object. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a65f77b6aa5f6f5d80b2d01558f7496f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::unsetId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the value of the "id" attribute of this SBML object. </p>
<dl class="section user"><dt></dt><dd>The identifier given by an object's "id" attribute value is used to identify the object within the SBML model definition. Other objects can refer to the component using this identifier. The data type of "id" is always <code>SId</code> or a type derived from that, such as <code>UnitSId</code>, depending on the object in question. All data types are defined as follows: <pre style="margin-left: 2em; border: none; font-weight: bold; color: black">
     letter ::= 'a'..'z','A'..'Z'
     digit  ::= '0'..'9'
     idChar ::= letter | digit | '_'
     SId    ::= ( letter | '_' ) idChar*
   </pre> The characters <code>(</code> and <code>)</code> are used for grouping, the character <code>*</code> "zero or more times", and the character <code>|</code> indicates logical "or". The equality of SBML identifiers is determined by an exact character sequence match; i.e., comparisons must be performed in a case-sensitive manner. This applies to all uses of <code>SId</code>, <code>SIdRef</code>, and derived types.</dd></dl>
<p>Users need to be aware of some important API issues that are the result of the history of SBML and libSBML. Prior to SBML Level&#160;3 Version&#160;2, SBML defined "id" and "name" attributes on only a subset of SBML objects. To simplify the work of programmers, libSBML's API provided get, set, check, and unset on the <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> object class itself instead of on individual subobject classes. This made the get/set/etc. methods uniformly available on all objects in the libSBML API. LibSBML simply returned empty strings or otherwise did not act when the methods were applied to SBML objects that were not defined by the SBML specification to have "id" or "name" attributes. Additional complications arose with the rule and assignment objects: <a class="el" href="class_initial_assignment.html" title=" An SBML initial assignment, evaluated once only. ">InitialAssignment</a>, <a class="el" href="class_event_assignment.html" title=" An assignment to a variable by an SBML event. ">EventAssignment</a>, <a class="el" href="class_assignment_rule.html" title=" An SBML assignment rule representing x = f(Y). ">AssignmentRule</a>, and <a class="el" href="class_rate_rule.html" title=" An SBML rate rule representing dx/dt = f(Y). ">RateRule</a>. In early versions of SBML, the rule object hierarchy was different, and in addition, then as now, they possess different attributes: "variable" (for the rules and event assignments), "symbol" (for initial assignments), or neither (for algebraic rules). Prior to SBML Level&#160;3 Version&#160;2, <a class="el" href="class_s_base.html#a8bd7cb0de43db3680bd1eeb30022fcd3" title="Returns the value of the &quot;id&quot; attribute of this SBML object, if it has one, or the &quot;variable&quot; attribu...">getId()</a> would always return an empty string, and <a class="el" href="class_s_base.html#a20e059dca5f0e97bdc7dc2e8fd3e4c35" title="Predicate returning true if a call to getId() returns a non-empty string. ">isSetId()</a> would always return <code>false</code> for objects of these classes.</p>
<p>With the addition of "id" and "name" attributes on <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> in Level&#160;3 Version&#160;2, it became necessary to introduce a new way to interact with the attributes more consistently in libSBML to avoid breaking backward compatibility in the behavior of the original "id" methods. For this reason, libSBML provides four functions (<a class="el" href="class_s_base.html#acd5e8dc937c46ace3af5125c8674c199" title="Returns the value of the &quot;id&quot; attribute of this SBML object. ">getIdAttribute()</a>, <a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object. ">setIdAttribute()</a>, <a class="el" href="class_s_base.html#ad201f20c9527cff5daf5d05bf49aac8c" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set. ">isSetIdAttribute()</a>, and <a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object. ">unsetIdAttribute()</a>) that always act on the actual "id" attribute inherited from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a>, regardless of the object's type. <b>These new methods should be used instead of the older <a class="el" href="class_s_base.html#a8bd7cb0de43db3680bd1eeb30022fcd3" title="Returns the value of the &quot;id&quot; attribute of this SBML object, if it has one, or the &quot;variable&quot; attribu...">getId()</a>/setId()/etc. methods</b> unless the old behavior is somehow necessary. Regardless of the Level and Version of the SBML, these functions allow client applications to use more generalized code in some situations (for instance, when manipulating objects that are all known to have identifiers). If the object in question does not posess an "id" attribute according to the SBML specification for the Level and Version in use, libSBML will not allow the identifier to be set, nor will it read or write "id" attributes for those objects.</p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#acd5e8dc937c46ace3af5125c8674c199" title="Returns the value of the &quot;id&quot; attribute of this SBML object. ">getIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object. ">setIdAttribute(const std::string&amp; sid)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#ad201f20c9527cff5daf5d05bf49aac8c" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set. ">isSetIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a1bfd93ef72d0f624964fcfd7a8d5cdfb" title="Unsets the value of the &quot;id&quot; attribute of this SBML object. ">unsetIdAttribute()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_model.html#a03389e655c02bcd4059098281272ecf3">Model</a>, <a class="el" href="class_layout.html#af4982549af923b69b15b953f6edda15e">Layout</a>, <a class="el" href="class_event.html#a0701f940cf25390e58a63ce6872f8aef">Event</a>, <a class="el" href="class_render_information_base.html#a224d410195df017468be55d64a2cfd70">RenderInformationBase</a>, <a class="el" href="class_color_definition.html#accb73d54a9ca9e235e97315bccce0dff">ColorDefinition</a>, <a class="el" href="class_graphical_primitive1_d.html#a415bf5e40dab8039039538e52775c881">GraphicalPrimitive1D</a>, <a class="el" href="class_gradient_base.html#a58c431cc462c4eac89dbf566bed89ed0">GradientBase</a>, <a class="el" href="class_group.html#aebca8f9f8f210ddcc51c516e07edf60e">Group</a>, <a class="el" href="class_input.html#a632e37f0f8f91c37bc126f18a15eea75">Input</a>, <a class="el" href="class_qualitative_species.html#a384e5340f7602b1cdf7ecb71d39a459f">QualitativeSpecies</a>, <a class="el" href="class_objective.html#a81017dda4d4d023eaaa7cb8bec74e8bc">Objective</a>, <a class="el" href="class_gene_product_association.html#a2ab9150d533a14201f58c0669077cd32">GeneProductAssociation</a>, <a class="el" href="class_output.html#a9c990fca391b3b59b3c451577eece6d2">Output</a>, <a class="el" href="class_flux_objective.html#a400a7bd7ba2b3e637ce31e96ef71a39f">FluxObjective</a>, <a class="el" href="class_gene_product.html#a0e71c628cb51b7245cdf22a44345ec86">GeneProduct</a>, <a class="el" href="class_submodel.html#a1f46eb5e0ca3441cb9b00dccbcc73012">Submodel</a>, <a class="el" href="class_image.html#a38fb5daf26be75e12a851fb548bfd992">Image</a>, <a class="el" href="class_member.html#a7e0de737dcb784f44c24817d728f275e">Member</a>, <a class="el" href="class_line_ending.html#acba364347d92605101db798a766efbfc">LineEnding</a>, <a class="el" href="class_dimensions.html#aa5f94cdaad9cfb9c32f286501f938ac7">Dimensions</a>, <a class="el" href="class_gene_product_ref.html#a6cf997d4619856924e00dce503ba50b8">GeneProductRef</a>, <a class="el" href="class_style.html#aa8b8f2901d8a4158a8e74d2478844e2f">Style</a>, <a class="el" href="class_graphical_object.html#afb8d1336d8ee0df1c4ab30081005217b">GraphicalObject</a>, <a class="el" href="class_transition.html#a92c11e7c7e7a11ae32d9730f45bbb1e8">Transition</a>, <a class="el" href="class_list_of_members.html#a8125ffb91d2cd3dfc11e318ffe96aac8">ListOfMembers</a>, <a class="el" href="class_simple_species_reference.html#a506860c78f48bc10a424c97c6789d0db">SimpleSpeciesReference</a>, <a class="el" href="class_outward_binding_site.html#a00e5bc5e7a56fb10eefce23616725179">OutwardBindingSite</a>, <a class="el" href="class_point.html#aea6b6f9694da6f3f4cd21df715a35a25">Point</a>, <a class="el" href="class_flux_bound.html#a803c042e9d9d8302ea30233ff260c0bf">FluxBound</a>, <a class="el" href="class_external_model_definition.html#a354bf4486911a37f1938afe37a9a3a74">ExternalModelDefinition</a>, <a class="el" href="class_sub_list_of_species_features.html#ab8bc098e2cad8e30f1ba80c7913adb99">SubListOfSpeciesFeatures</a>, <a class="el" href="class_deletion.html#a8c1b6ed323fbd0e524ae9f2b5f3290bb">Deletion</a>, <a class="el" href="class_bounding_box.html#aec1e2f3d070b2766f7bbb2b1e7eeece9">BoundingBox</a>, <a class="el" href="class_multi_species_type.html#af97b244a54b70f8250b01f670f709755">MultiSpeciesType</a>, <a class="el" href="class_species_feature.html#a785ac490618c9576370fc2627a1e80e3">SpeciesFeature</a>, <a class="el" href="class_port.html#ad420b000f3411bf042d2ccd5d1331b88">Port</a>, <a class="el" href="class_species_feature_type.html#a2837c700856b366e3ca958d18181f914">SpeciesFeatureType</a>, <a class="el" href="class_species_type_instance.html#a5810296ec2d8826587f8d016810dd2aa">SpeciesTypeInstance</a>, <a class="el" href="class_species_type_component_map_in_product.html#a62dc76a26caf4d8a3827c717a2a21946">SpeciesTypeComponentMapInProduct</a>, <a class="el" href="class_species_type_component_index.html#a67fcd88ced85bb1551789a7cc5fb6ce9">SpeciesTypeComponentIndex</a>, <a class="el" href="class_in_species_type_bond.html#a3b9f535f8b24b6309039ec17275c17e3">InSpeciesTypeBond</a>, <a class="el" href="class_possible_species_feature_value.html#abc416c7a8e3ee128b5469a3a1881627a">PossibleSpeciesFeatureValue</a>, <a class="el" href="class_gene_association.html#a85c0077563ea7cafa8cb24a6c5b4a9b7">GeneAssociation</a>, and <a class="el" href="class_compartment_reference.html#abba6d8b7ad411bd2e44243426b3b3402">CompartmentReference</a>.</p>

</div>
</div>
<a class="anchor" id="a1bfd93ef72d0f624964fcfd7a8d5cdfb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::unsetIdAttribute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the value of the "id" attribute of this SBML object. </p>
<p>Most (but not all) objects in SBML include two common attributes: "id" and "name". The identifier given by an object's "id" attribute value is used to identify the object within the SBML model definition. Other objects can refer to the component using this identifier.</p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#acd5e8dc937c46ace3af5125c8674c199" title="Returns the value of the &quot;id&quot; attribute of this SBML object. ">getIdAttribute()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a8a342a0f8387842fb6700c50c4c43344" title="Sets the value of the &quot;id&quot; attribute of this SBML object. ">setIdAttribute(const std::string&amp; sid)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#ad201f20c9527cff5daf5d05bf49aac8c" title="Predicate returning true if this object&#39;s &quot;id&quot; attribute is set. ">isSetIdAttribute()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a98c955421c92c28351610ea811ecb4fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::unsetMetaId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the value of the "metaid" attribute of this SBML object. </p>
<dl class="section user"><dt></dt><dd>The optional attribute named "metaid", present on every major SBML component type, is for supporting metadata annotations using RDF (<a href="http://www.w3.org/RDF/">Resource Description Format</a>). The attribute value has the data type <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a>, the XML identifier type, which means each "metaid" value must be globally unique within an SBML file. The latter point is important, because the uniqueness criterion applies across <em>any</em> attribute with type <code>ID</code> anywhere in the file, not just the "metaid" attribute used by SBML&mdash;something to be aware of if your application-specific XML content inside the "annotation" subelement happens to use the XML <code>ID</code> type. Although SBML itself specifies the use of <a href="http://www.w3.org/TR/REC-xml/#id">XML <code>ID</code></a> only for the "metaid" attribute, SBML-compatible applications should be careful if they use XML <code>ID</code>'s in XML portions of a model that are not defined by SBML, such as in the application-specific content of the "annotation" subelement. Finally, note that LibSBML does not provide an explicit XML <code>ID</code> data type; it uses ordinary character strings, which is easier for applications to support.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa197c1c8a34df2cbd05a58f6cbc41841"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::unsetModelHistory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the <a class="el" href="class_model_history.html" title=" MIRIAM-compliant data about a model&#39;s history. ">ModelHistory</a> object attached to this object. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In SBML Level&#160;2, model history annotations were only permitted on the <a class="el" href="class_model.html" title=" An SBML model. ">Model</a> element. In SBML Level&#160;3, they are permitted on all SBML components derived from <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a4cf8825fb83925a508eaac3d7f8fbb8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::unsetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the value of the "name" attribute of this SBML object. </p>
<dl class="section user"><dt></dt><dd>In SBML Level&#160;3 Version&#160;2, the "id" and "name" attributes were moved to <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> directly, instead of being defined individually for many (but not all) objects. LibSBML has for a long time provided functions defined on <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> itself to get, set, and unset those attributes, which would fail or otherwise return empty strings if executed on any object for which those attributes were not defined. Now that all <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> objects define those attributes, those functions now succeed for any object with the appropriate level and version.</dd></dl>
<p>The "name" attribute is optional and is not intended to be used for cross-referencing purposes within a model. Its purpose instead is to provide a human-readable label for the component. The data type of "name" is the type <code>string</code> defined in XML Schema. SBML imposes no restrictions as to the content of "name" attributes beyond those restrictions defined by the <code>string</code> type in XML Schema.</p>
<p>The recommended practice for handling "name" is as follows. If a software tool has the capability for displaying the content of "name" attributes, it should display this content to the user as a component's label instead of the component's "id". If the user interface does not have this capability (e.g., because it cannot display or use special characters in symbol names), or if the "name" attribute is missing on a given component, then the user interface should display the value of the "id" attribute instead. (Script language interpreters are especially likely to display "id" instead of "name".)</p>
<p>As a consequence of the above, authors of systems that automatically generate the values of "id" attributes should be aware some systems may display the "id"'s to the user. Authors therefore may wish to take some care to have their software create "id" values that are: (a) reasonably easy for humans to type and read; and (b) likely to be meaningful, for example by making the "id" attribute be an abbreviated form of the name attribute value.</p>
<p>An additional point worth mentioning is although there are restrictions on the uniqueness of "id" values, there are no restrictions on the uniqueness of "name" values in a model. This allows software applications leeway in assigning component identifiers.</p>
<p>Regardless of the level and version of the SBML, these functions allow client applications to use more generalized code in some situations (for instance, when manipulating objects that are all known to have names). If the object in question does not posess a "name" attribute according to the SBML specification for the Level and Version in use, libSBML will not allow the name to be set, nor will it read or write "name" attributes for those objects.</p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#ab24c4b22c1ac115368032d558b6fe4e4" title="Returns the value of the &quot;name&quot; attribute of this SBML object. ">getName()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a1531f729b16689aba3fb7f3567202a7c" title="Sets the value of the &quot;name&quot; attribute of this SBML object. ">setName(const std::string&amp; sid)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a541c62b7ad823db1f14674386a61b52f" title="Predicate returning true if this object&#39;s &quot;name&quot; attribute is set. ">isSetName()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_compartment.html#aaeb009c1619b3a61b4a54be3eab4d4fd">Compartment</a>, <a class="el" href="class_species.html#a8a2e7a03df6c26dfe554474e9e90f957">Species</a>, <a class="el" href="class_model.html#a1c272e1c5658984d36c2db89a66b0af8">Model</a>, <a class="el" href="class_layout.html#a5345af53212b7fe137997b1a90b1d7a1">Layout</a>, <a class="el" href="class_event.html#acaa462aa3f6001d93d046d5d1558af5d">Event</a>, <a class="el" href="class_reaction.html#aeb4ac9c47aa66c9ce1e8745a7b2c4013">Reaction</a>, <a class="el" href="class_parameter.html#a0d83c3c9fa5782df7dac35032e3e85d8">Parameter</a>, <a class="el" href="class_render_information_base.html#a31a28026c8cccb5f6502fcbe8e80778a">RenderInformationBase</a>, <a class="el" href="class_color_definition.html#aa4aa579f047158b109538e6a2111c0b0">ColorDefinition</a>, <a class="el" href="class_unit_definition.html#a329b088e161a60f43188bc4099fe6d8c">UnitDefinition</a>, <a class="el" href="class_gradient_base.html#a1a3c7ff2f3c4e97499cbdc24230f1076">GradientBase</a>, <a class="el" href="class_group.html#a1e713c22616fe1548dbc0a8e9d7ee08e">Group</a>, <a class="el" href="class_input.html#a1fb98b4415b9d004f15178822a1964b0">Input</a>, <a class="el" href="class_qualitative_species.html#aef5c9234fd6c71936d974de775698338">QualitativeSpecies</a>, <a class="el" href="class_output.html#af7dcabc3a32b329d0067ab14ba6ae8a9">Output</a>, <a class="el" href="class_objective.html#a0636dd451d5ccf749cc5dd712f8b75f7">Objective</a>, <a class="el" href="class_gene_product_association.html#aacdd488698f7380af32a63510c4c60e9">GeneProductAssociation</a>, <a class="el" href="class_submodel.html#a1886909941b7442f8dc04655db3c35a2">Submodel</a>, <a class="el" href="class_function_definition.html#a38dbc84be1d88b8ecb1bfe4397a815d9">FunctionDefinition</a>, <a class="el" href="class_flux_objective.html#af503748e70c93761a67fccb65239ee01">FluxObjective</a>, <a class="el" href="class_gene_product.html#a7e6ea05af34b020ad5cb575a2f4ed6b9">GeneProduct</a>, <a class="el" href="class_member.html#aeb354b8d8badaa51ec4f2d404c60e8d8">Member</a>, <a class="el" href="class_outward_binding_site.html#a6177657ab8c2c84e56a962d22cdd8130">OutwardBindingSite</a>, <a class="el" href="class_transformation.html#a46bb753804d6964f3fa66a4047f7c937">Transformation</a>, <a class="el" href="class_gene_product_ref.html#a9a1b1283cc729ff68cdd76a29c458988">GeneProductRef</a>, <a class="el" href="class_flux_bound.html#ac42d942ecbae6657be036094f2a2a3c8">FluxBound</a>, <a class="el" href="class_external_model_definition.html#a74410bfdb94578aadfa18134a91506f9">ExternalModelDefinition</a>, <a class="el" href="class_style.html#a962488bf464b2eaafe78c2d950d2ad2d">Style</a>, <a class="el" href="class_list_of_members.html#abb8ece42ed5552807a1ded0fc076a0ec">ListOfMembers</a>, <a class="el" href="class_transition.html#a58d47c51f247457bba0a9c7c58e002ee">Transition</a>, <a class="el" href="class_sub_list_of_species_features.html#a30f9615bd6998f474d9ceede9060ef6f">SubListOfSpeciesFeatures</a>, <a class="el" href="class_compartment_type.html#ab780f9a54eccf11f4435bddfc9b669db">CompartmentType</a>, <a class="el" href="class_simple_species_reference.html#acc2b026111435e64e027915246fe68b0">SimpleSpeciesReference</a>, <a class="el" href="class_species_type.html#a3c98a6b9fb070b4387305882823df82d">SpeciesType</a>, <a class="el" href="class_deletion.html#accb6fc5bbe73d7995642d1bd99dd449e">Deletion</a>, <a class="el" href="class_multi_species_type.html#a55c7cab1ebdefe126606af4bf0a1db5e">MultiSpeciesType</a>, <a class="el" href="class_species_feature.html#a8b662cf984dcd667ee817cf00b8b4af8">SpeciesFeature</a>, <a class="el" href="class_species_type_component_map_in_product.html#a6fc17dfd78bb311f1e0ad45367d1d028">SpeciesTypeComponentMapInProduct</a>, <a class="el" href="class_species_feature_type.html#ab8d08012137df4e665b5652b54300e95">SpeciesFeatureType</a>, <a class="el" href="class_species_type_instance.html#a3e316ff73b3b26c16a986e6f6f92c121">SpeciesTypeInstance</a>, <a class="el" href="class_species_type_component_index.html#a1568ede81d434848a6ecf2ecbd0e2407">SpeciesTypeComponentIndex</a>, <a class="el" href="class_port.html#a1397e9032c461d38c8fb9c8a9e23b8d1">Port</a>, <a class="el" href="class_possible_species_feature_value.html#a5db14ba6a2deda95537e3834efe80835">PossibleSpeciesFeatureValue</a>, <a class="el" href="class_in_species_type_bond.html#a6c4602bcc6acea1dcdcdbb2c9142309f">InSpeciesTypeBond</a>, and <a class="el" href="class_compartment_reference.html#a01490bd825496d6cf7168f391e5bccbc">CompartmentReference</a>.</p>

</div>
</div>
<a class="anchor" id="a89f626f2593df8e83da4cdbfe79142f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::unsetNotes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the value of the "notes" subelement of this SBML object. </p>
<p>The optional SBML element named "notes", present on every major SBML component type, is intended as a place for storing optional information intended to be seen by humans. An example use of the "notes" element would be to contain formatted user comments about the model element in which the "notes" element is enclosed. Every object derived directly or indirectly from type <a class="el" href="class_s_base.html" title=" SBML&#39;s SBase class, base class of most SBML objects. ">SBase</a> can have a separate value for "notes", allowing users considerable freedom when adding comments to their models.</p>
<p>The format of "notes" elements must be <a href="http://www.w3.org/TR/xhtml1/" target="_blank">XHTML&#160;1.0</a>. To help verify the formatting of "notes" content, libSBML provides the static utility method <a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content...">SyntaxChecker::hasExpectedXHTMLSyntax()</a>; however, readers are urged to consult the appropriate <a href="http://sbml.org/Documents/Specifications" target="_blank">SBML specification document</a> for the Level and Version of their model for more in-depth explanations. The SBML Level&#160;2 and&#160;3 specifications have considerable detail about how "notes" element content must be structured.</p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. This particular function only does one thing irrespective of user input or object state, and thus will only return a single value: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_s_base.html#a6eee96ee206a55837c0d7b936f20f14d" title="Returns the content of the &quot;notes&quot; subelement of this object as a string. ">getNotesString()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#aeff0554efc75440b5375b35a4d188ea0" title="Predicate returning true if this object&#39;s &quot;notes&quot; subelement exists and has content. ">isSetNotes()</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a611a4bd98a4e32e3573980b2481ce77e" title="Sets the value of the &quot;notes&quot; subelement of this SBML object. ">setNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a478ad1e0e2bb2dc27a9de6ab9bac4bf2" title="Sets the value of the &quot;notes&quot; subelement of this SBML object to a copy of the string notes...">setNotes(const std::string&amp; notes, bool addXHTMLMarkup)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#adb8c800163c108a27880bd644d7767ad" title="Appends the given notes to the &quot;notes&quot; subelement of this object. ">appendNotes(const XMLNode* notes)</a> </dd>
<dd>
<a class="el" href="class_s_base.html#a33da5a2b0b03cbe6af69730869e35212" title="Appends the given notes to the &quot;notes&quot; subelement of this object. ">appendNotes(const std::string&amp; notes)</a> </dd>
<dd>
<a class="el" href="class_syntax_checker.html#ade6c33a7180bbc7bc70b4421b917a7b0" title="Returns true or false depending on whether the given XMLNode object contains valid XHTML content...">SyntaxChecker::hasExpectedXHTMLSyntax()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="unset_notes_8cpp-example.html#a8">unsetNotes.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a317ea060a5c3f97576188a22e670e683"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::unsetSBOTerm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the value of the "sboTerm" attribute of this SBML object. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8b39106dd241502c4f7267b1f370190e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Rule::unsetUnits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the "units" for this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The attribute "units" exists on SBML Level&#160;1 ParameterRule objects only. It is not present in SBML Levels&#160;2 and&#160;3. </dd></dl>

</div>
</div>
<a class="anchor" id="abd78c4290e103245ce49b92b5e229375"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SBase::unsetUserData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the user data of this element. </p>
<dl class="section user"><dt></dt><dd>The user data associated with an SBML object can be used by an application developer to attach custom information to that object in the model. In case of a deep copy, this attribute will passed as it is. The attribute will never be interpreted by libSBML.</dd></dl>
<dl class="section user"><dt></dt><dd>The user data associated with an SBML object can be used by an application developer to attach custom information to that object in the model. In case of a deep copy, this data will passed as-is. The data attribute will never be interpreted by libSBML.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad8195e91304799d65e2a198352a49217"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Rule::unsetVariable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the value of the "variable" attribute of this <a class="el" href="class_rule.html" title=" Parent class for SBML rules in libSBML. ">Rule</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>integer value indicating success/failure of the function. The value is drawn from the enumeration <a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886d" title="LibSBML diagnostic return codes. ">OperationReturnValues_t</a>. The possible values returned by this function are: <ul>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886daf67ea900ebcd56036019237463be26b3">LIBSBML_OPERATION_SUCCESS</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886dac83e0b4b9acff7bc357e9ebb263236da">LIBSBML_OPERATION_FAILED</a> </li>
<li><a class="el" href="operation_return_values_8h.html#a87d90022619ee855654b2b8f4997886da354242392bc8b59872de6bd6d0a3b9fb">LIBSBML_UNEXPECTED_ATTRIBUTE</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_rule.html#a2ea784a5a8a3594270dfc5b5e83dc315" title="Sets the &quot;variable&quot; attribute value of this Rule object. ">setVariable(const std::string&amp; sid)</a> </dd>
<dd>
<a class="el" href="class_rule.html#a8a5fcb43d75b82d54382d2a28eea8e45" title="Predicate returning true if this Rule&#39;s &quot;variable&quot; attribute is set. ">isSetVariable()</a> </dd>
<dd>
<a class="el" href="class_rule.html#a21b6103384ba971fb7b1d85584566c7c" title="Get the value of the &quot;variable&quot; attribute of this Rule object. ">getVariable()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for Doxygen -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      Visit <a href="http://sbml.org">SBML.org</a> for more information
    about SBML and libSBML.
    </li>
   </ul>
</div>
</body>
</html>
